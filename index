<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard Fundamental DCF v2.2-TITULOS-NEGRO</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
  <style>
    :root {
      color-scheme: dark;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }

    .no-space {
      white-space: nowrap;
      font-variant-numeric: tabular-nums;
    }


    .module-card {
      border: 1px solid rgba(148, 163, 184, 0.2);
      transition: all 0.3s ease;
    }

    .module-card summary {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-radius: 1rem;
      transition: background-color 0.2s ease;
    }

    .module-card summary:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .dark .module-card summary:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .module-card summary::marker {
      display: none;
    }

    .chevron {
      transition: transform 0.3s ease;
    }

    .module-card[open] .chevron {
      transform: rotate(180deg);
    }

    .module-body {
      animation: fade 0.3s ease;
      padding: 1rem;
    }

    /* Module Color Classes */
    .module-0 {
      background: rgba(219, 234, 254, 0.5);
    }

    .dark .module-0 {
      background: rgba(30, 58, 138, 0.2);
    }

    .module-1 {
      background: rgba(243, 232, 255, 0.5);
    }

    .dark .module-1 {
      background: rgba(88, 28, 135, 0.2);
    }

    .module-2 {
      background: rgba(207, 250, 254, 0.5);
    }

    .dark .module-2 {
      background: rgba(22, 78, 99, 0.2);
    }

    .module-3 {
      background: rgba(220, 252, 231, 0.5);
    }

    .dark .module-3 {
      background: rgba(20, 83, 45, 0.2);
    }

    .module-4 {
      background: rgba(254, 249, 195, 0.5);
    }

    .dark .module-4 {
      background: rgba(113, 63, 18, 0.2);
    }

    .module-5 {
      background: rgba(254, 226, 226, 0.5);
    }

    .dark .module-5 {
      background: rgba(127, 29, 29, 0.2);
    }

    .module-6 {
      background: rgba(224, 231, 255, 0.5);
    }

    .dark .module-6 {
      background: rgba(49, 46, 129, 0.2);
    }

    .module-7 {
      background: rgba(209, 250, 229, 0.5);
    }

    .dark .module-7 {
      background: rgba(6, 78, 59, 0.2);
    }

    .module-8 {
      background: rgba(252, 231, 243, 0.5);
    }

    .dark .module-8 {
      background: rgba(131, 24, 67, 0.2);
    }

    @keyframes fade {
      from {
        opacity: 0.5;
      }

      to {
        opacity: 1;
      }
    }

    /* Tooltips mejorados para ratios */
    [data-tooltip] {
      position: relative;
      cursor: help;
    }

    [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      bottom: 100%;
      transform: translateX(-50%);
      padding: 12px 16px;
      background: rgba(15, 23, 42, 0.95);
      color: white;
      border-radius: 8px;
      font-size: 13px;
      white-space: pre-wrap;
      /* Permitir saltos de l√≠nea con \n */
      z-index: 1000;
      margin-bottom: 8px;
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3), 0 8px 10px -6px rgba(0, 0, 0, 0.2);
      pointer-events: none;
      min-width: 280px;
      max-width: 450px;
      width: max-content;
      text-align: left;
      line-height: 1.5;
      word-wrap: break-word;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    [data-tooltip]:hover::before {
      content: '';
      position: absolute;
      left: 50%;
      bottom: 100%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: rgba(15, 23, 42, 0.95);
      z-index: 1001;
      margin-bottom: -6px;
      pointer-events: none;
    }

    /* Print Styles */
    /* Print Styles */
    /* ============================================ */
    /* ESTILO "FIT TO PAGE" (HORIZONTAL COMPACTO) */
    /* ============================================ */
    @media print {
      @page {
        size: landscape;
        /* Fuerza hoja horizontal */
        margin: 5mm;
        /* M√°rgenes m√≠nimos para aprovechar el papel */
      }

      /* 1. ESCALADO GLOBAL (La clave para que quepa) */
      body {
        zoom: 75%;
        /* <--- ESTO ES LA CLAVE. Reduce todo al 75% del tama√±o original */
        width: 100% !important;
        background-color: white !important;
        color: #0f172a !important;
        font-family: 'Inter', sans-serif !important;
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      /* 2. OCULTAR ELEMENTOS INNECESARIOS */
      nav,
      button,
      .btn-back-dashboard,
      summary::after,
      .chevron,
      #file-input,
      label[for="file-input"],
      #data-status-msg,
      #placeholder-panel,
      #toggle-all-modules,
      #theme-toggle,
      #smart-sidebar,
      aside,
      .print-hidden-debug {
        display: none !important;
      }

      /* 3. REESTRUCTURACI√ìN DE LAYOUT (Aprovechar el ancho) */
      .max-w-\[1920px\],
      main,
      #executive-dashboard {
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 !important;
        padding: 0 !important;
        box-shadow: none !important;
      }

      /* Eliminar la columna lateral vac√≠a para que el contenido se expanda */
      .xl\:col-span-3 {
        width: 100% !important;
        grid-column: span 12 / span 12 !important;
        padding-right: 0 !important;
      }

      /* 4. COMPACTAR ESPACIOS (Menos aire, m√°s datos) */
      .gap-6 {
        gap: 1rem !important;
      }

      .p-6 {
        padding: 1rem !important;
      }

      .py-8 {
        padding-top: 1rem !important;
        padding-bottom: 1rem !important;
      }

      .space-y-8> :not([hidden])~ :not([hidden]) {
        margin-top: 1rem !important;
      }

      /* 5. PROTECCI√ìN DE CORTES (Evita gr√°ficos partidos) */
      .module-card,
      details,
      .bg-white,
      .rounded-xl,
      table {
        break-inside: avoid !important;
        /* No permitir partir por la mitad */
        page-break-inside: avoid !important;
      }

      /* Forzar salto de p√°gina limpio despu√©s del Dashboard Ejecutivo */
      #executive-dashboard {
        page-break-after: always;
      }

      /* 6. AJUSTE DE GR√ÅFICOS */
      canvas {
        max-height: 350px !important;
        /* Altura m√°xima controlada */
        width: 100% !important;
      }

      /* 7. EST√âTICA DE IMPRESI√ìN (Blanco y Negro limpio) */
      details {
        border: 1px solid #cbd5e1 !important;
        margin-bottom: 15px !important;
        box-shadow: none !important;
      }

      details[open] summary {
        background-color: #f1f5f9 !important;
        border-bottom: 1px solid #cbd5e1 !important;
        margin-bottom: 10px;
      }

      /* Texto negro puro para lectura */
      p,
      h1,
      h2,
      h3,
      h4,
      span,
      div {
        color: #000 !important;
      }

      /* Mantener colores sem√°nticos (verde/rojo) solo donde importa */
      .text-emerald-600,
      .text-green-600 {
        color: #059669 !important;
      }

      .text-red-600,
      .text-rose-600 {
        color: #dc2626 !important;
      }
    }

    /* ============================================ */
    /* TOOLTIPS EDUCATIVOS */
    /* ============================================ */

    /* Tooltip Container */
    [data-tooltip] {
      position: relative;
      cursor: help;
      text-decoration: underline dotted #94a3b8;
    }

    /* El Tooltip Invisible */
    [data-tooltip]:before {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-10px);
      width: 320px;
      max-width: 90vw;
      padding: 14px;
      border-radius: 10px;
      background: #1e293b;
      color: #f8fafc;
      font-size: 11px;
      line-height: 1.6;
      text-align: left;
      white-space: pre-wrap;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      pointer-events: none;
      z-index: 9999;
      box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.6);
      border: 1px solid #475569;
      font-family: 'Inter', system-ui, sans-serif;
    }

    /* La Flechita */
    [data-tooltip]:after {
      content: '';
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(0px);
      border: 7px solid transparent;
      border-top-color: #1e293b;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
      z-index: 9999;
    }

    /* Mostrar al Hover */
    [data-tooltip]:hover:before,
    [data-tooltip]:hover:after {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-8px);
    }

    /* Ajuste para tooltips en dark mode */
    .dark [data-tooltip]:before {
      background: #0f172a;
      /* Slate-950 */
      border-color: #334155;
    }

    .dark [data-tooltip]:after {
      border-top-color: #0f172a;
    }

    /* Dashboard Charts: Force canvas to fill container */
    #executive-dashboard canvas {
      height: 100% !important;
      width: 100% !important;
    }

    /* ============================================ */
    /* NAVIGATION: Clickable Dashboard Elements    */
    /* ============================================ */
    .dashboard-clickable {
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .dashboard-clickable:hover {
      opacity: 0.85;
      transform: scale(1.01);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .dark .dashboard-clickable:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    }

    /* Back to Dashboard Button */
    .btn-back-dashboard {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      font-size: 11px;
      font-weight: 600;
      color: #64748b;
      background: transparent;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
    }

    .btn-back-dashboard:hover {
      background: #f1f5f9;
      border-color: #94a3b8;
      color: #475569;
    }

    .dark .btn-back-dashboard {
      color: #94a3b8;
      border-color: #475569;
    }

    .dark .btn-back-dashboard:hover {
      background: #334155;
      border-color: #64748b;
      color: #e2e8f0;
    }
  </style>
</head>

<body class="bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-slate-100 min-h-screen">
  <nav class="sticky top-0 z-50 bg-slate-900 text-white shadow-lg border-b border-slate-800">
    <div class="max-w-[1920px] mx-auto px-6 py-3 flex justify-between items-center h-20">

      <!-- SECCI√ìN IZQUIERDA: CONTROLES -->
      <div class="flex-1 flex flex-col justify-center gap-2">
        <p class="text-[10px] text-blue-300 uppercase tracking-[0.2em] font-bold">Finanzas Corporativas</p>

        <div class="flex items-center gap-3">
          <!-- Input File Oculto -->
          <input type="file" id="file-input" class="hidden" accept=".xlsx,.xls,.xlsm,.xlsb" />

          <!-- Bot√≥n Carga (Label) -->
          <label for="file-input"
            class="px-4 py-1.5 bg-indigo-600 hover:bg-indigo-500 text-white text-xs font-bold uppercase rounded-lg shadow cursor-pointer transition-colors flex items-center gap-2">
            <span>üìÇ Carga de Datos</span>
          </label>

          <!-- Bot√≥n Calcular -->
          <button type="button" id="btn-calculate" disabled
            class="px-4 py-1.5 bg-emerald-600 hover:bg-emerald-500 disabled:opacity-50 disabled:cursor-not-allowed text-white text-xs font-bold uppercase rounded-lg shadow transition-colors flex items-center gap-2">
            <span>‚ö° Calcular Modelos</span>
          </button>

          <!-- Status -->
          <span id="data-status-msg" class="text-xs text-emerald-400 font-bold hidden animate-pulse">
            Datos Cargados ‚úîÔ∏è
          </span>
        </div>
      </div>

      <!-- SECCI√ìN CENTRAL: T√çTULOS -->
      <div class="flex-1 flex flex-col justify-center items-center text-center">
        <h1 class="text-2xl font-black uppercase tracking-tight text-white mb-0.5">
          AN√ÅLISIS FUNDAMENTAL INTEGRAL
        </h1>
        <h2 id="company-name" class="text-2xl font-black text-blue-200 uppercase tracking-tight min-h-[2rem]">
          <!-- Nombre din√°mico aqu√≠ -->
        </h2>
      </div>

      <!-- SECCI√ìN DERECHA: UTILIDADES -->
      <div class="flex-1 flex justify-end items-center gap-2">

        <!-- Bot√≥n Simulador Retorno (Redise√±ado: M√°s angosto, letra chica, texto apilado, palabras alineadas al centro) -->
        <button id="btn-simulador-retorno" onclick="scrollToElement('module-section-9')"
          class="px-2 py-1 rounded-lg bg-emerald-600 hover:bg-emerald-500 text-white transition-colors border border-emerald-500 hidden flex-row items-center gap-1.5 shadow-sm"
          title="Ir al Simulador de Retorno">
          <span class="text-lg">üí∞</span>
          <div class="flex flex-col leading-none text-[10px] font-bold uppercase text-center">
            <span>Simulador</span>
            <span>Retorno</span>
          </div>
        </button>

        <!-- Bot√≥n Imprimir (Con Texto "Informe Ejecutivo" en 2 l√≠neas alineado) -->
        <button onclick="prepareAndPrint()"
          class="px-2 py-1.5 rounded-lg bg-slate-800 hover:bg-slate-700 text-slate-300 hover:text-white transition-colors border border-slate-700 flex items-center gap-2"
          title="Imprimir Informe">
          <span class="text-lg">üñ®Ô∏è</span>
          <div class="hidden sm:flex flex-col leading-none text-[10px] font-bold uppercase text-center">
            <span>Informe</span>
            <span>Ejecutivo</span>
          </div>
        </button>

        <!-- Bot√≥n Expandir/Contraer Todo (Movido a la izquierda de Tema) -->
        <button id="toggle-all-modules" onclick="toggleAllModules()"
          class="p-2 rounded-lg bg-slate-800 hover:bg-slate-700 text-slate-300 hover:text-white transition-colors border border-slate-700 hidden"
          title="Expandir/Contraer todos los m√≥dulos">
          <span class="text-xl">‚ÜïÔ∏è</span>
        </button>

        <!-- Toggle Tema -->
        <button id="theme-toggle"
          class="p-2 rounded-lg bg-slate-800 hover:bg-slate-700 text-slate-300 hover:text-white transition-colors border border-slate-700 relative"
          title="Cambiar tema">
          <svg id="icon-light" class="w-6 h-6 hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
          </svg>
          <svg id="icon-dark" class="w-6 h-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
          </svg>
        </button>
      </div>

    </div>
  </nav>

  <!-- Executive Dashboard (Sticky Top after Nav) -->
  <div id="executive-dashboard" class="hidden w-full max-w-[1920px] mx-auto px-6 py-4 space-y-8 overflow-hidden"></div>

  <!-- BODY PRINCIPAL (Full Width) -->
  <main class="w-full max-w-[1920px] mx-auto px-6 py-8 space-y-8">

    <!-- Disclaimer / Status / Info Bar si es necesario en el futuro -->

    <!-- Panel de Placeholder (Estado Cero) -->
    <div id="placeholder-panel"
      class="rounded-3xl border-2 border-dashed border-slate-300 dark:border-slate-700 p-20 text-center text-slate-400 bg-slate-50 dark:bg-slate-800/50">
      <div class="flex flex-col items-center gap-4">
        <div class="text-6xl mb-2">üìä</div>
        <h3 class="text-xl font-bold text-slate-600 dark:text-slate-300">Esperando Datos</h3>
        <p class="max-w-md mx-auto">Sube un archivo Excel usando el bot√≥n "Carga de Datos" en la barra superior para
          comenzar el an√°lisis.</p>
      </div>
    </div>

    <!-- Panel de Resultados (Oculto Inicialmente) -->
    <div id="results-panel" class="hidden space-y-12">

      <!-- Layout Principal: 3 cols de contenido + 1 col de margen/dibujos -->
      <div class="grid grid-cols-1 xl:grid-cols-4 gap-8">

        <!-- Columna Lateral (Smart Sidebar Educativo) -->
        <aside id="smart-sidebar"
          class="hidden xl:block col-span-1 sticky top-24 h-[calc(100vh-6rem)] overflow-y-auto pl-6 space-y-6 transition-all duration-500">
          <!-- El contenido se inyecta din√°micamente v√≠a JS -->
        </aside>

        <!-- Columna Principal (M√≥dulos) -->
        <div class="xl:col-span-3 pr-12">
          <div id="modules-container" class="space-y-3"></div>
        </div>

      </div>

      <!-- Executive Dashboard moved to top of page -->
    </div>

  </main>

  <script>
    async function generateProfessionalReport() {
      if (!moduleResults || !financialData) {
        alert("Por favor, cargue datos y calcule los modelos antes de generar el reporte actual (Datos no encontrados en memoria).");
        return;
      }

      const mr = moduleResults;
      const fd = financialData;
      const companyName = (fd.datos.empresa || 'Empresa').toUpperCase();

      // Helpers
      const fNum = (v, d = 2) => (v !== null && v !== undefined) ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: d, maximumFractionDigits: d }).format(v) : '<span style="color:#cbd5e1">N/A</span>';
      const fPct = (v, d = 2) => (v !== null && v !== undefined) ? (v * 100).toFixed(d) + '%' : '<span style="color:#cbd5e1">N/A</span>';
      const fCur = (v) => (v !== null && v !== undefined) ? new Intl.NumberFormat('es-CL', { style: 'currency', currency: 'CLP', maximumFractionDigits: 0 }).format(v) : '<span style="color:#cbd5e1">N/A</span>';

      // Helper estilos sem√°nticos (fondos tenues)
      const getCardClass = (val, isPositiveGood = true) => {
        if (val === null || val === undefined) return '';
        const num = parseFloat(val);
        if (isNaN(num)) return '';
        if (isPositiveGood) return num >= 0 ? 'good' : 'bad';
        return num <= 0 ? 'good' : 'bad';
      };

      const getImg = (id) => {
        try {
          const canvas = document.getElementById(id);
          return canvas ? canvas.toDataURL("image/png") : null;
        } catch (e) {
          console.warn("Error capturando imagen " + id, e);
          return null;
        }
      };

      // Captura de im√°genes
      const imgGauge = getImg('gauge-structure-chart');
      const imgM5 = getImg('chart-module5');
      const imgM6 = getImg('chart-module6');
      const imgM7 = getImg('chart-module7');
      const imgVal = getImg('chart-module8-ttv');

      const win = window.open('', '_blank');
      if (!win) { alert("Habilite pop-ups para generar el reporte."); return; }

      try {
        const styles = `
            <style>
                @page { size: A4 portrait; margin: 1.5cm; }
                html, body { height: auto; overflow: visible; }
                body { font-family: 'Helvetica', 'Arial', sans-serif; color: #1e293b; line-height: 1.4; font-size: 10pt; margin: 0; padding: 20px; box-sizing: border-box; }
                
                h1 { font-size: 18pt; margin: 0 0 10px 0; border-bottom: 3px solid #1e293b; padding-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; page-break-after: avoid; break-after: avoid; }
                
                /* Limpieza de floats y forzado de bloque AT√ìMICO */
                .atomic-block {
                    display: block !important; 
                    width: 100%;
                    page-break-inside: avoid !important;
                    break-inside: avoid-page !important;
                    margin-bottom: 40px;
                    position: relative;
                }

                /* Evita que el contenedor flexible interno rompa la regla del padre */
                .split-container {
                    display: flex;
                    gap: 20px;
                }

                h2 { font-size: 14pt; color: #1e293b; border-left: 5px solid #2563eb; padding-left: 10px; margin: 0 0 15px 0; background: #f1f5f9; padding: 8px 12px; page-break-after: avoid !important; break-after: avoid !important; }
                h3 { font-size: 11pt; color: #475569; margin: 0 0 8px 0; font-weight: bold; text-transform: uppercase; page-break-after: avoid !important; break-after: avoid !important; }
                p { orphans: 3; widows: 3; }

                /* Layout Split View Cols */
                .left-col { flex: 0 0 40%; display: flex; flex-direction: column; gap: 10px; }
                .right-col { flex: 0 0 60%; text-align: justify; font-size: 10pt; color: #334155; line-height: 1.5; }

                .card-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 100%; }
                .kpi-card { 
                    padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #e2e8f0; background: white; 
                    display: flex; flex-direction: column; justify-content: center;
                }
                .kpi-card.good { background: rgba(5, 150, 105, 0.1); border-color: #059669; }
                .kpi-card.bad { background: rgba(220, 38, 38, 0.1); border-color: #dc2626; }
                
                .lbl { font-size: 7.5pt; color: #64748b; text-transform: uppercase; font-weight: bold; letter-spacing: 0.5px; }
                .val { font-size: 11pt; font-weight: bold; color: #0f172a; margin-top: 2px; }

                .chart-img { width: 100%; height: auto; border: 1px solid #cbd5e1; border-radius: 4px; background: white; padding: 5px; }

                table { width: 100%; border-collapse: collapse; font-size: 9pt; background: white; }
                th { text-align: left; background: #f8fafc; color: #64748b; padding: 6px; font-size: 8pt; text-transform: uppercase; }
                td { border-bottom: 1px solid #f1f5f9; padding: 6px; color: #334155; }
                tr:last-child td { border-bottom: none; }

                .footer-box { 
                    background: #1e293b; color: white; padding: 20px; border-radius: 8px; 
                    display: flex; justify-content: space-between; align-items: center; margin-top: 20px;
                }
                .rec-block { text-align: center; flex: 1; border-right: 1px solid rgba(255,255,255,0.2); }
                .rec-block:last-child { border: none; }
                .rec-title { font-size: 9pt; opacity: 0.8; letter-spacing: 1px; text-transform: uppercase; }
                .rec-val { font-size: 18pt; font-weight: bold; margin: 5px 0; color: #facc15; }
                .strategy-block-container {
                    display: flex; gap: 20px; margin-top: 20px;
                }
            </style>
        `;

        let html = `<html><head><title>Reporte ${companyName}</title>${styles}</head><body>`;

        html += `
            <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-bottom:20px;">
                <div>
                     <h1>INFORME EJECUTIVO ANALISIS FUNDAMENTAL<br><span style="color:#2563eb">${companyName}</span></h1>
                     <div style="color:#64748b; font-size:9pt">Generado el: ${new Date().toLocaleDateString()}</div>
                </div>
                <div style="text-align:right; font-size:9pt; color:#64748b;">Moneda Base: <b>${fd.datos.monedaBase || 'CLP'}</b></div>
            </div>
        `;

        // SECCI√ìN 1: CALIDAD
        const m1 = mr.module1 || {};
        const mb = mr.moduleBenchmark || {};
        const m9 = mr.module9 || {};
        const m8 = mr.module8 || {};

        html += `
        <div class="atomic-block">
            <h2>1. CALIDAD DEL NEGOCIO</h2>
            <div class="split-container">
                <div class="left-col">
                    <div class="card-grid">
                        <div class="kpi-card"><span class="lbl">ROE</span><span class="val">${fPct(m1.actual?.roeUltimo)}</span></div>
                        <div class="kpi-card"><span class="lbl">Mg. Neto</span><span class="val">${fPct(m1.actual?.margenNetoUltimo)}</span></div>
                    </div>
                    ${imgGauge ? `<img src="${imgGauge}" class="chart-img">` : ''}
                </div>
                <div class="right-col">
                    <h3>Diagn√≥stico de Calidad</h3>
                    <p><strong>Causa Ra√≠z:</strong> ${m1.diagnosis?.forensicNote || 'Sin observaci√≥n espec√≠fica.'}</p>
                    <p><strong>Diagn√≥stico Final:</strong> ${m1.conclusionFinal || 'Estructura est√°ndar.'}</p>
                    <hr style="border:0; border-top:1px solid #e2e8f0; margin:15px 0">
                    <p style="font-size:9pt"><i>El Score de Calidad Estructural de ${m8.score}/100 refleja la capacidad del negocio para sostener sus ventajas competitivas en el tiempo frente a sus pares de la industria.</i></p>
                </div>
            </div>
        </div>`;

        // SECCI√ìN 1.4: COMPARATIVA DE INDUSTRIA
        // L√≥gica de Benchmarking
        let benchRows = [];
        let goodCount = 0;
        let totalCount = 0;

        if (mb.metrics && mb.metrics.length > 0) {
          // Mapeo solicitado
          const targetMetrics = ['ROE', 'Margen Operativo', 'Deuda/Patrimonio', 'Deuda/Pat', 'Deuda', 'PER', 'P/BV'];

          targetMetrics.forEach(tag => {
            // CORRECCI√ìN: Usamos 'name' para buscar
            const match = mb.metrics.find(m => m && typeof m.name === 'string' && m.name.includes(tag));
            if (match && !benchRows.includes(match)) {
              benchRows.push(match);
              totalCount++;
              if (match.status === 'good') goodCount++;
            }
          });

          // Fallback
          if (benchRows.length === 0) {
            benchRows = mb.metrics.slice(0, 5);
            totalCount = benchRows.length;
            benchRows.forEach(m => { if (m.status === 'good') goodCount++ });
          }
        }

        // Definir Estado General
        let industryStatus = "Datos Insuficientes";
        let statusColor = "#94a3b8";
        let statusBg = "#f1f5f9";

        if (totalCount > 0) {
          const ratio = goodCount / totalCount;
          if (ratio >= 0.6) {
            industryStatus = "L√≠der de Industria";
            statusColor = "#166534";
            statusBg = "#dcfce7";
          } else if (ratio >= 0.4) {
            industryStatus = "Similar a Industria";
            statusColor = "#854d0e";
            statusBg = "#fef9c3";
          } else {
            industryStatus = "Bajo Industria";
            statusColor = "#991b1b";
            statusBg = "#fee2e2";
          }
        }

        // Construcci√≥n HTML Tabla
        let benchTableHtml = `<table style="margin-top:0"><tr><th>M√©trica</th><th>Empresa</th><th>Industria</th></tr>`;

        const fmtBenchVal = (val, type) => {
          if (val === null || val === undefined) return 'N/A';
          if (type === 'percent') return (val * 100).toFixed(2) + '%';
          return new Intl.NumberFormat('es-CL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(val) + 'x';
        };

        if (benchRows.length > 0) {
          benchRows.forEach(m => {
            let rowStyle = "";
            if (m.status === 'good') rowStyle = "background-color: rgba(5, 150, 105, 0.1)";
            if (m.status === 'bad') rowStyle = "background-color: rgba(220, 38, 38, 0.1)";

            // CORRECCI√ìN: Acceso directo a valores planos (no .value)
            const compVal = m.company;
            const indVal = m.industry;

            benchTableHtml += `<tr style="${rowStyle}">
                <td>${m.name}</td>
                <td><b>${fmtBenchVal(compVal, m.format)}</b></td>
                <td>${fmtBenchVal(indVal, m.format)}</td>
             </tr>`;
          });
        } else {
          benchTableHtml += `<tr><td colspan="3" style="text-align:center; padding:15px; color:#64748b">Datos de industria no disponibles en el archivo de origen.</td></tr>`;
        }
        benchTableHtml += `</table>`;

        // Render Bloque 1.4
        html += `
        <div class="atomic-block">
            <h3>1.4 COMPARATIVA DE INDUSTRIA</h3>
            <div class="split-container">
                <div class="left-col">
                    ${benchTableHtml}
                </div>
                <div class="right-col">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
                        <span style="font-weight:bold; color:#1e293b">Posicionamiento Relativo</span>
                        <span style="display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 8pt; font-weight: bold; text-transform: uppercase; color:${statusColor}; background:${statusBg}">${industryStatus}</span>
                    </div>
                    <p>La tabla adjunta compara los ratios fundamentales clave de <b>${companyName}</b> frente a los promedios de su industria y competidores directos.</p>
                    <p>Un desempe√±o superior en m√©tricas de rentabilidad (ROE, Margenes) junto a ratios de valoraci√≥n (PER, P/BV) razonables suele indicar una ventaja competitiva sostenible.</p>
                    ${m9.benchmarks ? `<p style="font-size:8.5pt; color:#64748b; margin-top:10px"><i>Referencia Adicional: Bono del Tesoro (Risk Free) ${fPct(m9.benchmarks.bono)} | Retorno de Mercado (IPSA) ${fPct(m9.benchmarks.ipsa)}</i></p>` : ''}
                </div>
            </div>
        </div>
      `;

        // SECCI√ìN 2: DEUDA
        const m5 = mr.module5 || {};
        html += `
        <div class="atomic-block">
            <h2>2. DEUDA Y SOLVENCIA</h2>
            <div class="split-container">
                 <div class="left-col">
                    <div class="card-grid">
                        <div class="kpi-card ${getCardClass(m5.liquidezCorriente - 1)}"><span class="lbl">Liq. Corr.</span><span class="val">${fNum(m5.liquidezCorriente)}x</span></div>
                        <div class="kpi-card ${getCardClass(2 - m5.deudaSobrePatrimonio)}"><span class="lbl">Deuda/Pat</span><span class="val">${fNum(m5.deudaSobrePatrimonio)}x</span></div>
                        <div class="kpi-card" style="grid-column:span 2"><span class="lbl">Cob. Int.</span><span class="val">${fNum(m5.coberturaIntereses)}x</span></div>
                    </div>
                    ${imgM5 ? `<img src="${imgM5}" class="chart-img">` : ''}
                 </div>
                 <div class="right-col">
                    <h3>Salud Financiera</h3>
                    <p>${m5.conclusion?.message || 'Sin an√°lisis de deuda disponible.'}</p>
                 </div>
            </div>
        </div>`;

        // SECCI√ìN 3: GESTI√ìN Y CRECIMIENTO
        const m6 = mr.module6 || {};
        const m7 = mr.module7 || {};
        const lastEff = m6.tabla && m6.tabla.length ? m6.tabla[m6.tabla.length - 1] : {};

        html += `
        <div class="atomic-block">
            <h2>3. GESTI√ìN OPERATIVA Y CRECIMIENTO</h2>
            <!-- Texto Arriba (Ancho Completo) -->
            <div style="margin-bottom:15px">
                 <h3>Eficiencia y Din√°mica de Crecimiento</h3>
                 <p style="margin-bottom:10px">${m6.conclusion?.message || 'Eficiencia estable.'}</p>
                 <p>${m7.conclusion?.message || 'Crecimiento org√°nico alineado a la industria.'}</p>
            </div>
            
            <!-- Gr√°ficos y KPIs Abajo (Lado a Lado) -->
            <div style="display:flex; gap:20px; align-items:flex-start">
                  <!-- Columna Izquierda: KPIs + Gr√°fico Eficiencia -->
                  <div style="flex:1">
                      <div class="card-grid" style="grid-template-columns: repeat(2, 1fr); margin-bottom:10px">
                          <div class="kpi-card"><span class="lbl">Rot. Act.</span><span class="val">${fNum(lastEff.rotActivos)}x</span></div>
                          <div class="kpi-card"><span class="lbl">Rot. Inv.</span><span class="val">${fNum(lastEff.rotInventarios)}x</span></div>
                      </div>
                      ${imgM6 ? `<img src="${imgM6}" class="chart-img" style="max-height:160px; object-fit:contain; width:100%">` : ''}
                  </div>
                  
                  <!-- Columna Derecha: KPIs Growth + Gr√°fico Crecimiento -->
                  <div style="flex:1">
                      <div class="card-grid" style="grid-template-columns: repeat(2, 1fr); margin-bottom:10px">
                          <div class="kpi-card"><span class="lbl">CAGR Vtas</span><span class="val">${fPct(m7.cagrVentas)}</span></div>
                          <div class="kpi-card"><span class="lbl">CAGR Util</span><span class="val">${fPct(m7.cagrUtilidad)}</span></div>
                      </div>
                      ${imgM7 ? `<img src="${imgM7}" class="chart-img" style="max-height:160px; object-fit:contain; width:100%">` : ''}
                  </div>
            </div>
        </div>`;

        // SECCI√ìN 4: VEREDICTO DE VALOR + RECOMENDACI√ìN (MISMO BLOQUE AT√ìMICO)
        const m2 = mr.module2 || {};
        const pActual = m8.precioActual;
        const pObj = m8.pFinal;
        const upside = m8.upside;

        html += `
        <div class="atomic-block">
            <h2>4. VEREDICTO DE VALOR Y ESTRATEGIA</h2>
            
            <!-- Texto Arriba (Ancho Completo) -->
            <div style="margin-bottom:15px">
                <h3>Convergencia de Precio</h3>
                <p>${m8.veredicto?.message || 'An√°lisis de valor intr√≠nseco pendiente.'}</p>
            </div>

            <!-- Gr√°fico y Tabla Abajo -->
            <div style="margin-bottom:20px">
                 ${imgVal ? `<img src="${imgVal}" class="chart-img" style="width:100%; height:auto; max-height:250px; object-fit:contain">` : ''}
                 <table style="margin-top:10px; width:100%">
                     <tr><th>Indicador</th><th>Actual</th><th>Promedio 5A</th></tr>
                     <tr><td>PER</td><td><b>${fNum(m2.perActual, 1)}x</b></td><td>${fNum(m2.perPromedio, 1)}x</td></tr>
                     <tr><td>P/BV</td><td><b>${fNum(m2.pbvActual, 1)}x</b></td><td>${fNum(m2.pbvPromedio, 1)}x</td></tr>
                 </table>
            </div>

            <!-- Footer Dentro del Mismo Bloque At√≥mico para no cortar -->
            <!-- Change: Royal Blue Background (#2563eb) for blocks and New Order (Price, Target, Upside, Rec) -->
            <div class="footer-box" style="background:transparent; padding:0; gap:10px">
                 <div class="rec-block" style="background-color:#2563eb; color:white">
                    <div class="rec-title" style="color:#bfdbfe">Precio Actual</div>
                    <div class="rec-val" style="color:white">${fCur(pActual)}</div>
                 </div>
                 <div class="rec-block" style="background-color:#2563eb; color:white">
                    <div class="rec-title" style="color:#bfdbfe">Precio Objetivo</div>
                    <div class="rec-val" style="color:white">${fCur(pObj)}</div>
                 </div>
                 <div class="rec-block" style="background-color:#2563eb; color:white">
                    <div class="rec-title" style="color:#bfdbfe">Potencial</div>
                    <div class="rec-val" style="color:${upside > 0 ? '#86efac' : '#fca5a5'}">${fPct(upside)}</div>
                 </div>
                 <div class="rec-block" style="background-color:#2563eb; color:white">
                    <div class="rec-title" style="color:#bfdbfe">Recomendaci√≥n</div>
                    <div class="rec-val" style="color:${upside > 0 ? '#86efac' : '#fca5a5'}">${m8.decision || 'MANTENER'}</div>
                 </div>
            </div>

            <div class="strategy-block-container">
                 <div style="flex:1; background:#f0fdf4; padding:15px; border-radius:8px; border:1px solid #bbf7d0; font-size:9pt">
                    <strong style="color:#166534; text-transform:uppercase">Estrategia Corto Plazo</strong>
                    <p style="color:#14532d; margin-top:5px">${m8.recomendaciones?.cortoPlazo || 'Monitorear niveles de soporte.'}</p>
                 </div>
                 <div style="flex:1; background:#f0f9ff; padding:15px; border-radius:8px; border:1px solid #bae6fd; font-size:9pt">
                    <strong style="color:#0369a1; text-transform:uppercase">Visi√≥n Largo Plazo</strong>
                    <p style="color:#0c4a6e; margin-top:5px">${m8.recomendaciones?.largoPlazo || 'Mantener en cartera si los fundamentales persisten.'}</p>
                 </div>
            </div>
        </div>`;

        html += `<script>window.onload=()=>{setTimeout(()=>{window.print();},1000)};<\/script></body></html>`;

        win.document.write(html);
        win.document.close();
      } catch (e) {
        alert("Ocurri√≥ un error generando el reporte: " + e.message);
        console.error(e);
        if (win) win.close();
      }
    }

    function prepareAndPrint() { generateProfessionalReport(); }

    // ============================================
    // NAVIGATION: Scroll Functions
    // ============================================

    /**
     * Scroll suavemente a un elemento espec√≠fico
     * @param {string} elementId - ID del elemento destino
     * @param {number} offset - Offset adicional en p√≠xeles (default: 80 para compensar nav)
     */
    function scrollToElement(elementId, offset = 80) {
      const element = document.getElementById(elementId);
      if (!element) {
        console.warn(`[Navigation] Element not found: ${elementId}`);
        return;
      }

      // Expand module if it's a details element or inside one
      const details = element.closest('details');
      if (details && !details.open) {
        details.open = true;
      }

      // Wait a tick for DOM to update
      setTimeout(() => {
        const rect = element.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const targetY = rect.top + scrollTop - offset;

        window.scrollTo({
          top: targetY,
          behavior: 'smooth'
        });
      }, 50);
    }

    /**
     * Scroll suave de vuelta al inicio del Dashboard
     */
    function scrollToDashboard() {
      const dashboard = document.getElementById('executive-dashboard');
      if (dashboard) {
        window.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      }
    }

    tailwind.config = { darkMode: 'class' };

    // ============================================
    // DICCIONARIO MAESTRO DE TOOLTIPS EDUCATIVOS
    // ============================================

    const RATIO_DEFINITIONS = {
      // ============================================
      // M√ìDULO 1 & 3: RATIOS FUNDAMENTALES
      // ============================================

      // Ratios por Acci√≥n
      'EPS': {
        name: "EPS (Utilidad por Acci√≥n)",
        formula: "Utilidad Neta / N√∫mero de Acciones",
        meaning: "Es la porci√≥n de beneficio que corresponde a cada acci√≥n. Un EPS de $500 significa que cada acci√≥n gener√≥ $500 de utilidad en el √∫ltimo a√±o. Es la base para calcular el PER y evaluar rentabilidad por acci√≥n."
      },
      'BVPS': {
        name: "BVPS (Valor Libro por Acci√≥n)",
        formula: "Patrimonio Neto / N√∫mero de Acciones",
        meaning: "Es el valor contable de cada acci√≥n seg√∫n el balance. Un BVPS de $3.000 significa que si liquidaras la empresa hoy, cada acci√≥n valdr√≠a $3.000 en teor√≠a. Se compara con el precio de mercado para calcular el P/BV."
      },

      // M√∫ltiplos de Valoraci√≥n
      'PER': {
        name: "PER (Ratio Precio / Utilidad)",
        formula: "Precio Acci√≥n / EPS (Beneficio por Acci√≥n)",
        meaning: "Representa cu√°nto paga el mercado por cada $1 de utilidad que genera la empresa. Tambi√©n se lee como los a√±os que tardar√≠as en recuperar la inversi√≥n v√≠a utilidades constantes. Un PER de 15x significa que pagas 15 veces la utilidad anual."
      },
      'P_BV': {
        name: "P/BV (Precio sobre Valor Libro)",
        formula: "Precio Acci√≥n / BVPS",
        meaning: "Compara el precio de mercado con el valor contable. Un P/BV de 1,5x significa que pagas $1,50 por cada $1 de patrimonio contable. Valores bajo 1x pueden indicar infravaloraci√≥n o problemas estructurales."
      },
      'FCFE_YIELD': {
        name: "FCFE Yield (Rendimiento de Caja Libre)",
        formula: "FCFE por Acci√≥n / Precio Acci√≥n",
        meaning: "Es el flujo de caja libre que genera la empresa por cada peso invertido. Un 8% significa que por cada $100 que inviertes, la empresa genera $8 de caja libre anual. Es como el 'dividendo potencial' si repartiera todo el flujo."
      },

      // Rentabilidad
      'ROE': {
        name: "ROE (Retorno sobre Patrimonio)",
        formula: "Beneficio Neto / Patrimonio Neto",
        meaning: "Mide cu√°nto beneficio genera la empresa por cada $1 que los accionistas han invertido. Un ROE de 18% significa que por cada $100 de capital propio, la empresa genera $18 de utilidad anual. Es la m√©trica rey de rentabilidad."
      },
      'ROA': {
        name: "ROA (Retorno sobre Activos)",
        formula: "Beneficio Neto / Activos Totales",
        meaning: "Mide la eficiencia con que la empresa usa TODOS sus activos (propios y financiados) para generar utilidad. Un ROA de 12% significa que cada $100 en activos genera $12 de beneficio. √ötil para comparar empresas con distinto apalancamiento."
      },

      // M√°rgenes
      'MARGEN_NETO': {
        name: "Margen Neto",
        formula: "Utilidad Neta / Ventas",
        meaning: "Indica qu√© porcentaje de cada peso vendido llega como utilidad final (despu√©s de TODO: costos, gastos, intereses e impuestos). Un 15% significa que de cada $100 en ventas, $15 son ganancia neta. Refleja la rentabilidad total del negocio."
      },
      'MARGEN_OP': {
        name: "Margen Operativo",
        formula: "EBIT / Ventas",
        meaning: "Indica qu√© porcentaje de cada peso vendido se convierte en utilidad operativa (antes de intereses e impuestos). Un 25% significa que de cada $100 en ventas, $25 quedan como ganancia operativa. Refleja la eficiencia del negocio core."
      },

      // Pol√≠tica de Dividendos
      'PAYOUT': {
        name: "Payout Ratio (Ratio de Reparto)",
        formula: "Dividendos Pagados / Utilidad Neta",
        meaning: "Es el porcentaje de utilidades que se reparte como dividendos. Un 40% significa que de cada $100 de utilidad, $40 se pagan a accionistas y $60 se reinvierten. Alto payout = m√°s dividendos, bajo payout = m√°s reinversi√≥n para crecer."
      },
      'RETENCION': {
        name: "Ratio de Retenci√≥n",
        formula: "1 - Payout",
        meaning: "Es el porcentaje de utilidades que la empresa retiene para reinvertir. Un 60% significa que de cada $100 de utilidad, $60 se quedan en la empresa para financiar crecimiento. Complemento del payout."
      },

      // Liquidez y Solvencia
      'LIQUIDEZ': {
        name: "Liquidez Corriente",
        formula: "Activo Corriente / Pasivo Corriente",
        meaning: "Capacidad de pago a corto plazo. Un 2,5x significa que tienes $2,50 en activos l√≠quidos (caja, cuentas por cobrar, inventarios) para pagar cada $1 de deuda que vence en el pr√≥ximo a√±o. Menos de 1x es zona de peligro."
      },

      'DEUDA_PATRIMONIO': {
        name: "Solvencia (Deuda / Patrimonio)",
        formula: "Deuda Neta / Patrimonio Neto",
        meaning: "Indica el nivel de apalancamiento. Un valor de 0,67x significa que por cada $1 puesto por los due√±os, la empresa debe $0,67 a terceros. Menos es m√°s seguro. M√°s de 2x suele ser riesgoso salvo en sectores espec√≠ficos."
      },
      'COBERTURA_INTERESES': {
        name: "Cobertura de Intereses",
        formula: "EBIT / Gastos Financieros",
        meaning: "Mide cu√°ntas veces la utilidad operativa cubre los intereses de la deuda. Un 8x significa que ganas 8 veces lo que pagas en intereses. Menos de 2x es riesgoso, m√°s de 5x es s√≥lido. Indica capacidad de pago de deuda."
      },
      'DEUDA_NETA': {
        name: "Deuda Neta",
        formula: "Deuda Total - Caja y Equivalentes",
        meaning: "Es la deuda real despu√©s de descontar el efectivo disponible. Si tienes $1.000 en deuda pero $300 en caja, tu deuda neta es $700. Es la m√©trica correcta para evaluar el riesgo financiero real."
      },

      // ============================================
      // M√ìDULO 5: DEUDA Y SOLVENCIA
      // ============================================
      'DEUDA_EBITDA': {
        name: "Deuda Neta / EBITDA",
        formula: "Deuda Neta / EBITDA",
        meaning: "Indica cu√°ntos a√±os de flujo operativo (EBITDA) se necesitan para pagar toda la deuda. Un 2,5x significa que tardar√≠as 2,5 a√±os en pagar la deuda si dedicaras todo el EBITDA. Menos de 3x es saludable, m√°s de 5x es riesgoso."
      },

      // ============================================
      // M√ìDULO 6: EFICIENCIA OPERATIVA
      // ============================================
      'ROT_INVENTARIOS': {
        name: "Rotaci√≥n de Inventarios",
        formula: "Costo de Ventas / Inventario Promedio",
        meaning: "Mide cu√°ntas veces al a√±o vac√≠as la bodega. 1,88x significa que tardas aprox 194 d√≠as en vender tu stock. M√°s rotaci√≥n = menos capital atrapado en inventario = mejor liquidez. Var√≠a mucho por industria."
      },
      'ROT_CUENTAS_COBRAR': {
        name: "Rotaci√≥n de Cuentas por Cobrar",
        formula: "Ventas / Cuentas por Cobrar Promedio",
        meaning: "Mide cu√°ntas veces al a√±o cobras tus ventas a cr√©dito. Un 6x significa que tardas aprox 60 d√≠as en cobrar. M√°s rotaci√≥n = cobras m√°s r√°pido = mejor liquidez. Menos de 4x puede indicar problemas de cobranza."
      },
      'ROT_ACTIVOS': {
        name: "Rotaci√≥n de Activos Totales",
        formula: "Ventas / Activos Totales",
        meaning: "Mide cu√°ntas veces generas ventas equivalentes a tus activos totales. Un 1,2x significa que vendes $1,20 por cada $1 en activos. M√°s rotaci√≥n = usas mejor tus activos. Var√≠a mucho por industria (retail alto, utilities bajo)."
      },
      'CICLO_CONVERSION': {
        name: "Ciclo de Conversi√≥n de Efectivo",
        formula: "D√≠as Inventario + D√≠as Cobro - D√≠as Pago",
        meaning: "Es el tiempo que tarda tu dinero en dar la vuelta completa (compras ‚Üí vendes ‚Üí cobras). Un ciclo de 45 d√≠as significa que tardas 45 d√≠as desde que pagas a proveedores hasta que cobras de clientes. Menos d√≠as = mejor liquidez."
      },

      // ============================================
      // M√ìDULO 7: CRECIMIENTO (CAGR)
      // ============================================
      'CAGR_VENTAS': {
        name: "CAGR Ventas (Crecimiento Compuesto)",
        formula: "(Ventas Final / Ventas Inicial)^(1/n) - 1",
        meaning: "Es la velocidad de crecimiento promedio anual suavizada. Elimina la volatilidad de los a√±os intermedios para mostrar la tendencia estructural de expansi√≥n. Un 12% anual significa que las ventas se duplican cada 6 a√±os."
      },
      'CAGR_BENEFICIO': {
        name: "CAGR Beneficio Neto",
        formula: "(Beneficio Final / Beneficio Inicial)^(1/n) - 1",
        meaning: "Es la tasa de crecimiento anual compuesta de las utilidades. Un 15% significa que el beneficio crece 15% anual en promedio. M√°s importante que el CAGR de ventas porque refleja si el crecimiento es rentable o solo por volumen."
      },
      'CAGR_PATRIMONIO': {
        name: "CAGR Patrimonio",
        formula: "(Patrimonio Final / Patrimonio Inicial)^(1/n) - 1",
        meaning: "Mide cu√°nto crece el valor contable de la empresa a√±o a a√±o. Un 10% significa que el patrimonio se duplica cada 7 a√±os. Refleja la capacidad de la empresa de reinvertir utilidades y crear valor a largo plazo."
      },
      'CAGR_UTILIDAD': {
        name: "CAGR Utilidad",
        formula: "(Utilidad Final / Utilidad Inicial)^(1/n) - 1",
        meaning: "Mide la tasa de crecimiento anual compuesta de la utilidad neta. Es un indicador clave de la capacidad de la empresa para generar valor creciente para los accionistas. M√°s importante que el CAGR de ventas porque refleja si el crecimiento es rentable."
      },
      'CAGR_FCFE': {
        name: "CAGR FCFE",
        formula: "(FCFE Final / FCFE Inicial)^(1/n) - 1",
        meaning: "Mide el crecimiento del flujo de caja libre para el accionista. Un FCFE creciente es la base para un aumento sostenible en dividendos y valoraci√≥n por DCF."
      },
      'VOLATILIDAD_ROE': {
        name: "Volatilidad del ROE",
        formula: "Desviaci√≥n Est√°ndar del ROE (5 a√±os)",
        meaning: "Mide la estabilidad de las ganancias. Una volatilidad baja (<2%) indica un negocio predecible y seguro. Una volatilidad alta (>5%) sugiere un negocio c√≠clico o riesgoso."
      },
      'CONSISTENCIA_ROE': {
        name: "Consistencia del ROE",
        formula: "Evaluaci√≥n cualitativa de la tendencia",
        meaning: "Clasifica la trayectoria de la rentabilidad: 'Creciente' (Mejora), 'Estable' (Mantiene) o 'Decreciente' (Empeora). Buscamos empresas con ROE estable o creciente."
      },
      'DEUDA_NETA': {
        name: "Deuda Neta (Moneda Base)",
        formula: "Deuda Financiera Total - Caja y Equivalentes",
        meaning: "Es el valor absoluto de la deuda descontando el efectivo. Si es negativo, la empresa tiene m√°s caja que deuda (Cash King). Es el pasivo financiero real que debe asumir el accionista."
      },
      'PRECIO_JUSTO': {
        name: "Precio Justo",
        formula: "Promedio ponderado de m√©todos de valoraci√≥n",
        meaning: "Es el valor intr√≠nseco estimado de la acci√≥n, combinando distintos m√©todos (Flujo de Caja, M√∫ltiplos, Hist√≥rico). Si el precio de mercado es menor a este valor, la acci√≥n podr√≠a estar 'barata'."
      },
      'METODO_PER': {
        name: "M√∫ltiplo PER",
        formula: "EPS Proyectado √ó PER Justo",
        meaning: "Valoraci√≥n basada en ganancias. Estima cu√°nto deber√≠a valer la acci√≥n si cotizara a un m√∫ltiplo PER razonable seg√∫n su calidad y crecimiento esperado."
      },
      'METODO_PBV': {
        name: "M√∫ltiplo P/BV",
        formula: "BVPS Proyectado √ó P/BV Justo",
        meaning: "Valoraci√≥n basada en patrimonio. Estima el precio justo multiplicando el valor libro por acci√≥n por un ratio P/BV ajustado a la rentabilidad (ROE) de la empresa."
      },
      'METODO_HISTORICO': {
        name: "Promedio Hist√≥rico",
        formula: "Promedio de valoraciones hist√≥ricas",
        meaning: "Valor estimado asumiendo que la empresa recuperar√° sus m√∫ltiplos de valoraci√≥n promedio de los √∫ltimos 5 a√±os (reversi√≥n a la media)."
      }
    };

    // Funci√≥n generadora de texto para tooltips
    function getTooltipText(ratioId) {
      const def = RATIO_DEFINITIONS[ratioId];
      if (!def) return "";
      // Usar caracteres especiales unicode y saltos de l√≠nea
      return `üìå ${def.name.toUpperCase()}\n\nüìê F√ìRMULA:\n${def.formula}\n\nüí° INTERPRETACI√ìN:\n${def.meaning}`;
    }
    if (typeof Chart !== 'undefined' && typeof ChartDataLabels !== 'undefined') {
      Chart.register(ChartDataLabels);
    }

    const fmtNumber = (value, decimals = 2) => {
      if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
      return new Intl.NumberFormat('es-CL', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }).format(value);
    };

    const fmtCurrency = (value) => {
      if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
      return new Intl.NumberFormat('es-CL', { style: 'currency', currency: 'CLP', maximumFractionDigits: 0 }).format(value);
    };

    const fmtPercent = (value, decimals = 2) => {
      if (value === null || value === undefined || Number.isNaN(value)) return '‚Äî';
      return `${(value * 100).toFixed(decimals)}%`;
    };

    const safeDivide = (a, b) => {
      if (a === null || a === undefined || b === null || b === undefined) return null;
      if (b === 0) return null;
      return a / b;
    };

    const average = (arr) => {
      const valid = arr.filter((n) => n !== null && n !== undefined && Number.isFinite(n));
      if (!valid.length) return null;
      return valid.reduce((sum, value) => sum + value, 0) / valid.length;
    };

    // Calcula el promedio excluyendo el valor m√°ximo y el m√≠nimo para limpiar outliers (ej. a√±o pandemia)
    const trimmedMean = (arr) => {
      // Filtramos nulos y no finitos
      const valid = arr.filter((n) => n !== null && n !== undefined && Number.isFinite(n));

      // Si hay menos de 3 datos, no podemos recortar extremos sin perder representatividad: usamos promedio simple
      if (valid.length < 3) return average(valid);

      // Ordenamos de menor a mayor
      const sorted = [...valid].sort((a, b) => a - b);

      // Eliminamos el primero (m√≠nimo) y el √∫ltimo (m√°ximo)
      const trimmed = sorted.slice(1, -1);

      // Calculamos promedio de los centrales
      return trimmed.reduce((sum, value) => sum + value, 0) / trimmed.length;
    };


    const standardDeviation = (arr) => {
      const valid = arr.filter((n) => Number.isFinite(n));
      if (valid.length < 2) return 0; // Sample StdDev requires at least 2 data points
      const mean = average(valid);
      if (mean === null) return null;
      // Use Sample Standard Deviation (N-1) for risk estimation
      const variance = valid.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (valid.length - 1);
      return Math.sqrt(variance);
    };

    // Nueva funci√≥n estricta de CAGR que maneja correctamente p√©rdidas finales
    const computeStrictCAGR = (values, years) => {
      // 1. Validar inputs
      if (!values || !years || values.length < 2 || values.length !== years.length) {
        return { value: null, startYear: null, endYear: null, error: "Datos insuficientes" };
      }

      // 2. Obtener el valor del √öLTIMO A√ëO REAL disponible en la data
      const lastIndex = values.length - 1;
      const lastValue = values[lastIndex];
      const lastYear = years[lastIndex];

      // REGLA DE ORO: Si terminamos en p√©rdida, el CAGR de crecimiento no aplica
      if (lastValue <= 0) {
        return { value: null, startYear: years[0], endYear: lastYear, error: "P√©rdida final" };
      }

      // 3. Buscar el primer a√±o positivo para el inicio (Start Year)
      let startIndex = -1;
      for (let i = 0; i < values.length - 1; i++) { // No podemos empezar en el √∫ltimo a√±o
        if (values[i] > 0) {
          startIndex = i;
          break;
        }
      }

      // Si no hay inicio positivo v√°lido o el inicio es el √∫ltimo a√±o
      if (startIndex === -1 || startIndex === lastIndex) {
        return { value: null, startYear: years[0], endYear: lastYear, error: "Sin base positiva" };
      }

      // 4. Calcular CAGR
      const startValue = values[startIndex];
      const startYear = years[startIndex];
      const periods = lastYear - startYear;

      if (periods <= 0) {
        return { value: null, startYear, endYear: lastYear, error: "Periodos insuficientes" };
      }

      const cagr = Math.pow(lastValue / startValue, 1 / periods) - 1;
      return { value: cagr, startYear, endYear: lastYear, error: null };
    };

    const ratioLabels = {
      A1: 'EPS √∫ltimo a√±o',
      A2: 'BVPS √∫ltimo a√±o',
      A3: 'PER actual',
      A4: 'P/BV actual',
      A5: 'ROE √∫ltimo a√±o',
      A6: 'ROA √∫ltimo a√±o',
      A7: 'Margen neto √∫ltimo a√±o',
      A8: 'Margen operacional √∫ltimo a√±o',
      A9: 'Payout √∫ltimo a√±o',
      A10: 'Retenci√≥n √∫ltimo a√±o',
      A11: 'Liquidez corriente',
      A12: 'Deuda neta / Patrimonio',
      A13: 'Cobertura de intereses',
      A14: 'Deuda neta (monto)',
      B1: 'ROE promedio normalizado',
      B2: 'ROA promedio normalizado',
      B3: 'Margen neto promedio',
      B4: 'Margen operacional promedio',
      B5: 'Payout promedio normalizado',
      B6: 'Retenci√≥n promedio normalizado',
      B7: 'Volatilidad ROE',
      B8: 'Consistencia ROE',
      B9: 'CAGR ventas 5 a√±os',
      B10: 'CAGR beneficio neto 5 a√±os',
      B11: 'CAGR patrimonio 5 a√±os',
    };

    // Cat√°logo de f√≥rmulas de c√°lculo para tooltips
    const ratioFormulas = {
      A1: 'EPS = Utilidad neta (EERR) / N√∫mero de acciones',
      A2: 'BVPS = Patrimonio (Balance) / N√∫mero de acciones',
      A3: 'PER = Precio actual / EPS',
      A4: 'P/BV = Precio actual / BVPS',
      A5: 'ROE = Utilidad neta (EERR) / Patrimonio (Balance)',
      A6: 'ROA = Utilidad neta (EERR) / Activos totales (Balance)',
      A7: 'Margen neto = Utilidad neta (EERR) / Ventas (EERR)',
      A8: 'Margen operacional = EBIT (EERR) / Ventas (EERR)',
      A9: 'Payout = Dividendos pagados (FCFE o EERR) / Utilidad neta (EERR)',
      A10: 'Retenci√≥n = 1 - Payout',
      A11: 'Liquidez corriente = Activo corriente (Balance) / Pasivo corriente (Balance)',
      A12: 'Deuda neta/Patrimonio = Deuda neta (Balance) / Patrimonio (Balance)',
      A13: 'Cobertura intereses = EBIT (EERR) / Gastos financieros (EERR)',
      A14: 'Deuda neta = Deuda total (Balance) - Caja y equivalentes (Balance)',
      B1: 'ROE promedio = Promedio de (Utilidad neta / Patrimonio) excluyendo a√±os con utilidad o patrimonio negativos',
      B2: 'ROA promedio = Promedio de (Utilidad neta / Activos) excluyendo a√±os con utilidad o activos negativos',
      B3: 'Margen neto promedio = Promedio de (Utilidad neta / Ventas) excluyendo a√±os con utilidad o ventas negativas',
      B4: 'Margen operacional promedio = Promedio de (EBIT / Ventas) excluyendo a√±os con EBIT o ventas negativas',
      B5: 'Payout promedio = Promedio de (Dividendos / Utilidad neta) excluyendo a√±os con utilidad negativa',
      B6: 'Retenci√≥n promedio = 1 - Payout promedio',
      B7: 'Volatilidad ROE = Desviaci√≥n est√°ndar de los valores de ROE v√°lidos',
      B8: 'Consistencia ROE = Clasificaci√≥n basada en volatilidad: Alta (<5%), Media (5-10%), Baja (>10%)',
      B9: 'CAGR ventas = ((Ventas √∫ltimo a√±o / Ventas primer a√±o)^(1/n√∫mero de a√±os)) - 1',
      B10: 'CAGR beneficio = ((Beneficio neto √∫ltimo a√±o / Beneficio neto primer a√±o)^(1/n√∫mero de a√±os)) - 1',
      B11: 'CAGR patrimonio = ((Patrimonio √∫ltimo a√±o / Patrimonio primer a√±o)^(1/n√∫mero de a√±os)) - 1',
    };

    // Cat√°logo de f√≥rmulas para m√≥dulos de c√°lculo
    const moduleFormulas = {
      // M√≥dulo 0 - DCF
      'dcf_price': 'Precio DCF = VNA de FCFE proyectados / N√∫mero de acciones',
      'dcf_vna': 'VNA = Œ£(FCFE_t / (1+Ke)^t) + Valor Terminal / (1+Ke)^n',
      'dcf_ke': 'Ke (Costo del capital) = Rf + Œ≤ √ó (Rm - Rf)',
      'dcf_terminal': 'Valor Terminal = FCFE_n √ó (1 + g_perpetua) / (Ke - g_perpetua)',
      'dcf_fcfe_base': 'FCFE base = Promedio de FCFE hist√≥ricos v√°lidos',
      'dcf_fcfe_proj': 'FCFE proyectado a√±o t = FCFE base √ó (1 + g_expl√≠cita)^t',

      // M√≥dulo 2 - M√∫ltiplos
      'mult_per_hist': 'PER hist√≥rico = Promedio de (Precio / EPS) √∫ltimos 5 a√±os',
      'mult_pbv_hist': 'P/BV hist√≥rico = Promedio de (Precio / BVPS) √∫ltimos 5 a√±os',
      'mult_market_cap': 'Market Cap = Precio actual √ó N√∫mero de acciones',
      'mult_ev': 'EV (Enterprise Value) = Market Cap + Deuda neta',
      'mult_fcfe_yield': 'FCFE Yield = FCFE √∫ltimo a√±o / Market Cap',
      'mult_ev_fcfe': 'EV/FCFE = Enterprise Value / FCFE √∫ltimo a√±o',

      // M√≥dulo 3 - M√∫ltiplos objetivo
      'obj_per_hist': 'PER hist√≥rico = Promedio PER √∫ltimos 5 a√±os',
      'obj_per_growth': 'PER por crecimiento = PEG √ó (g_expl√≠cita √ó 100)',
      'obj_per_final': 'PER objetivo = Promedio ponderado entre PER hist√≥rico y PER crecimiento',
      'obj_pbv': 'P/BV objetivo = ROE √ó PER objetivo',
      'obj_price_per': 'Precio objetivo PER = EPS base √ó PER objetivo',
      'obj_price_pbv': 'Precio objetivo P/BV = BVPS base √ó P/BV objetivo',

      // M√≥dulo 4 - Proyecciones
      'proj_eps': 'EPS proyectado = Utilidad proyectada / N√∫mero de acciones',
      'proj_bvps': 'BVPS proyectado = Patrimonio proyectado / N√∫mero de acciones',
      'proj_utilidad': 'Utilidad a√±o t = Utilidad a√±o (t-1) √ó (1 + g_expl√≠cita)',
      'proj_patrimonio': 'Patrimonio a√±o t = Patrimonio a√±o (t-1) √ó (1 + ROE √ó Retenci√≥n)',

      // M√≥dulo 5 - Deuda y solvencia
      'debt_total': 'Deuda total = Deuda corto plazo + Deuda largo plazo',
      'debt_net': 'Deuda neta = Deuda total - Efectivo y equivalentes',
      'debt_equity': 'Deuda/Patrimonio = Deuda neta / Patrimonio',
      'debt_current': 'Liquidez corriente = Activo corriente / Pasivo corriente',
      'debt_coverage': 'Cobertura intereses = EBIT / Gastos financieros',

      // M√≥dulo 6 - Eficiencia
      'eff_asset_turn': 'Rotaci√≥n activos = Ventas / Activos totales',
      'eff_wc_turn': 'Rotaci√≥n capital trabajo = Ventas / (Activo corriente - Pasivo corriente)',
      'eff_inv_turn': 'Rotaci√≥n inventarios = Costo ventas / Inventarios promedio',

      // M√≥dulo 7 - Crecimiento (CAGR)
      'cagr_sales': 'CAGR ventas = ((Ventas final / Ventas inicial)^(1/a√±os) - 1',
      'cagr_income': 'CAGR beneficio = ((Beneficio final / Beneficio inicial)^(1/a√±os) - 1',
      'cagr_equity': 'CAGR patrimonio = ((Patrimonio final / Patrimonio inicial)^(1/a√±os) - 1',
      'cagr_fcfe': 'CAGR FCFE = ((FCFE final / FCFE inicial)^(1/a√±os) - 1',

      // M√≥dulo 8 - Precio final
      'final_price': 'Precio final = Promedio ponderado de todos los m√©todos de valoraci√≥n',
      'final_upside': 'Upside = (Precio final - Precio actual) / Precio actual',
      'final_weight_dcf': 'Peso DCF en precio final (seg√∫n calidad de datos)',
      'final_weight_per': 'Peso PER objetivo en precio final',
      'final_weight_pbv': 'Peso P/BV objetivo en precio final',
      'final_weight_internal': 'Peso m√©todos internos en precio final',
    };

    const ratioColorClasses = {
      good: 'bg-emerald-500 text-white',
      warn: 'bg-amber-500 text-white',
      bad: 'bg-rose-500 text-white',
      neutral: 'bg-slate-500 text-white',
    };

    function ratioChip(id, colorClass, title, targetId) {
      const chipTitle = title ? `${title} (${id})` : `Ratio ${id}`;
      const formula = ratioFormulas[id] || 'F√≥rmula no disponible';
      return `
        <button
          class="inline-flex items-center justify-center w-6 h-6 rounded-full text-[10px] font-bold ${colorClass} mr-1 align-middle focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-400 cursor-help"
          title="${chipTitle}\n\nF√≥rmula: ${formula}"
          data-scroll-target="${targetId}"
          data-chip-id="${id}"
          data-formula="${formula}"
          type="button"
        >${id}</button>
      `;
    }

    function getRatioValueById(id, actual = {}, estructural = {}, cagr = {}) {
      switch (id) {
        case 'A1':
          return actual.epsCLP ?? null;
        case 'A2':
          return actual.bvpsCLP ?? null;
        case 'A3':
          return actual.perReal ?? null;
        case 'A4':
          return actual.pbvReal ?? null;
        case 'A5':
          return actual.roeUltimo ?? null;
        case 'A6':
          return actual.roaUltimo ?? null;
        case 'A7':
          return actual.margenNetoUltimo ?? null;
        case 'A8':
          return actual.margenOperacionalUltimo ?? null;
        case 'A9':
          return actual.payoutUltimo ?? null;
        case 'A10':
          return actual.retencionUltimo ?? null;
        case 'A11':
          return actual.liquidezCorriente ?? null;
        case 'A12':
          return actual.deudaNetaSobrePatrimonio ?? null;
        case 'A13':
          return actual.coberturaIntereses ?? null;
        case 'A14':
          return actual.deudaNetaBase ?? null;
        case 'B1':
          return estructural.roePromedioNormalizado ?? null;
        case 'B2':
          return estructural.roaPromedioNormalizado ?? null;
        case 'B3':
          return estructural.margenNetoPromedioNormalizado ?? null;
        case 'B4':
          return estructural.margenOperacionalPromedioNormalizado ?? null;
        case 'B5':
          return estructural.payoutPromedioNormalizado ?? null;
        case 'B6':
          return estructural.retencionPromedioNormalizado ?? null;
        case 'B7':
          return estructural.volatilidadROE ?? null;
        case 'B8':
          return estructural.consistenciaROE ?? null;
        case 'B9':
          return cagr.ventas ?? null;
        case 'B10':
          return cagr.beneficio ?? null;
        case 'B11':
          return cagr.patrimonio ?? null;
        default:
          return null;
      }
    }

    function getRatioColorClass(id, actual = {}, estructural = {}, cagr = {}) {
      const value = getRatioValueById(id, actual, estructural, cagr);
      const val = Number.isFinite(value) ? value : null;
      switch (id) {
        case 'A3':
          if (!Number.isFinite(actual?.epsCLP) || actual.epsCLP <= 0 || !Number.isFinite(value)) return ratioColorClasses.neutral;
          if (value <= 10) return ratioColorClasses.good;
          if (value <= 20) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A4':
          if (!Number.isFinite(value)) return ratioColorClasses.neutral;
          if (value <= 1) return ratioColorClasses.good;
          if (value <= 2) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A5':
          if (val === null) return ratioColorClasses.neutral;
          if (val >= 0.15) return ratioColorClasses.good;
          if (val > 0) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A8':
          if (val === null) return ratioColorClasses.neutral;
          if (val >= 0.15) return ratioColorClasses.good;
          if (val >= 0.05) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A9':
          if (val === null) return ratioColorClasses.neutral;
          if (val < 0.3) return ratioColorClasses.good;
          if (val <= 0.7) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A10':
          if (val === null) return ratioColorClasses.neutral;
          if (val >= 0.6) return ratioColorClasses.good;
          if (val >= 0.3) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A11':
          if (val === null) return ratioColorClasses.neutral;
          if (val > 2) return ratioColorClasses.good;
          if (val >= 1) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A12':
          if (val === null) return ratioColorClasses.neutral;
          if (val < 0.5) return ratioColorClasses.good;
          if (val <= 1) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'A13':
          if (val === null) return ratioColorClasses.neutral;
          if (val > 4) return ratioColorClasses.good;
          if (val >= 2) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'B1':
          if (val === null) return ratioColorClasses.neutral;
          if (val >= 0.2) return ratioColorClasses.good;
          if (val >= 0.1) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'B4':
          if (val === null) return ratioColorClasses.neutral;
          if (val >= 0.15) return ratioColorClasses.good;
          if (val >= 0.05) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'B5':
          if (val === null) return ratioColorClasses.neutral;
          if (val < 0.3) return ratioColorClasses.good;
          if (val <= 0.7) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'B6':
          if (val === null) return ratioColorClasses.neutral;
          if (val >= 0.6) return ratioColorClasses.good;
          if (val >= 0.3) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'B7':
          if (val === null) return ratioColorClasses.neutral;
          if (val <= 0.1) return ratioColorClasses.good;
          if (val <= 0.2) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        case 'B8': {
          const label = typeof value === 'string' ? value.toLowerCase() : '';
          if (label.includes('alta')) return ratioColorClasses.good;
          if (label.includes('media')) return ratioColorClasses.warn;
          if (label.includes('baja')) return ratioColorClasses.bad;
          return ratioColorClasses.neutral;
        }
        case 'B9':
        case 'B10':
        case 'B11':
          if (val === null) return ratioColorClasses.neutral;
          if (val > 0.10) return ratioColorClasses.good;
          if (val >= 0) return ratioColorClasses.warn;
          return ratioColorClasses.bad;
        default:
          return ratioColorClasses.neutral;
      }
    }

    function attachChipScrollHandler(root) {
      if (!root || root.dataset.chipHandlerAttached) return;
      root.addEventListener('click', (event) => {
        const trigger = event.target.closest('[data-scroll-target]');
        if (!trigger) return;
        const targetId = trigger.getAttribute('data-scroll-target');
        if (!targetId) return;
        const targetEl = document.getElementById(targetId);
        if (!targetEl) return;
        targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        targetEl.classList.add('ring-2', 'ring-blue-400', 'ring-offset-2', 'ring-offset-transparent');
        setTimeout(() => {
          targetEl.classList.remove('ring-2', 'ring-blue-400', 'ring-offset-2', 'ring-offset-transparent');
        }, 1500);
      });
      root.dataset.chipHandlerAttached = 'true';
    }

    // Variables globales
    let rawSheets = null;
    let yearMetadata = null;
    let financialData = null;
    let moduleResults = null;
    const chartRegistry = [];
    let state = {
      context: null  // Se poblar√° al finalizar M√≥dulo 1
    };

    // ============================================
    // RULE ENGINE: MULTI-DIMENSIONAL CONCLUSION SYSTEM
    // ============================================

    // ========== CONSTANTS ==========
    const RULE_ENGINE_CONSTANTS = {
      // Valuation Thresholds
      DEEP_DISCOUNT_PER: -0.20,
      DISCOUNT_PER: -0.10,
      PREMIUM_PER: 0.15,
      DEEP_DISCOUNT_PBV: -0.20,
      DISCOUNT_PBV: -0.10,

      // Quality Thresholds
      HIGH_ROE: 0.15,
      MEDIUM_ROE: 0.08,
      LOW_ROE: 0.05,
      HIGH_MARGIN: 0.12,
      MEDIUM_MARGIN: 0.05,
      HIGH_VOLATILITY_ROE: 0.05,

      // Debt Thresholds
      SAFE_DEBT_EQUITY: 0.5,
      STRESSED_DEBT_EQUITY: 1.5,
      DISTRESS_DEBT_EQUITY: 3.0,
      SAFE_COVERAGE: 3.0,
      DISTRESS_COVERAGE: 1.5,

      // Growth Thresholds
      HIGH_GROWTH_CAGR: 0.10,
      MODERATE_GROWTH_CAGR: 0.05,
      STAGNATION_CAGR: 0.02,

      // History Thresholds
      CONSISTENT_PROFIT_RATIO: 0.8,
      POOR_HISTORY_RATIO: 0.4,

      // Competitive Thresholds
      LEADER_RATIO: 0.7,
      LAGGARD_RATIO: 0.3,

      // Efficiency Thresholds
      EXCELLENT_EFFICIENCY: 0.75,
      WARNING_EFFICIENCY: 0.50,
    };

    const RATING_SCORE_MAP = [
      { min: 80, max: 100, rating: 'STRONG BUY', icon: 'üöÄ', color: 'emerald' },
      { min: 65, max: 79, rating: 'BUY', icon: 'üìà', color: 'green' },
      { min: 45, max: 64, rating: 'HOLD', icon: '‚è∏Ô∏è', color: 'amber' },
      { min: 30, max: 44, rating: 'SELL', icon: 'üìâ', color: 'orange' },
      { min: 0, max: 29, rating: 'STRONG SELL', icon: '‚õî', color: 'red' },
    ];

    // ========== CLASSIFIER FUNCTIONS ==========

    function classifyQualityTier(estructural) {
      if (!estructural) return 'UNKNOWN';
      const roe = estructural.roePromedioNormalizado || 0;
      const margin = estructural.margenOperacionalPromedioNormalizado || 0;
      const vol = estructural.volatilidadROE || 0;

      if (roe > RULE_ENGINE_CONSTANTS.HIGH_ROE &&
        margin > RULE_ENGINE_CONSTANTS.HIGH_MARGIN &&
        vol < RULE_ENGINE_CONSTANTS.HIGH_VOLATILITY_ROE) {
        return 'HIGH_QUALITY';
      } else if (roe < RULE_ENGINE_CONSTANTS.LOW_ROE || margin < 0) {
        return 'LOW_QUALITY';
      }
      return 'MEDIUM_QUALITY';
    }

    function classifyDebtTier(debtMetrics) {
      if (!debtMetrics) return 'UNKNOWN';
      const { debtEquity, netDebt, coverage } = debtMetrics;

      if (netDebt < 0) return 'CASH_KING';

      if (debtEquity < RULE_ENGINE_CONSTANTS.SAFE_DEBT_EQUITY &&
        coverage > RULE_ENGINE_CONSTANTS.SAFE_COVERAGE) {
        return 'SAFE';
      }

      if (debtEquity > RULE_ENGINE_CONSTANTS.DISTRESS_DEBT_EQUITY ||
        coverage < RULE_ENGINE_CONSTANTS.DISTRESS_COVERAGE) {
        return 'DISTRESS';
      }

      return 'STRESSED';
    }

    function classifyHistoryPattern(beneficioSeries) {
      if (!beneficioSeries || beneficioSeries.length === 0) return 'UNKNOWN';

      const positiveYears = beneficioSeries.filter(b => b > 0).length;
      const totalYears = beneficioSeries.length;
      const ratio = positiveYears / totalYears;

      if (ratio >= RULE_ENGINE_CONSTANTS.CONSISTENT_PROFIT_RATIO) return 'CONSISTENT_PROFIT';
      if (ratio === 0) return 'CHRONIC_LOSSES';
      if (ratio < RULE_ENGINE_CONSTANTS.POOR_HISTORY_RATIO) return 'POOR_HISTORY';
      return 'MIXED_HISTORY';
    }

    function classifyValuationBucket(mod2, mod8) {
      if (!mod2 || !mod8) return 'UNKNOWN';

      const perDiscount = mod2.perPromedio ? (mod2.perActual / mod2.perPromedio - 1) : 0;
      const pbvDiscount = mod2.pbvPromedio ? (mod2.pbvActual / mod2.pbvPromedio - 1) : 0;
      const upside = mod8.upside || 0;

      // Deep discount: both multiples cheap AND significant upside
      if ((perDiscount < RULE_ENGINE_CONSTANTS.DEEP_DISCOUNT_PER ||
        pbvDiscount < RULE_ENGINE_CONSTANTS.DEEP_DISCOUNT_PBV) &&
        upside > 0.30) {
        return 'DEEP_DISCOUNT';
      }

      if (perDiscount < RULE_ENGINE_CONSTANTS.DISCOUNT_PER ||
        pbvDiscount < RULE_ENGINE_CONSTANTS.DISCOUNT_PBV) {
        return 'DISCOUNT';
      }

      if (perDiscount > RULE_ENGINE_CONSTANTS.PREMIUM_PER) {
        return 'PREMIUM';
      }

      return 'FAIR';
    }

    function classifyGrowthPattern(mod7) {
      if (!mod7 || !mod7.cagrs) return 'UNKNOWN';

      const { ventas, beneficio, fcfe } = mod7.cagrs;
      const salesGrowth = ventas?.value || 0;
      const incomeGrowth = beneficio?.value || 0;

      // Profitless growth: sales growing but profits negative
      if (salesGrowth > RULE_ENGINE_CONSTANTS.MODERATE_GROWTH_CAGR && incomeGrowth < 0) {
        return 'PROFITLESS';
      }

      // Compounder: both sales and profits growing well
      if (salesGrowth > RULE_ENGINE_CONSTANTS.HIGH_GROWTH_CAGR &&
        incomeGrowth > RULE_ENGINE_CONSTANTS.HIGH_GROWTH_CAGR) {
        return 'COMPOUNDER';
      }

      // Declining
      if (salesGrowth < -0.05) {
        return 'DECLINING';
      }

      // Stagnant
      if (Math.abs(salesGrowth) < RULE_ENGINE_CONSTANTS.STAGNATION_CAGR) {
        return 'STAGNANT';
      }

      return 'MODERATE';
    }

    function classifyCompetitivePosition(mod9) {
      if (!mod9 || !mod9.metrics) return 'UNKNOWN';

      const goodMetrics = mod9.metrics.filter(m => m.status === 'good').length;
      const totalMetrics = mod9.metrics.length;
      const ratio = totalMetrics > 0 ? goodMetrics / totalMetrics : 0;

      if (ratio >= RULE_ENGINE_CONSTANTS.LEADER_RATIO) return 'LEADER';
      if (ratio <= RULE_ENGINE_CONSTANTS.LAGGARD_RATIO) return 'LAGGARD';
      return 'AVERAGE';
    }

    function detectEfficiencyDivergence(mod6) {
      if (!mod6) return false;
      // Detect if margins improve but turnover worsens (or vice versa)
      const marginTrend = mod6.marginTrend || 0;
      const turnoverTrend = mod6.turnoverTrend || 0;
      return (marginTrend > 0.05 && turnoverTrend < -0.05) ||
        (marginTrend < -0.05 && turnoverTrend > 0.05);
    }

    // ========== STATE BUILDER ==========

    function buildCompanyState(modules) {
      const { m0, m1, m2, m3, m4, m5, m6, m7, m8, m9 } = modules;

      // Safety checks
      if (!m1 || !m1.actual) {
        console.warn('[STATE BUILDER] Missing critical module data');
        return null;
      }

      return {
        // Dimension 1: Operational Health
        health: {
          ebit: m1.actual.ebit || 0,
          netIncome: m1.actual.netIncome || 0,
          equity: m1.actual.patrimonio || 0,
          diagnosis: m1.diagnosis?.stateCode || 'UNKNOWN',
          forensic: m1.diagnosis?.forensicNote || '',
          anomalies: m1.anomalies || [],
        },

        // Dimension 2: Historical Track Record
        history: {
          profitYears: m1.series?.beneficio ? m1.series.beneficio.filter(b => b > 0).length : 0,
          totalYears: m1.series?.beneficio ? m1.series.beneficio.length : 0,
          consecutiveLosses: m1.recurrence?.consecutiveLossMaxStreak || 0,
          pattern: m1.series?.beneficio ? classifyHistoryPattern(m1.series.beneficio) : 'UNKNOWN',
        },

        // Dimension 3: Structural Quality
        quality: {
          roeAvg: m1.estructural?.roePromedioNormalizado || 0,
          roeVol: m1.estructural?.volatilidadROE || 0,
          marginOp: m1.estructural?.margenOperacionalPromedioNormalizado || 0,
          tier: m1.estructural ? classifyQualityTier(m1.estructural) : 'UNKNOWN',
        },

        // Dimension 4: Valuation
        valuation: {
          perDiscount: m2 && m2.perPromedio ? (m2.perActual / m2.perPromedio - 1) : 0,
          pbvDiscount: m2 && m2.pbvPromedio ? (m2.pbvActual / m2.pbvPromedio - 1) : 0,
          fcfeYield: m2?.fcfeYield || 0,
          upside: m8?.upside || 0,
          bucket: (m2 && m8) ? classifyValuationBucket(m2, m8) : 'UNKNOWN',
        },

        // Dimension 5: Debt Profile
        debt: {
          debtEquity: m5?.debtEquity || 0,
          netDebt: m5?.netDebt || 0,
          coverage: m5?.coverage || 0,
          isPayingDown: (m5?.debtPaydownRatio || 0) > 0.3,
          debtPaydownRatio: m5?.debtPaydownRatio || 0,
          tier: m5 ? classifyDebtTier(m5) : 'UNKNOWN',
        },

        // Dimension 6: Growth Dynamics
        growth: {
          salesCAGR: m7?.cagrs?.ventas?.value || 0,
          incomeCAGR: m7?.cagrs?.beneficio?.value || 0,
          fcfeCAGR: m7?.cagrs?.fcfe?.value || 0,
          capexRatio: m5?.capexRatio || 0,
          pattern: m7 ? classifyGrowthPattern(m7) : 'UNKNOWN',
        },

        // Dimension 7: Operational Efficiency
        efficiency: {
          trend: m6?.conclusion?.type || 'neutral',
          score: m6?.efficiencyScore || 0.5,
          divergence: m6 ? detectEfficiencyDivergence(m6) : false,
        },

        // Dimension 8: Competitive Position
        competitive: {
          scoreCount: m9?.metrics ? m9.metrics.filter(m => m.status === 'good').length : 0,
          totalMetrics: m9?.metrics ? m9.metrics.length : 0,
          position: m9 ? classifyCompetitivePosition(m9) : 'UNKNOWN',
        },

        // Raw modules for advanced rules
        _raw: modules,
      };
    }

    // ========== RULE ENGINE CLASS ==========

    class RuleEngine {
      constructor(rules) {
        this.rules = rules || [];
        this.debugMode = true; // Set to false in production
      }

      evaluate(state) {
        if (!state) {
          console.error('[RULE ENGINE] Invalid state provided');
          return this._getDefaultResult();
        }

        const result = {
          rating: 'HOLD',
          score: 50, // Base score
          messages: [],
          overrides: {},
          appliedRules: [],
          debugLog: [],
        };

        // Sort rules by priority (descending), then by order
        const sortedRules = [...this.rules].sort((a, b) => {
          if (b.priority !== a.priority) return b.priority - a.priority;
          return (a.order || 0) - (b.order || 0);
        });

        // Apply rules sequentially
        for (const rule of sortedRules) {
          try {
            if (rule.condition(state)) {
              const ruleResult = rule.apply(state);

              // Apply modifications
              if (ruleResult.rating) result.rating = ruleResult.rating;
              if (ruleResult.scoreBonus) result.score += ruleResult.scoreBonus;
              if (ruleResult.scorePenalty) result.score += ruleResult.scorePenalty;
              if (ruleResult.scoreSet !== undefined) result.score = ruleResult.scoreSet;
              if (ruleResult.message) {
                result.messages.push({
                  text: ruleResult.message,
                  priority: rule.priority,
                  impact: Math.abs(ruleResult.scoreBonus || ruleResult.scorePenalty || 0),
                  ruleId: rule.id,
                });
              }
              if (ruleResult.methodOverride) result.overrides.method = ruleResult.methodOverride;

              result.appliedRules.push(rule.id);

              if (this.debugMode) {
                const logEntry = `[RULE] ${rule.id} | Priority: ${rule.priority} | Score: ${result.score}`;
                result.debugLog.push(logEntry);
                console.log(logEntry);
              }

              // Kill switch: stop processing
              if (rule.priority >= 1000 && ruleResult.killSwitch) {
                if (this.debugMode) {
                  console.log(`[KILL SWITCH] ${rule.id} - Stopping rule evaluation`);
                }
                break;
              }
            }
          } catch (error) {
            console.error(`[RULE ERROR] ${rule.id}:`, error);
          }
        }

        // Normalize score
        result.score = Math.max(0, Math.min(100, result.score));

        // Map score to rating if not overridden by kill switch
        if (!result.appliedRules.some(id => id.startsWith('KILL_') || id.startsWith('SANITY_'))) {
          const mapping = RATING_SCORE_MAP.find(m => result.score >= m.min && result.score <= m.max);
          if (mapping) {
            result.rating = mapping.rating;
            result.icon = mapping.icon;
            result.color = mapping.color;
          }
        }

        // Filter and sort messages: keep top 5 by impact
        result.topMessages = result.messages
          .sort((a, b) => b.impact - a.impact || b.priority - a.priority)
          .slice(0, 5)
          .map(m => m.text);

        return result;
      }

      _getDefaultResult() {
        return {
          rating: 'HOLD',
          score: 50,
          messages: [],
          topMessages: ['No se pudo evaluar la empresa por falta de datos'],
          overrides: {},
          appliedRules: [],
          debugLog: [],
        };
      }
    }

    // ========== RULES LIBRARY ==========

    const CORE_RULES = [
      // ============================================
      // TIER 1: SANITY CHECKS (Priority 2000+)
      // ============================================
      {
        id: 'SANITY_NEGATIVE_EQUITY',
        priority: 2100,
        order: 1,
        condition: (s) => s.health.equity <= 0,
        apply: (s) => ({
          rating: 'STRONG SELL',
          scoreSet: 5,
          message: 'üö® PATRIMONIO NEGATIVO: La empresa est√° t√©cnicamente insolvente. El valor contable es negativo.',
          killSwitch: true,
        }),
      },

      {
        id: 'SANITY_PROFIT_WITH_NEGATIVE_EQUITY',
        priority: 2000,
        order: 2,
        condition: (s) => s.health.netIncome > 0 && s.health.equity < 0,
        apply: (s) => ({
          message: '‚ö†Ô∏è ANOMAL√çA CONTABLE: Beneficio positivo con patrimonio negativo. Revisar estados financieros.',
          scorePenalty: -30,
        }),
      },

      {
        id: 'SANITY_NO_OPERATIONS',
        priority: 2050,
        order: 3,
        condition: (s) => s._raw.m1?.actual?.ventas <= 0,
        apply: (s) => ({
          rating: 'STRONG SELL',
          scoreSet: 10,
          message: '‚õî SIN OPERACIONES: La empresa no registra ventas. Posible liquidaci√≥n o datos err√≥neos.',
          killSwitch: true,
        }),
      },

      // ============================================
      // TIER 2: KILL SWITCHES (Priority 1000-999)
      // ============================================
      {
        id: 'KILL_BANKRUPTCY',
        priority: 1000,
        order: 1,
        condition: (s) => s.health.diagnosis === 'DISTRESS_BANKRUPTCY_RISK',
        apply: (s) => ({
          rating: 'STRONG SELL',
          scoreSet: 10,
          message: '‚õî QUIEBRA T√âCNICA: Patrimonio negativo o insolvencia inminente detectada por diagn√≥stico.',
          killSwitch: true,
        }),
      },

      {
        id: 'KILL_CHRONIC_PROFITLESS_GROWTH',
        priority: 999,
        order: 2,
        condition: (s) =>
          s.history.pattern === 'CHRONIC_LOSSES' &&
          s.growth.salesCAGR > 0.05 &&
          s.history.totalYears >= 5,
        apply: (s) => ({
          rating: 'SELL',
          scoreSet: 25,
          message: `üí£ PROFITLESS GROWTH: ${s.history.totalYears} a√±os de p√©rdidas pese a crecer ventas ${fmtPercent(s.growth.salesCAGR)}. Destrucci√≥n sistem√°tica de valor.`,
          killSwitch: true,
        }),
      },

      {
        id: 'KILL_DEBT_DEATH_SPIRAL',
        priority: 998,
        order: 3,
        condition: (s) =>
          s.debt.tier === 'DISTRESS' &&
          s.health.netIncome < 0 &&
          s.growth.salesCAGR < 0,
        apply: (s) => ({
          rating: 'STRONG SELL',
          scoreSet: 15,
          message: `üåÄ ESPIRAL DE DEUDA: Deuda cr√≠tica (${fmtNumber(s.debt.debtEquity, 1)}x patrimonio), p√©rdidas operativas y ventas cayendo. Riesgo de quiebra.`,
          killSwitch: true,
        }),
      },

      // ============================================
      // TIER 3: STRUCTURAL QUALITY (Priority 800-750)
      // ============================================
      {
        id: 'QUALITY_EXCELLENCE',
        priority: 850,
        order: 1,
        condition: (s) =>
          s.quality.tier === 'HIGH_QUALITY' &&
          s.quality.roeVol < 0.02,
        apply: (s) => ({
          message: `‚≠ê EXCELENCIA ESTRUCTURAL: ROE promedio ${fmtPercent(s.quality.roeAvg)} con volatilidad m√≠nima (${fmtPercent(s.quality.roeVol)}). Negocio predecible y rentable.`,
          scoreBonus: 12,
        }),
      },

      {
        id: 'QUALITY_POOR',
        priority: 840,
        order: 2,
        condition: (s) => s.quality.tier === 'LOW_QUALITY',
        apply: (s) => ({
          message: `üìâ CALIDAD ESTRUCTURAL BAJA: ROE ${fmtPercent(s.quality.roeAvg)}, margen operativo ${fmtPercent(s.quality.marginOp)}. Rentabilidad insuficiente.`,
          scorePenalty: -15,
        }),
      },

      {
        id: 'QUALITY_VOLATILE',
        priority: 830,
        order: 3,
        condition: (s) => s.quality.roeVol > RULE_ENGINE_CONSTANTS.HIGH_VOLATILITY_ROE,
        apply: (s) => ({
          message: `‚ö†Ô∏è RENTABILIDAD VOL√ÅTIL: Desviaci√≥n est√°ndar del ROE de ${fmtPercent(s.quality.roeVol)}. Negocio c√≠clico o inestable.`,
          scorePenalty: -8,
        }),
      },

      // ============================================
      // TIER 4: HEALTH vs HISTORY (Priority 900-890)
      // ============================================
      {
        id: 'HEALTHY_DISTORTION_VALIDATED',
        priority: 900,
        order: 1,
        condition: (s) =>
          s.health.diagnosis === 'HEALTHY_DISTORTION' &&
          s.history.pattern === 'CONSISTENT_PROFIT' &&
          s.quality.tier === 'HIGH_QUALITY',
        apply: (s) => ({
          message: `‚öñÔ∏è EVENTO PUNTUAL VALIDADO: La p√©rdida est√° justificada por "${s.health.forensic}". Historial s√≥lido (${s.history.profitYears}/${s.history.totalYears} a√±os positivos, ROE ${fmtPercent(s.quality.roeAvg)}). Valoraci√≥n debe usar m√©tricas normalizadas.`,
          methodOverride: 'USE_NORMALIZED',
          scoreBonus: 10,
        }),
      },

      {
        id: 'HEALTHY_DISTORTION_UNVALIDATED',
        priority: 899,
        order: 2,
        condition: (s) =>
          s.health.diagnosis === 'HEALTHY_DISTORTION' &&
          (s.history.pattern === 'POOR_HISTORY' || s.quality.tier === 'LOW_QUALITY'),
        apply: (s) => ({
          message: `‚ö†Ô∏è DISTORSI√ìN CON HISTORIAL D√âBIL: Aunque se diagnostica evento puntual, solo ${s.history.profitYears}/${s.history.totalYears} a√±os fueron positivos. La "normalizaci√≥n" puede ser optimista.`,
          scorePenalty: -15,
        }),
      },

      {
        id: 'CYCLICAL_OPPORTUNITY',
        priority: 898,
        order: 3,
        condition: (s) =>
          s.health.diagnosis === 'CYCLICAL_DOWNTURN' &&
          s.quality.tier === 'HIGH_QUALITY' &&
          s.valuation.bucket === 'DEEP_DISCOUNT',
        apply: (s) => ({
          rating: 'BUY',
          message: 'üîß OPORTUNIDAD C√çCLICA: Empresa de calidad en fase baja del ciclo. Fundamentos estructurales s√≥lidos con precio deprimido temporalmente.',
          scoreBonus: 10,
        }),
      },

      // ============================================
      // TIER 5: VALUATION (Priority 500-450)
      // ============================================
      {
        id: 'OPPORTUNITY_GOLD',
        priority: 500,
        order: 1,
        condition: (s) =>
          s.valuation.bucket === 'DEEP_DISCOUNT' &&
          s.quality.tier === 'HIGH_QUALITY' &&
          s.debt.tier !== 'DISTRESS' &&
          s.history.pattern === 'CONSISTENT_PROFIT',
        apply: (s) => ({
          rating: 'STRONG BUY',
          message: `üíé OPORTUNIDAD DE ORO: Empresa de alta calidad (ROE ${fmtPercent(s.quality.roeAvg)}) cotizando con descuento significativo. Margen de seguridad del ${fmtPercent(Math.abs(s.valuation.upside))}.`,
          scoreBonus: 15,
        }),
      },

      {
        id: 'VALUE_TRAP',
        priority: 499,
        order: 2,
        condition: (s) =>
          s.valuation.bucket === 'DEEP_DISCOUNT' &&
          (s.quality.tier === 'LOW_QUALITY' || s.growth.salesCAGR < -0.05),
        apply: (s) => ({
          rating: 'SELL',
          message: `üí£ TRAMPA DE VALOR: El descuento est√° justificado por deterioro estructural. ROE ${fmtPercent(s.quality.roeAvg)}, Ventas ${fmtPercent(s.growth.salesCAGR)}.`,
          scorePenalty: -20,
        }),
      },

      {
        id: 'PREMIUM_JUSTIFIED',
        priority: 480,
        order: 3,
        condition: (s) =>
          s.valuation.bucket === 'PREMIUM' &&
          s.growth.pattern === 'COMPOUNDER' &&
          s.quality.tier === 'HIGH_QUALITY',
        apply: (s) => ({
          message: `‚ú® PREMIUM JUSTIFICADO: Empresa de alta calidad con crecimiento sostenido (Ventas ${fmtPercent(s.growth.salesCAGR)}, Beneficio ${fmtPercent(s.growth.incomeCAGR)}). El m√∫ltiplo elevado refleja fundamentos excepcionales.`,
          scoreBonus: 5,
        }),
      },

      {
        id: 'PREMIUM_UNJUSTIFIED',
        priority: 479,
        order: 4,
        condition: (s) =>
          s.valuation.bucket === 'PREMIUM' &&
          (s.growth.pattern === 'STAGNANT' || s.quality.tier === 'LOW_QUALITY'),
        apply: (s) => ({
          rating: 'SELL',
          message: `‚ö†Ô∏è SOBREVALORACI√ìN: Cotiza con premium sin fundamentos que lo justifiquen. Crecimiento ${s.growth.pattern}, Calidad ${s.quality.tier}.`,
          scorePenalty: -15,
        }),
      },

      {
        id: 'FAIR_VALUATION_QUALITY',
        priority: 470,
        order: 5,
        condition: (s) =>
          s.valuation.bucket === 'FAIR' &&
          s.quality.tier === 'HIGH_QUALITY',
        apply: (s) => ({
          message: '‚úÖ VALORACI√ìN JUSTA: Precio alineado con fundamentos. Empresa de calidad sin margen de seguridad significativo.',
          scoreBonus: 3,
        }),
      },

      // ============================================
      // TIER 6: DEBT DYNAMICS (Priority 700-650)
      // ============================================
      {
        id: 'DEBT_DISTRESS',
        priority: 700,
        order: 1,
        condition: (s) => s.debt.tier === 'DISTRESS',
        apply: (s) => ({
          rating: 'SELL',
          message: `üö® ESTR√âS FINANCIERO: Deuda/Patrimonio ${fmtNumber(s.debt.debtEquity, 2)}x, Cobertura ${fmtNumber(s.debt.coverage, 1)}x. Riesgo de refinanciaci√≥n.`,
          scorePenalty: -25,
        }),
      },

      {
        id: 'DELEVERAGING_ACTIVE',
        priority: 680,
        order: 2,
        condition: (s) =>
          s.debt.debtEquity > 1.5 &&
          s.debt.isPayingDown &&
          s.growth.fcfeCAGR > 0,
        apply: (s) => ({
          message: `üõ°Ô∏è DESAPALANCAMIENTO ACTIVO: Aunque la deuda es alta (${fmtNumber(s.debt.debtEquity, 1)}x), la empresa genera caja y destina ${fmtPercent(s.debt.debtPaydownRatio)} a reducirla.`,
          scoreBonus: 5,
        }),
      },

      {
        id: 'CASH_FORTRESS',
        priority: 670,
        order: 3,
        condition: (s) => s.debt.tier === 'CASH_KING',
        apply: (s) => ({
          message: 'üí∞ FORTALEZA FINANCIERA: Posici√≥n neta de caja. Flexibilidad estrat√©gica m√°xima.',
          scoreBonus: 8,
        }),
      },

      {
        id: 'DEBT_SAFE',
        priority: 660,
        order: 4,
        condition: (s) => s.debt.tier === 'SAFE',
        apply: (s) => ({
          message: `‚úÖ DEUDA CONTROLADA: Apalancamiento conservador (${fmtNumber(s.debt.debtEquity, 1)}x) con cobertura s√≥lida (${fmtNumber(s.debt.coverage, 1)}x).`,
          scoreBonus: 3,
        }),
      },

      // ============================================
      // TIER 7: GROWTH PATTERNS (Priority 300-250)
      // ============================================
      {
        id: 'INVESTMENT_PHASE',
        priority: 300,
        order: 1,
        condition: (s) =>
          s.growth.pattern === 'PROFITLESS' &&
          s.growth.capexRatio > 1.5 &&
          s.debt.tier !== 'DISTRESS',
        apply: (s) => ({
          message: `üöÄ FASE DE INVERSI√ìN: El crecimiento sin rentabilidad est√° justificado por CAPEX elevado (${fmtNumber(s.growth.capexRatio, 1)}x beneficio). Modelo Amazon.`,
          rating: 'HOLD',
        }),
      },

      {
        id: 'COMPOUNDER_EXCELLENCE',
        priority: 290,
        order: 2,
        condition: (s) =>
          s.growth.pattern === 'COMPOUNDER' &&
          s.quality.tier === 'HIGH_QUALITY',
        apply: (s) => ({
          message: `üåü COMPOUNDER DE CALIDAD: Crecimiento sostenido con rentabilidad elevada. Ventas ${fmtPercent(s.growth.salesCAGR)}, Beneficio ${fmtPercent(s.growth.incomeCAGR)}.`,
          scoreBonus: 12,
        }),
      },

      {
        id: 'TURNAROUND_REQUIRED',
        priority: 280,
        order: 3,
        condition: (s) => s.history.profitYears === 0 && s.history.totalYears >= 3,
        apply: (s) => ({
          message: `üå± TURNAROUND REQUERIDO: Sin historial de rentabilidad en ${s.history.totalYears} a√±os. Las proyecciones asumen cambio radical. Riesgo extremo.`,
          methodOverride: 'CONDITIONAL_VALUATION',
          scorePenalty: -25,
        }),
      },

      {
        id: 'STAGNATION_WARNING',
        priority: 270,
        order: 4,
        condition: (s) =>
          s.growth.pattern === 'STAGNANT' &&
          s.competitive.position === 'LAGGARD',
        apply: (s) => ({
          message: '‚ö†Ô∏è ESTANCAMIENTO: Crecimiento nulo con posici√≥n competitiva d√©bil. Riesgo de obsolescencia.',
          scorePenalty: -10,
        }),
      },

      {
        id: 'DECLINING_SALES',
        priority: 260,
        order: 5,
        condition: (s) => s.growth.pattern === 'DECLINING',
        apply: (s) => ({
          message: `üìâ VENTAS EN DECLIVE: Ca√≠da sostenida de ${fmtPercent(s.growth.salesCAGR)}. P√©rdida de cuota de mercado o mercado en contracci√≥n.`,
          scorePenalty: -12,
        }),
      },

      // ============================================
      // TIER 8: EFFICIENCY SIGNALS (Priority 600-550)
      // ============================================
      {
        id: 'EFFICIENCY_EXCELLENCE',
        priority: 600,
        order: 1,
        condition: (s) => s.efficiency.trend === 'excellent',
        apply: (s) => ({
          message: '‚ö° EXCELENCIA OPERATIVA: Mejora sostenida en m√°rgenes y rotaci√≥n de activos.',
          scoreBonus: 8,
        }),
      },

      {
        id: 'EFFICIENCY_DIVERGENCE',
        priority: 590,
        order: 2,
        condition: (s) => s.efficiency.divergence,
        apply: (s) => ({
          message: '‚ö†Ô∏è DIVERGENCIA OPERATIVA: Mejora en m√°rgenes compensada por deterioro en rotaci√≥n (o viceversa). Monitorear sostenibilidad.',
          scorePenalty: -5,
        }),
      },

      {
        id: 'EFFICIENCY_WARNING',
        priority: 580,
        order: 3,
        condition: (s) => s.efficiency.trend === 'warning',
        apply: (s) => ({
          message: '‚ö†Ô∏è EFICIENCIA EN DETERIORO: Tendencia negativa en indicadores operativos.',
          scorePenalty: -7,
        }),
      },

      // ============================================
      // TIER 9: COMPETITIVE POSITION (Priority 550-500)
      // ============================================
      {
        id: 'INDUSTRY_LEADER',
        priority: 550,
        order: 1,
        condition: (s) => s.competitive.position === 'LEADER',
        apply: (s) => ({
          message: `üèÜ L√çDER DE INDUSTRIA: Supera al sector en ${s.competitive.scoreCount}/${s.competitive.totalMetrics} m√©tricas clave.`,
          scoreBonus: 10,
        }),
      },

      {
        id: 'INDUSTRY_LAGGARD',
        priority: 549,
        order: 2,
        condition: (s) => s.competitive.position === 'LAGGARD',
        apply: (s) => ({
          message: `üìâ REZAGO COMPETITIVO: Solo supera al sector en ${s.competitive.scoreCount}/${s.competitive.totalMetrics} m√©tricas.`,
          scorePenalty: -8,
        }),
      },

      // ============================================
      // TIER 10: CROSS-MODULE CONTRADICTIONS (Priority 400-350)
      // ============================================
      {
        id: 'GROWTH_IMPLICIT_UNREALISTIC',
        priority: 400,
        order: 1,
        condition: (s) => {
          const gImplicito = s._raw.m0?.gImplicito || 0;
          return gImplicito > s.growth.salesCAGR * 2 && s.valuation.upside < 0;
        },
        apply: (s) => {
          const gImplicito = s._raw.m0?.gImplicito || 0;
          return {
            message: `‚ö†Ô∏è CRECIMIENTO IMPL√çCITO IRREAL: El mercado descuenta ${fmtPercent(gImplicito)} perpetuo, el doble del hist√≥rico (${fmtPercent(s.growth.salesCAGR)}). Requiere cambio estructural.`,
            scorePenalty: -10,
          };
        },
      },

      {
        id: 'HIGH_QUALITY_LOW_GROWTH',
        priority: 390,
        order: 2,
        condition: (s) =>
          s.quality.tier === 'HIGH_QUALITY' &&
          s.growth.pattern === 'STAGNANT',
        apply: (s) => ({
          message: '‚öñÔ∏è CALIDAD SIN CRECIMIENTO: Rentabilidad elevada pero sin expansi√≥n. Posible madurez de mercado o falta de oportunidades de inversi√≥n.',
          scorePenalty: -3,
        }),
      },

      {
        id: 'LOW_QUALITY_HIGH_GROWTH',
        priority: 380,
        order: 3,
        condition: (s) =>
          s.quality.tier === 'LOW_QUALITY' &&
          s.growth.pattern === 'COMPOUNDER',
        apply: (s) => ({
          message: '‚ö†Ô∏è CRECIMIENTO SIN CALIDAD: Expansi√≥n r√°pida con rentabilidad baja. Riesgo de insostenibilidad.',
          scorePenalty: -8,
        }),
      },

      // ============================================
      // TIER 11: HISTORY PATTERNS (Priority 350-300)
      // ============================================
      {
        id: 'CONSISTENT_PROFIT_HISTORY',
        priority: 350,
        order: 1,
        condition: (s) => s.history.pattern === 'CONSISTENT_PROFIT',
        apply: (s) => ({
          message: `‚úÖ HISTORIAL S√ìLIDO: ${s.history.profitYears}/${s.history.totalYears} a√±os con beneficios positivos. Negocio predecible.`,
          scoreBonus: 6,
        }),
      },

      {
        id: 'POOR_HISTORY',
        priority: 340,
        order: 2,
        condition: (s) => s.history.pattern === 'POOR_HISTORY',
        apply: (s) => ({
          message: `‚ö†Ô∏è HISTORIAL IRREGULAR: Solo ${s.history.profitYears}/${s.history.totalYears} a√±os positivos. Alta incertidumbre.`,
          scorePenalty: -10,
        }),
      },

      {
        id: 'CONSECUTIVE_LOSSES',
        priority: 330,
        order: 3,
        condition: (s) => s.history.consecutiveLosses >= 3,
        apply: (s) => ({
          message: `üî¥ P√âRDIDAS CONSECUTIVAS: ${s.history.consecutiveLosses} a√±os seguidos de p√©rdidas. Crisis estructural.`,
          scorePenalty: -15,
        }),
      },
    ];

    // Add order property to all rules for tiebreaking
    CORE_RULES.forEach((rule, index) => {
      if (rule.order === undefined) rule.order = index;
    });

    // Initialize global rule engine
    const globalRuleEngine = new RuleEngine(CORE_RULES);

    // ============================================
    // RULE ENGINE INTEGRATION HELPERS
    // ============================================

    /**
     * Generate comprehensive multi-dimensional analysis using the rule engine
     * @param {Object} moduleResults - Results from all modules (m0-m9)
     * @returns {Object} Comprehensive analysis with rating, score, and insights
     */
    function generateComprehensiveAnalysis(moduleResults) {
      console.log('[COMPREHENSIVE ANALYSIS] Starting...');

      // Build module references
      const modules = {
        m0: moduleResults.module0,
        m1: moduleResults.module1,
        m2: moduleResults.module2,
        m3: moduleResults.module3,
        m4: moduleResults.module4,
        m5: moduleResults.module5,
        m6: moduleResults.module6,
        m7: moduleResults.module7,
        m8: moduleResults.module8,
        m9: moduleResults.moduleBenchmark,
      };

      // Build company state
      const companyState = buildCompanyState(modules);

      if (!companyState) {
        console.warn('[COMPREHENSIVE ANALYSIS] Failed to build company state');
        return {
          rating: 'HOLD',
          score: 50,
          insights: ['No se pudo generar an√°lisis por falta de datos'],
          summary: 'An√°lisis no disponible',
        };
      }

      // Evaluate with rule engine
      const ruleEngineResult = globalRuleEngine.evaluate(companyState);

      console.log('[COMPREHENSIVE ANALYSIS] Rule Engine Result:', {
        rating: ruleEngineResult.rating,
        score: ruleEngineResult.score,
        rulesApplied: ruleEngineResult.appliedRules.length,
        topMessages: ruleEngineResult.topMessages.length,
      });

      // Generate summary
      const summary = generateAnalysisSummary(companyState, ruleEngineResult);

      return {
        rating: ruleEngineResult.rating,
        score: ruleEngineResult.score,
        icon: ruleEngineResult.icon || '‚è∏Ô∏è',
        color: ruleEngineResult.color || 'amber',
        insights: ruleEngineResult.topMessages,
        summary: summary,
        state: companyState,
        debugLog: ruleEngineResult.debugLog,
        appliedRules: ruleEngineResult.appliedRules,
      };
    }

    /**
     * Generate human-readable summary of the analysis
     * @param {Object} state - Company state
     * @param {Object} ruleResult - Rule engine result
     * @returns {String} Summary text
     */
    function generateAnalysisSummary(state, ruleResult) {
      const parts = [];

      // Quality summary
      if (state.quality.tier === 'HIGH_QUALITY') {
        parts.push(`Empresa de alta calidad (ROE ${fmtPercent(state.quality.roeAvg)})`);
      } else if (state.quality.tier === 'LOW_QUALITY') {
        parts.push(`Rentabilidad baja (ROE ${fmtPercent(state.quality.roeAvg)})`);
      } else {
        parts.push(`Calidad media (ROE ${fmtPercent(state.quality.roeAvg)})`);
      }

      // Valuation summary
      if (state.valuation.bucket === 'DEEP_DISCOUNT') {
        parts.push('cotizando con descuento significativo');
      } else if (state.valuation.bucket === 'PREMIUM') {
        parts.push('cotizando con premium');
      } else {
        parts.push('valoraci√≥n en l√≠nea con fundamentos');
      }

      // Debt summary
      if (state.debt.tier === 'CASH_KING') {
        parts.push('sin deuda neta');
      } else if (state.debt.tier === 'DISTRESS') {
        parts.push('con estr√©s financiero');
      }

      // Growth summary
      if (state.growth.pattern === 'COMPOUNDER') {
        parts.push(`creciendo sostenidamente (${fmtPercent(state.growth.salesCAGR)} anual)`);
      } else if (state.growth.pattern === 'DECLINING') {
        parts.push(`en declive (${fmtPercent(state.growth.salesCAGR)} anual)`);
      }

      return parts.join(', ') + '.';
    }

    // ============================================
    // END OF RULE ENGINE SYSTEM
    // ============================================

    // Referencias a elementos del DOM (se inicializan al cargar)
    const fileInput = document.getElementById('file-input');
    // const dropZone removed

    const btnCalc = document.getElementById('btn-calculate');
    // const fileNameDisplay removed
    const dataStatusMsg = document.getElementById('data-status-msg');
    const placeholderPanel = document.getElementById('placeholder-panel');
    const resultsPanel = document.getElementById('results-panel');
    // const autoDataList removed

    // Funciones de utilidad globales
    function resetState() {
      rawSheets = null;
      yearMetadata = null;
      financialData = null;
      moduleResults = null;
      state.context = null;
      dataStatusMsg.classList.add('hidden');
      // autoDataList.innerHTML removed
      btnCalc.disabled = true;
      placeholderPanel.classList.remove('hidden');
      resultsPanel.classList.add('hidden');
      clearCharts();
    }

    function clearCharts() {
      while (chartRegistry.length) {
        const chart = chartRegistry.pop();
        chart.destroy();
      }
    }

    // Event listener para el input file
    fileInput.addEventListener('change', function (e) {
      console.log('üîî Input change event fired');
      if (e.target.files.length > 0) {
        handleFile(e.target.files[0]);
      }
    });

    // Event listeners para drag & drop (mantener)
    // Drag & Drop listeners removed (UI element removed)
    // The file input change listener handles the file selection.


    // Mantener el listener original para compatibilidad
    // Listener eliminado (input-period-type no existe)

    // Event listener para el bot√≥n calcular
    btnCalc.addEventListener('click', () => {
      if (!financialData) {
        alert('Carga primero un archivo.');
        return;
      }
      const options = gatherOptions();
      try {
        runAllModules(options);
      } catch (error) {
        console.error(error);
        alert(error.message || 'Error al calcular los m√≥dulos');
      }
    });

    async function handleFile(file) {
      console.log('=== HANDLEFILE CALLED ===');
      console.log('File object:', file);

      if (!file) {
        console.log('‚ùå No file provided - user cancelled');
        return;
      }

      console.log('‚úÖ File received:', file.name, 'Size:', file.size, 'Type:', file.type);

      try {
        console.log('üîÑ Calling resetState...');
        resetState();
        console.log('‚úÖ resetState completed');

        // fileNameDisplay removed (not shown in new UI)

        console.log('üîÑ Reading file buffer...');
        const buffer = await file.arrayBuffer();
        console.log('‚úÖ Buffer read, size:', buffer.byteLength);

        console.log('üîÑ Parsing Excel with XLSX...');
        const workbook = XLSX.read(buffer, { type: 'array' });
        console.log('‚úÖ Workbook parsed, sheets:', workbook.SheetNames);

        console.log('üîÑ Processing workbook...');
        processWorkbook(workbook);
        console.log('‚úÖ Workbook processed');

        console.log('üîÑ Updating UI...');
        dataStatusMsg.classList.remove('hidden');
        btnCalc.disabled = false;
        console.log('‚úÖ UI updated - file loaded successfully!');

      } catch (error) {
        console.error('‚ùå ERROR in handleFile:', error);
        console.error('Error stack:', error.stack);
        alert('Error al leer el archivo. Verifica el formato.\n\nError: ' + error.message);
      }
    }

    function processWorkbook(workbook) {
      const required = ['BALANCE', 'EERR', 'FCFE', 'DATOS'];
      const sheetNames = workbook.SheetNames.reduce((acc, name) => ({ ...acc, [normalizeKey(name)]: name }), {});
      required.forEach((sheet) => {
        if (!sheetNames[normalizeKey(sheet)]) {
          console.error(`Falta la pesta√±a: ${sheet}. Pesta√±as encontradas: ${Object.keys(sheetNames).join(', ')}`);
          throw new Error(`El archivo Excel no tiene la pesta√±a requerida: "${sheet}".\n\nPesta√±as encontradas: ${Object.keys(sheetNames).join(', ')}`);
        }
      });

      // Buscar pesta√±a opcional RATIOS o INDUSTRIA
      const ratiosSheetKey = Object.keys(sheetNames).find(k => k.includes('ratios') || k.includes('industria'));
      console.log('=== HOJAS DEL EXCEL ===');
      console.log('Hojas encontradas:', Object.keys(sheetNames));
      console.log('Hoja de RATIOS/INDUSTRIA encontrada:', ratiosSheetKey || 'NINGUNA');

      rawSheets = {
        BALANCE: XLSX.utils.sheet_to_json(workbook.Sheets[sheetNames['balance']], { header: 1, defval: '' }),
        EERR: XLSX.utils.sheet_to_json(workbook.Sheets[sheetNames['eerr']], { header: 1, defval: '' }),
        FCFE: XLSX.utils.sheet_to_json(workbook.Sheets[sheetNames['fcfe']], { header: 1, defval: '' }),
        DATOS: XLSX.utils.sheet_to_json(workbook.Sheets[sheetNames['datos']], { header: 1, defval: '' }),
        RATIOS: ratiosSheetKey ? XLSX.utils.sheet_to_json(workbook.Sheets[sheetNames[ratiosSheetKey]], { header: 1, defval: '' }) : [],
      };

      yearMetadata = findYearsAndIndices(rawSheets.BALANCE);
      if (!yearMetadata) {
        throw new Error('No se detectaron a√±os en BALANCE');
      }

      // populateYearSelectors eliminado (elementos UI eliminados)
      const industryData = buildIndustryData(rawSheets.RATIOS);
      financialData = buildFinancialData(rawSheets, yearMetadata, industryData); // Pass industryData to buildFinancialData

      // G Explicita logic (Safe Guarded)
      let gPro = null;
      let gProDebug = null;

      try {
        const gProResult = computeGExplicitaPro(financialData) || {};
        gPro = gProResult.value ?? null;
        gProDebug = gProResult.debug ?? null;
      } catch (err) {
        console.error('Error calculating G Explicita Pro:', err);
      }

      const gExplicitaInput = financialData?.datos?.gExplicita ?? null;

      // CAMBIO: Eliminado el fallbackDefault del 10%

      let gSource = null;
      let gFinal = null;

      // 1. Prioridad: C√°lculo Autom√°tico (Si es v√°lido)
      if (gPro !== null && gPro !== undefined) {
        gFinal = gPro;
        gSource = 'pro';
      }
      // 2. Prioridad: Input Manual en Excel (Si existe)
      else if (gExplicitaInput !== null && gExplicitaInput !== undefined) {
        gFinal = gExplicitaInput;
        gSource = 'datos';
      }
      // 3. NO HAY DATOS -> LANZAR ERROR BLOQUEANTE
      else {
        throw new Error(
          "‚õî ERROR CR√çTICO: No se pudo calcular la Tasa de Crecimiento (g) y no se encontr√≥ un valor manual.\n\n" +
          "El sistema no detect√≥ suficientes a√±os positivos hist√≥ricos para proyectar una tendencia fiable, y no hay un valor de respaldo en la hoja de Datos.\n\n" +
          "SOLUCI√ìN:\n" +
          "Vaya a la pesta√±a 'DATOS' de su Excel y agregue una fila llamada 'g expl√≠cita' con un valor manual (ej: 5% o 0.05)."
        );
      }

      if (financialData?.datos) {
        financialData.datos.gExplicita = gFinal;
        financialData.datos.gExplicitaSource = gSource;
        financialData.datos.gExplicitaInput = gExplicitaInput;
        financialData.datos.gExplicitaDebug = gProDebug || null;
      }
      console.log('gExplicitaPro Result:', { value: gPro, source: gSource });
    }

    // function populateYearSelectors removed


    // function renderAutoData removed


    btnCalc.addEventListener('click', () => {
      if (!financialData) {
        alert('Carga primero un archivo.');
        return;
      }
      const options = gatherOptions();
      try {
        runAllModules(options);
      } catch (error) {
        console.error(error);
        alert(error.message || 'Error al calcular los m√≥dulos');
      }
    });

    function gatherOptions() {
      const datos = financialData?.datos ?? {};
      return {
        yearsProj: datos.yearsProj || 5,
        currency: (financialData?.datos?.monedaBase || 'CLP').toUpperCase(),
        scale: financialData?.datos?.magnitud || 1,
        rf: datos.rf ?? null,
        rm: datos.rm ?? null,
        gPerp: datos.gPerpetuidad ?? null,
        tax: datos.tax ?? null,
      };
    }

    function normalizePercent(value) {
      if (value === null || value === undefined || Number.isNaN(value)) return null;
      return value > 1 ? value / 100 : value;
    }



    function renderResults(results) {
      placeholderPanel.classList.add('hidden');
      resultsPanel.classList.remove('hidden');
      clearCharts();

      // Set company name in header
      const companyNameEl = document.getElementById('company-name');
      if (companyNameEl && financialData && financialData.datos) {
        const companyName = financialData.datos.empresa || 'EMPRESA NO IDENTIFICADA';
        companyNameEl.textContent = companyName;
      }

      renderModuleSections(results);
    }

    // Toggle all modules expand/collapse
    function toggleAllModules() {
      const container = document.getElementById('modules-container');
      if (!container) return;

      const allDetails = container.querySelectorAll('details');
      if (!allDetails.length) return;

      // Check if majority are open
      const openCount = Array.from(allDetails).filter(d => d.open).length;
      const shouldOpen = openCount < allDetails.length / 2;

      // Apply to all
      allDetails.forEach(detail => {
        detail.open = shouldOpen;
      });
    }

    // ============================================
    // DYNAMIC CONTEXTUAL SIDEBAR (GLOSSARY)
    // ============================================

    const MODULE_GLOSSARY_MAP = {
      'module-1': [
        'EBIT', 'UTILIDAD_NETA', 'MARGEN_NETO', 'MARGEN_OP', 'FCFE', 'DEUDA_NETA',
        'ROE', 'ROA', 'VOLATILIDAD_ROE', 'CONSISTENCIA_ROE'
      ],
      'module-2': ['MARKET_CAP', 'EV', 'EV_FCFE', 'PER', 'P_BV'],
      'module-3': ['PAYOUT_POLITICA', 'RETENCION_REINVERSION', 'CRECIMIENTO_G', 'EPS_PROYECTADO', 'P_BV_PROYECTADO'], // M√≥dulo 3: Proyecci√≥n
      'module-4': ['DEUDA_PATRIMONIO', 'LIQUIDEZ', 'COBERTURA_INTERESES'],
      'module-5': ['ROT_INVENTARIOS', 'ROT_ACTIVOS', 'ROTACION_CAP_TRABAJO'],
      'module-6': ['CAGR_VENTAS', 'CAGR_UTILIDAD', 'CAGR_PATRIMONIO', 'CAGR_FCFE'],
      'module-7': ['CAGR_VENTAS', 'PER', 'P_BV'],
      'module-8': ['PRECIO_JUSTO', 'METODO_PER', 'METODO_PBV', 'METODO_HISTORICO'],
      'module-9': ['FCFE_YIELD']
    };

    // Extensiones manuales para t√©rminos que podr√≠an faltar en RATIO_DEFINITIONS
    const MANUAL_DEFINITIONS = {
      // --- M√ìDULO 1 ---
      'EBIT': { name: "EBIT", meaning: "Beneficio antes de intereses e impuestos. Mide la potencia operativa pura de la empresa.", formula: "Utilidad Operativa" },
      'UTILIDAD_NETA': { name: "Utilidad Neta", meaning: "La 'Bottom Line'. Cu√°nto gan√≥ realmente la empresa despu√©s de pagar todo.", formula: "Ingresos - Gastos Totales" },
      'MARGEN_NETO': { name: "Margen Neto", meaning: "Porcentaje de cada venta que se convierte en ganancia final.", formula: "Utilidad Neta / Ventas" },
      'MARGEN_OP': { name: "Margen Operacional", meaning: "% de ventas tras costos operacionales. Eficiencia del negocio base.", formula: "EBIT / Ventas" },
      'FCFE': { name: "FCFE", meaning: "Flujo de Caja Libre para el Accionista. El dinero real disponible para pagar dividendos o recomprar acciones.", formula: "CFO - Capex + Deuda Neta Emitida" },
      'DEUDA_NETA': { name: "Deuda Neta", meaning: "Deuda financiera total menos el efectivo en caja. Lo que 'realmente' debe.", formula: "Deuda CP + LP - Caja" },
      'ROE': { name: "ROE", meaning: "Retorno sobre Patrimonio. La rentabilidad del capital de los due√±os.", formula: "Utilidad Neta / Patrimonio" },
      'ROA': { name: "ROA", meaning: "Retorno sobre Activos. Rentabilidad de todos los recursos de la empresa.", formula: "Utilidad Neta / Activos" },
      'PAYOUT': { name: "Payout Ratio", meaning: "% de la utilidad que se reparte como dividendos.", formula: "Dividendos / Utilidad Neta" },
      'RETENCION': { name: "Retenci√≥n", meaning: "% de la utilidad que se reinvierte en el negocio para crecer.", formula: "1 - Payout" },
      'VOLATILIDAD_ROE': { name: "Volatilidad ROE", meaning: "Desviaci√≥n est√°ndar del ROE hist√≥rico. Mide la estabilidad de la rentabilidad.", formula: "StdDev(ROE)" },
      'CONSISTENCIA_ROE': { name: "Consistencia ROE", meaning: "Evaluaci√≥n cualitativa de qu√© tan estable ha sido el ROE en el tiempo.", formula: "An√°lisis de Tendencia" },
      'CAGR_VENTAS_5Y': { name: "Ventas (CAGR 5A)", meaning: "Crecimiento anual compuesto de las ventas en los √∫ltimos 5 a√±os.", formula: "(V_final/V_inicial)^(1/5)-1" },
      'CAGR_BENEFICIO_NETO_5Y': { name: "Beneficio Neto (CAGR 5A)", meaning: "Crecimiento compuesto de las utilidades en 5 a√±os.", formula: "(U_final/U_inicial)^(1/5)-1" },
      'CAGR_PATRIMONIO_5Y': { name: "Patrimonio (CAGR 5A)", meaning: "Crecimiento del valor libro en 5 a√±os. Indica creaci√≥n de valor.", formula: "(P_final/P_inicial)^(1/5)-1" },

      // --- M√ìDULO 2 ---
      'MARKET_CAP': { name: "Market Cap", meaning: "Valor total de mercado de todas las acciones de la empresa.", formula: "Precio * N¬∞ Acciones" },
      'EV': { name: "EV (Enterprise Value)", meaning: "Valor de la Empresa completo, como si la compraras deslistada (Equity + Deuda - Caja).", formula: "Market Cap + Deuda Neta" },
      'EV_FCFE': { name: "EV / FCFE", meaning: "M√∫ltiplo de valoraci√≥n respecto al flujo de caja libre.", formula: "Enterprise Value / FCFE" },
      'PER': { name: "PER", meaning: "Precio / Utilidad. Cu√°ntos a√±os tardas en recuperar la inversi√≥n v√≠a beneficios.", formula: "Precio / EPS" },
      'P_BV': { name: "P/BV (Price/Book Value)", meaning: "Precio sobre Valor Libro. Cu√°nto pagas por cada $1 de patrimonio contable.", formula: "Precio / BVPS" },

      // --- M√ìDULO 3 ---
      'PAYOUT_POLITICA': { name: "Payout (Pol√≠tica)", meaning: "Supuesto de distribuci√≥n de dividendos usado para la proyecci√≥n futura.", formula: "% de Utilidad a Distribuir" },
      'RETENCION_REINVERSION': { name: "Retenci√≥n (Reinversi√≥n)", meaning: "Porcentaje de utilidad retenida para financiar el crecimiento futuro.", formula: "1 - Payout" },
      'CRECIMIENTO_G': { name: "Crecimiento (g)", meaning: "Tasa de crecimiento sostenible proyectada basada en ROE y Retenci√≥n.", formula: "ROE * Retenci√≥n" },
      'EPS_PROYECTADO': { name: "EPS Proyectado", meaning: "Estimaci√≥n de la Utilidad por Acci√≥n futura aplicando la tasa de crecimiento.", formula: "EPS * (1+g)^n" },
      'P_BV_PROYECTADO': { name: "P/BV Proyectado", meaning: "Valor Libro proyectado futuro para estimar precios objetivos.", formula: "BVPS * (1+g)^n" },

      // --- OTROS ---
      'PEG': { name: "Ratio PEG", meaning: "PER ajustado por crecimiento. < 1 indica subvaloraci√≥n.", formula: "PER / g" },
      'CAGR_EPS': { name: "CAGR EPS", meaning: "Crecimiento hist√≥rico del EPS.", formula: "CAGR" },
      'DEUDA_PATRIMONIO': { name: "Deuda / Patrimonio", meaning: "Nivel de apalancamiento financiero.", formula: "Deuda / Patrimonio" },
      'LIQUIDEZ': { name: "Liquidez Corriente", meaning: "Solvencia de corto plazo.", formula: "Activo CTE / Pasivo CTE" },
      'COBERTURA_INTERESES': { name: "Cobertura de Intereses", meaning: "Capacidad de pagar intereses con la operaci√≥n.", formula: "EBIT / Gastos Financieros" },
      'ROT_INVENTARIOS': { name: "Rotaci√≥n Inventarios", meaning: "Veces que rota el stock al a√±o.", formula: "Costo / Inventario" },
      'ROT_ACTIVOS': { name: "Rotaci√≥n de Activos", meaning: "Eficiencia de activos para generar ventas.", formula: "Ventas / Activos" },
      'ROTACION_CAP_TRABAJO': { name: "Rotaci√≥n Cap. Trabajo", meaning: "Mide cu√°n eficientemente la empresa usa su capital de trabajo para generar ventas.", formula: "Ventas / Capital de Trabajo" },
      'CICLO_CONVERSION': { name: "Ciclo Conv. Efectivo", meaning: "D√≠as para cobrar, vender y pagar.", formula: "CCC" },
      'CAGR_VENTAS': { name: "Crecimiento Ventas", meaning: "Tendencia de ingresos.", formula: "CAGR" },
      'CAGR_PATRIMONIO': { name: "Crecimiento Patrimonio", meaning: "Acumulaci√≥n de riqueza.", formula: "CAGR" },
      'ROIC': { name: "ROIC", meaning: "Retorno sobre el Capital Invertido.", formula: "NOPAT / Invested Capital" },
      'SPREAD_ROIC_WACC': { name: "Spread ROIC-WACC", meaning: "Creaci√≥n de valor econ√≥mico.", formula: "ROIC - WACC" },
      'WACC': { name: "WACC", meaning: "Costo de Capital Promedio Ponderado.", formula: "Ke + Kd" },
      'VALOR_TERMINAL': { name: "Valor Terminal", meaning: "Valor perpetuo al final de la proyecci√≥n.", formula: "TV" },
      'YIELD_ON_COST': { name: "Yield on Cost", meaning: "Dividendos sobre tu costo original.", formula: "Div / Costo" },
      'INTERES_COMPUESTO': { name: "Inter√©s Compuesto", meaning: "Ganancia sobre ganancia.", formula: "Exponencial" }
    };

    function updateSidebar() {
      const container = document.getElementById('modules-container');
      if (!container) return;

      const sidebar = document.getElementById('smart-sidebar');
      if (!sidebar) return;

      const openDetails = Array.from(container.querySelectorAll('details[open]'));
      const count = openDetails.length;

      // Limpiar sidebar
      sidebar.innerHTML = '';
      sidebar.className = ''; // Reset CSS classes

      // ESTRATEGIA DE POSICIONAMIENTO ABSOLUTO
      // El sidebar debe ser un lienzo 'state.relative' que mapee la altura del contenedor de m√≥dulos.
      // Cada bloque de glosario se posicionar√° absolutamente a la altura (offsetTop) de su m√≥dulo correspondiente.

      sidebar.style.position = 'relative';
      sidebar.style.height = `${container.offsetHeight}px`; // Sincronizar altura total
      // Eliminamos sticky/margins anteriores ya que usaremos coordenadas absolutas
      sidebar.classList.remove('sticky', 'top-24', 'space-y-4');
      sidebar.style.marginTop = '0px';

      // ===============================================
      // ESTADO 0: BIENVENIDA (Sin m√≥dulos abiertos)
      // ===============================================
      if (count === 0) {
        // En estado 0, mostramos la tarjeta sticky arriba
        sidebar.innerHTML = `
            <div class="sticky top-24 bg-white dark:bg-slate-800 p-6 rounded-xl border border-slate-100 dark:border-slate-700 shadow-lg text-center animate-fade-in-up">
                <div class="mb-4 text-4xl">üëã</div>
                <h3 class="font-bold text-slate-700 dark:text-gray-200 mb-2">Asistente Inteligente</h3>
                <p class="text-xs text-slate-500 dark:text-slate-400 leading-relaxed">
                    Abre un m√≥dulo de an√°lisis para ver aqu√≠ autom√°ticamente el **Glosario Contextual** alineado con tu lectura.
                </p>
                <div class="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                    <p class="text-[10px] font-bold text-blue-600 dark:text-blue-300 uppercase">Tip de Navegaci√≥n</p>
                    <p class="text-[10px] text-blue-500 dark:text-blue-400 mt-1">La informaci√≥n aparecer√° justo al lado del m√≥dulo que abras.</p>
                </div>
            </div>
        `;
        sidebar.style.height = 'auto'; // Permitir altura natural en estado 0
        return;
      }

      // ===============================================
      // ESTADO ACTIVO: RENDERIZADO POR COORDENADAS
      // ===============================================

      // Obtenemos coordenadas base del contenedor para calcular offsets relativos
      const containerRect = container.getBoundingClientRect();

      openDetails.forEach(detail => {
        // 1. Identificar M√≥dulo
        const moduleClass = Array.from(detail.classList).find(c => c.match(/^module-\d+$/));
        const title = detail.querySelector('summary span')?.innerText.split('¬∑')[1] || 'M√≥dulo';

        if (!moduleClass || !MODULE_GLOSSARY_MAP[moduleClass]) return;

        // 2. Calcular Posici√≥n "Top" Relativa
        // Usamos getBoundingClientRect para ser precisos respecto al viewport, luego restamos el top del contenedor
        const detailRect = detail.getBoundingClientRect();
        const relativeTop = detailRect.top - containerRect.top;
        const minHeight = detailRect.height; // Altura m√≠nima para que acompa√±e al m√≥dulo

        // 3. Generar Contenido del Glosario
        const keys = MODULE_GLOSSARY_MAP[moduleClass];
        let cardsHtml = '';

        keys.forEach(key => {
          let def = RATIO_DEFINITIONS[key] || MANUAL_DEFINITIONS[key];
          if (!def) def = { name: key, meaning: "Definici√≥n no disponible.", formula: "" };

          cardsHtml += `
                <div class="bg-white dark:bg-slate-800 p-4 rounded-xl border-l-4 border-blue-500 shadow-sm mb-3 transition-all hover:translate-x-1 group">
                    <div class="flex justify-between items-start mb-1">
                         <h5 class="font-bold text-slate-800 dark:text-white text-sm uppercase tracking-wide">${def.name}</h5>
                         ${def.formula ? `<span class="text-[10px] font-mono bg-slate-100 dark:bg-slate-900/50 px-2 py-0.5 rounded text-slate-600 dark:text-slate-400 opacity-0 group-hover:opacity-100 transition-opacity">∆í</span>` : ''}
                    </div>
                    <p class="text-xs text-slate-500 dark:text-slate-400 leading-relaxed text-justify">
                        ${def.meaning}
                    </p>
                    ${def.formula ? `
                        <div class="mt-2 text-[10px] font-mono bg-slate-100 dark:bg-slate-900/50 px-2 py-1 rounded inline-block text-slate-600 dark:text-slate-400 break-all">
                            ${def.formula}
                        </div>
                    ` : ''}
                </div>
             `;
        });

        // 4. Crear Wrapper Absoluto
        // Este div flotar√° exactamente a la altura (relativeTop) del m√≥dulo
        const wrapper = document.createElement('div');
        wrapper.style.position = 'absolute';
        wrapper.style.top = `${relativeTop}px`;
        wrapper.style.width = '100%';
        wrapper.style.paddingBottom = '20px'; // Espacio visual

        wrapper.innerHTML = `
            <div class="mb-2 px-2 flex items-center gap-2">
                <span class="w-1.5 h-1.5 rounded-full bg-slate-300 dark:bg-slate-600"></span>
                <h4 class="text-[10px] font-black uppercase text-slate-400 tracking-wider">Conceptos: ${title}</h4>
            </div>
            <div class="space-y-3">
                ${cardsHtml}
            </div>
         `;

        sidebar.appendChild(wrapper);
      });
    }

    function renderModuleSections(results) {
      // Guardar resultados globales para el sidebar

      const container = document.getElementById('modules-container');
      const moduleDefs = [
        {
          key: 'module1',
          title: '1.1 - 1.3 ‚Äì DIAGNOSTICO ACTUAL Y CALIDAD ESTRUCTURAL <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Salud del Negocio</span>',
          renderer: renderModule1
        },
        {
          key: 'module5',
          title: '1.4 ‚Äì DEUDA Y SOLVENCIA <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Resistencia Financiera</span>',
          renderer: renderModule5
        },
        {
          key: 'module6',
          title: '1.5 ‚Äì GESTION OPERATIVA <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Eficiencia y Rotaci√≥n</span>',
          renderer: renderModule6
        },
        {
          key: 'moduleBenchmark',
          title: '1.6 ‚Äì BENCHMARK <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Posici√≥n Competitiva</span>',
          renderer: renderModule9Benchmark
        },
        {
          key: 'module7',
          title: '1.7 ‚Äì CRECIMIENTO HISTORICO <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Expansi√≥n Real (5 A√±os)</span>',
          renderer: renderModule7
        },
        {
          key: 'module2',
          title: '2.1 ‚Äì MULTIPLOS HISTORICOS VS MULTIPLOS ACTUALES <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Comparativa de Valor</span>',
          renderer: renderModule2
        },
        {
          key: 'module4',
          title: '2.2 ‚Äì PROYECCION DE VALOR <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Trayectoria Estimada</span>',
          renderer: renderModule4
        },
        {
          key: 'module8',
          title: '3 ‚Äì PRECIO OBJETIVO FINAL <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Veredicto de Inversi√≥n</span>',
          renderer: renderModule8
        },
        {
          key: 'module9Yield',
          title: 'AP√âNDICE ‚Äì SIMULADOR DE RETORNO <span class="block sm:inline text-slate-500 dark:text-slate-400 font-normal sm:ml-2 text-xs sm:text-sm">¬∑ Proyecci√≥n de Flujo al Accionista</span>',
          renderer: renderModule9Yield
        }
      ];

      // Generate HTML with custom titles (No auto-numbering prefix)
      container.innerHTML = moduleDefs
        .map((module, idx) => `
          <details id="module-section-${idx + 1}" class="bg-white dark:bg-slate-800 rounded-2xl shadow module-card module-${idx + 1}">
            <summary class="px-6 py-4 text-base font-semibold cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors">
              <div class="flex justify-between items-center w-full">
                <span>${module.title}</span>
                <div class="flex items-center gap-3">
                  <button type="button" class="btn-back-dashboard" onclick="event.stopPropagation(); scrollToDashboard();">‚¨Ü Volver al Dashboard</button>
                  <svg class="chevron w-5 h-5 text-slate-400 transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                  </svg>
                </div>
              </div>
            </summary>
            <div id="${module.key}-body" class="module-body px-6 pb-6 pt-2 border-t border-slate-100 dark:border-slate-700"></div>
          </details>
        `)
        .join('');

      // Add listeners for Smart Sidebar
      container.querySelectorAll('details').forEach(el => {
        el.addEventListener('toggle', updateSidebar);
      });

      // Initial Sidebar Update
      setTimeout(updateSidebar, 100);



      // Render each module's content
      moduleDefs.forEach((module) => {
        if (results[module.key]) {
          module.renderer(results[module.key], document.getElementById(`${module.key}-body`), results);
        }
      });

      // Show the toggle-all button now that modules are rendered
      const toggleBtn = document.getElementById('toggle-all-modules');
      if (toggleBtn) {
        toggleBtn.classList.remove('hidden');
      }

      // Show the simulador retorno button
      const simuladorBtn = document.getElementById('btn-simulador-retorno');
      if (simuladorBtn) {
        simuladorBtn.classList.remove('hidden');
      }
    }

    function renderModule9Benchmark(data, container) {
      if (!data || !data.metrics) {
        container.innerHTML = '<p class="text-sm text-slate-500">No hay datos de benchmarking disponibles.</p>';
        return;
      }

      const getStatusBadge = (status) => {
        if (status === 'good') return '<span class="px-2 py-1 rounded bg-emerald-100 text-emerald-800 text-xs font-bold">L√çDER üü¢</span>';
        if (status === 'warning') return '<span class="px-2 py-1 rounded bg-amber-100 text-amber-800 text-xs font-bold">ACEPTABLE üü°</span>';
        if (status === 'bad') return '<span class="px-2 py-1 rounded bg-rose-100 text-rose-800 text-xs font-bold">REZAGADA üî¥</span>';
        return '<span class="px-2 py-1 rounded bg-slate-100 text-slate-500 text-xs font-bold">N/A</span>';
      };

      const formatVal = (val, type) => {
        if (val === null || val === undefined) return '‚Äî';
        return type === 'percent' ? fmtPercent(val) : fmtNumber(val, 2) + 'x';
      };

      const rows = data.metrics.map(m => `
         <tr class="border-b border-slate-100 dark:border-slate-700 last:border-0 hover:bg-slate-50 dark:hover:bg-slate-700/30 transition-colors">
           <td class="py-3 text-sm font-medium text-slate-700 dark:text-slate-300">${m.name}</td>
           <td class="py-3 text-sm font-bold text-slate-900 dark:text-white">${formatVal(m.company, m.format)}</td>
           <td class="py-3 text-sm text-slate-500 font-mono">${formatVal(m.industry, m.format)}</td>
           <td class="py-3 text-right">${getStatusBadge(m.status)}</td>
         </tr>
       `).join('');

      // Conclusi√≥n de Posicionamiento Competitivo
      const conclusion = data.conclusion || {};
      const conclusionColor = conclusion.type === 'bad' ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100' :
        conclusion.type === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100' :
          conclusion.type === 'excellent' ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 text-purple-900 dark:text-purple-100' :
            conclusion.type === 'good' ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100' :
              'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100';

      const conclusionHtml = conclusion.title ? `
        <div class="mb-6 border-l-4 ${conclusionColor} rounded-r-xl p-5 shadow-sm">
          <div class="flex items-start gap-4">
            <div class="text-4xl flex-shrink-0">${conclusion.icon}</div>
            <div class="flex-1">
              <h4 class="text-base font-bold uppercase mb-2 opacity-90">${conclusion.title}</h4>
              <p class="text-sm leading-relaxed opacity-90">${conclusion.message}</p>
            </div>
          </div>
        </div>
      ` : '';

      container.innerHTML = `
         ${conclusionHtml}
         <div class="overflow-hidden rounded-xl border border-slate-200 dark:border-slate-700">
           <table class="w-full text-left">
             <thead class="bg-slate-50 dark:bg-slate-900/50">
               <tr>
                 <th class="py-3 px-4 text-xs font-bold uppercase text-slate-400">M√©trica</th>
                 <th class="py-3 px-4 text-xs font-bold uppercase text-slate-400">Empresa</th>
                 <th class="py-3 px-4 text-xs font-bold uppercase text-slate-400">Industria</th>
                 <th class="py-3 px-4 text-right text-xs font-bold uppercase text-slate-400">Estado</th>
               </tr>
             </thead>
             <tbody class="divide-y divide-slate-100 dark:divide-slate-700 bg-white dark:bg-slate-800 px-4">
               ${rows}
             </tbody>
           </table>
         </div>
         <p class="mt-4 text-xs text-slate-400 italic">
           * Datos de industria extra√≠dos de la pesta√±a "RATIOS" del Excel reportado. Si est√° vac√≠a, se asumen valores nulos.
         </p>
       `;
    }

    function renderModule0(module0, container) {
      // Necesitamos acceso a datos y m√≥dulo 1 para la conclusi√≥n
      const datos = financialData.datos || {};
      const companyName = (datos.empresa || 'Empresa').toUpperCase();
      const module1 = moduleResults?.module1 || null;

      // Actualizar t√≠tulo
      // Actualizar t√≠tulo din√°mico
      const companyLabel = document.getElementById('company-name');
      if (companyLabel) companyLabel.textContent = companyName;

      document.title = `Dashboard Fundamental DCF ¬∑ ${companyName}`;

      // C√°lculos previos
      const diffMarket = datos.precioActualCLP ? safeDivide(module0.pDCF - datos.precioActualCLP, datos.precioActualCLP) : null;
      const diffAnalyst = datos.precioAnalistasCLP ? safeDivide(module0.pDCF - datos.precioAnalistasCLP, datos.precioAnalistasCLP) : null;
      const rec = buildRecommendation(diffMarket);
      const summMarket = diffMarket === null ? 'No hay precio de mercado.' : `El precio justo est√° ${fmtPercent(diffMarket)} vs mercado.`;
      const summAnalyst = diffAnalyst === null ? 'Sin precio de analistas.' : `Comparado con analistas: ${fmtPercent(diffAnalyst)}.`;

      // Generar conclusi√≥n de valoraci√≥n
      const cagrVentas = module1?.cagr?.ventas || null;
      const valuationConclusion = generateValuationConclusion(
        module0.pDCF,
        module0.precioMercado,
        module0.gImplicito,
        cagrVentas !== null,
        cagrVentas
      );

      const conclusionColorClass = valuationConclusion.type === 'excellent' ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100' :
        valuationConclusion.type === 'good' ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800 text-blue-900 dark:text-blue-100' :
          valuationConclusion.type === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100' :
            valuationConclusion.type === 'bad' ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100' :
              'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100';

      // Generar HTML de Time to Value
      let timeToValueHTML = '';
      if (module0.timeToValue) {
        const ttv = module0.timeToValue;
        const conclusionColorClass = ttv.conclusionType === 'excellent' ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-300 dark:border-emerald-700' :
          ttv.conclusionType === 'good' ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-300 dark:border-blue-700' :
            ttv.conclusionType === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-300 dark:border-amber-700' :
              'bg-red-50 dark:bg-red-900/20 border-red-300 dark:border-red-700';

        timeToValueHTML = `
          <div class="bg-white dark:bg-slate-800 rounded-xl p-5 border border-slate-200 dark:border-slate-700">
            <h4 class="text-sm font-bold text-slate-700 dark:text-slate-300 uppercase mb-3 flex items-center gap-2">
              <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
              </svg>
              Convergencia Temporal de Valor (Time to Value)
            </h4>
            <p class="text-xs text-slate-500 dark:text-slate-400 mb-3">¬øCu√°ntos a√±os tarda el valor intr√≠nseco en alcanzar el precio de mercado?</p>
            
            <!-- Canvas para Chart.js -->
            <div class="mb-4">
              <canvas id="chart-time-to-value" class="w-full" style="height: 300px;"></canvas>
            </div>
            
            <!-- Tarjeta de Conclusi√≥n -->
            <div class="border-2 ${conclusionColorClass} rounded-lg p-4">
              <p class="text-sm leading-relaxed">${ttv.conclusion}</p>
              ${ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 ? `
                <div class="mt-3 pt-3 border-t border-slate-200 dark:border-slate-600 grid grid-cols-3 gap-2 text-center text-xs">
                  <div>
                    <p class="text-slate-500 dark:text-slate-400 uppercase mb-1">Valor Hoy</p>
                    <p class="font-bold">${fmtCurrency(ttv.precioDCF)}</p>
                  </div>
                  <div>
                    <p class="text-slate-500 dark:text-slate-400 uppercase mb-1">Precio Mercado</p>
                    <p class="font-bold text-red-600 dark:text-red-400">${fmtCurrency(ttv.precioMercado)}</p>
                  </div>
                  <div>
                    <p class="text-slate-500 dark:text-slate-400 uppercase mb-1">A√±os Convergencia</p>
                    <p class="font-bold text-blue-600 dark:text-blue-400">${ttv.yearsToCatchUp === 0 ? 'Hoy' : ttv.yearsToCatchUp + ' a√±os'}</p>
                  </div>
                </div>
              ` : ''}
            </div>
          </div>
        `;
      } else {
        timeToValueHTML = `<div class="bg-slate-100 dark:bg-slate-800 rounded-xl p-5 border border-slate-200 dark:border-slate-700 text-center text-slate-500">
          <p>An√°lisis de convergencia temporal no disponible</p>
          <p class="text-xs mt-2">Falta precio de mercado o par√°metros de crecimiento</p>
        </div>`;
      }

      // Reverse DCF y Conclusi√≥n eliminados - solo mostramos Time to Value

      // Inyectar HTML
      container.innerHTML = `
      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div class="bg-slate-900 text-white rounded-xl p-4">
          <p class="text-xs uppercase text-slate-300">Precio justo por acci√≥n</p>
          <p class="text-2xl font-bold" title="${moduleFormulas.dcf_price}\n\nVNA: ${fmtCurrency(module0.vnaCLP)}\nAcciones: ${fmtNumber(datos.numeroAcciones, 0)}\nKe: ${fmtPercent(module0.ke)}\ng expl√≠cita: ${fmtPercent(module0.gExplicita)}\ng perpetua: ${fmtPercent(module0.gPerpetuidad)}">${fmtCurrency(module0.pDCF)}</p>
        </div>
        <div class="bg-blue-50 dark:bg-blue-900/30 border border-blue-100 dark:border-blue-900 rounded-xl p-4">
          <p class="text-xs uppercase text-blue-500">Precio mercado</p>
          <p class="text-2xl font-bold text-blue-600 dark:text-blue-200">${datos.precioActualCLP ? fmtCurrency(datos.precioActualCLP) : '‚Äî'}</p>
        </div>
        <div class="bg-purple-50 dark:bg-purple-900/30 border border-purple-100 dark:border-purple-900 rounded-xl p-4">
          <p class="text-xs uppercase text-purple-500">Precio analistas</p>
          <p class="text-2xl font-bold text-purple-600 dark:text-purple-200">${datos.precioAnalistasCLP ? fmtCurrency(datos.precioAnalistasCLP) : '‚Äî'}</p>
        </div>
      </div>
      


      <!-- NUEVO PANEL DE AN√ÅLISIS DCF -->
      <div class="mt-6">
        <h3 class="text-lg font-bold text-slate-700 dark:text-slate-300 mb-4 uppercase">üìä An√°lisis de Convergencia Temporal</h3>
        
        <!-- Time to Value (Full Width) -->
        <div class="w-full">
          ${timeToValueHTML}
        </div>
      </div>

      <div class="mt-4 flex justify-between items-center bg-slate-50 dark:bg-slate-900/40 p-3 rounded-lg">
          <p class="text-sm text-slate-500 font-mono">Moneda base estados: ${(datos.monedaBase || 'CLP').toUpperCase()}</p>
      </div>
      
      <!-- Debug Section -->
      <div class="mt-4 border-t border-slate-200 dark:border-slate-700 pt-4">
        <details>
           <summary class="text-xs uppercase text-slate-400 font-bold cursor-pointer hover:text-slate-600 flex items-center gap-2">
             <span>üõ†Ô∏è Debug de C√°lculo (DCF)</span>
             <span class="text-[10px] font-normal opacity-50">(Revisar datos de entrada)</span>
           </summary>
           <div class="mt-3 overflow-x-auto bg-slate-50 dark:bg-slate-900/50 p-3 rounded-lg border border-slate-200 dark:border-slate-700">
              <table class="w-full text-xs font-mono text-slate-600 dark:text-slate-300 table-auto">
                <tbody class="divide-y divide-slate-200 dark:divide-slate-700">
                   <tr><td class="py-1">FCFE Base (Inicio):</td><td class="text-right font-semibold">${fmtNumber(module0.fcfeBase, 0)}</td></tr>
                   <tr><td class="py-1">Tasa Descuento (Ke):</td><td class="text-right font-semibold">${fmtPercent(module0.ke, 2)}</td></tr>
                   <tr><td class="py-1">Crecimiento Expl√≠cito (gExp):</td><td class="text-right font-semibold">${fmtPercent(module0.gExplicita, 2)}</td></tr>
                   <tr><td class="py-1">Crecimiento Perpetuo (gPerp):</td><td class="text-right font-semibold">${fmtPercent(module0.gPerpetuidad, 2)}</td></tr>
                   <tr><td class="py-1 text-slate-500">Valor Terminal (al final del periodo):</td><td class="text-right text-slate-500">${fmtNumber(module0.valorTerminal, 0)}</td></tr>
                   <tr class="bg-slate-100 dark:bg-slate-800/50"><td class="py-1 font-bold">VNA (Valor Presente Neto):</td><td class="text-right font-bold">${fmtNumber(module0.vnaCLP, 0)}</td></tr>
                   <tr><td class="py-1">Acciones en Circulaci√≥n:</td><td class="text-right font-semibold">${fmtNumber(datos.numeroAcciones, 0)}</td></tr>
                   <tr class="bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300"><td class="py-1 font-bold">Precio Justo Calculado:</td><td class="text-right font-bold text-base">${fmtCurrency(module0.pDCF)}</td></tr>
                </tbody>
              </table>
              <div class="mt-3 pt-3 border-t border-slate-200 dark:border-slate-700">
                <p class="text-[10px] uppercase text-slate-400 font-bold mb-1">Flujos Proyectados (FCFE):</p>
                <div class="flex flex-wrap gap-2">
                  ${module0.fcfeProyectados.map((v, i) => `<span class="bg-white dark:bg-slate-800 px-2 py-1 rounded border border-slate-200 dark:border-slate-700 text-[10px] font-mono">A√±o ${i + 1}: ${fmtNumber(v, 0)}</span>`).join('')}
                </div>
              </div>
           </div>
        </details>
      </div>
      `;

      // Renderizar gr√°fico de Time to Value si existe
      if (module0.timeToValue) {
        setTimeout(() => {
          const canvas = document.getElementById('chart-time-to-value');
          if (canvas) {
            const ttv = module0.timeToValue;
            const ctx = canvas.getContext('2d');

            // Preparar datos - Solo hasta convergencia o m√°ximo calculado
            const maxYearsToShow = ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0
              ? Math.min(ttv.yearsToCatchUp + 2, ttv.years.length) // +2 para mostrar un poco m√°s all√° del cruce
              : ttv.years.length;

            const yearsToShow = ttv.years.slice(0, maxYearsToShow);
            const valuesToShow = ttv.values.slice(0, maxYearsToShow);

            // CORRECCI√ìN: Usar a√±os calendario reales (2025, 2026...) en lugar de "A√±o 1, 2..."
            const currentYear = new Date().getFullYear();
            const labels = yearsToShow.map((y) => currentYear + y);
            const marketPriceLine = new Array(yearsToShow.length).fill(ttv.precioMercado);

            const chart = new Chart(ctx, {
              type: 'line',
              data: {
                labels,
                datasets: [
                  {
                    label: 'Precio Mercado Objetivo (Hoy)',
                    data: marketPriceLine,
                    borderColor: '#ef4444',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    borderDash: [8, 4],
                    pointRadius: 0, // Sin puntos visibles
                    fill: false,
                    tension: 0,
                    datalabels: {
                      display: function (context) {
                        // CAMBIO: Mostrar al inicio de la l√≠nea (√≠ndice 0)
                        return context.dataIndex === 0;
                      },
                      align: 'top',
                      anchor: 'start', // CAMBIO: Anclado al inicio
                      backgroundColor: 'rgba(255, 255, 255, 0.9)',
                      borderRadius: 4,
                      color: '#dc2626',
                      font: { weight: 'bold', size: 13 },
                      formatter: function (value) {
                        return '$' + new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(value);
                      },
                      padding: 6
                    }
                  },
                  {
                    label: 'Valor Intr√≠nseco Fundamental',
                    data: valuesToShow,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 3,
                    pointRadius: (context) => {
                      // CAMBIO: Punto m√°s grande en convergencia solo si yearsToCatchUp > 0
                      if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                        return 8;
                      }
                      return 5;
                    },
                    pointBackgroundColor: (context) => {
                      // CAMBIO: Color verde en convergencia solo si yearsToCatchUp > 0
                      if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                        return '#10b981';
                      }
                      return '#3b82f6';
                    },
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    fill: true,
                    tension: 0.3,
                    datalabels: {
                      display: true,
                      align: 'top',
                      anchor: 'end',
                      backgroundColor: function (context) {
                        // CAMBIO: Fondo verde en convergencia solo si yearsToCatchUp > 0
                        if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                          return 'rgba(16, 185, 129, 0.9)';
                        }
                        return 'rgba(255, 255, 255, 0.8)';
                      },
                      borderRadius: 4,
                      color: function (context) {
                        // CAMBIO: Texto blanco en convergencia solo si yearsToCatchUp > 0
                        if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                          return '#ffffff';
                        }
                        return '#1e40af';
                      },
                      font: { weight: 'bold', size: 11 },
                      formatter: function (value) {
                        return '$' + new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(value);
                      },
                      padding: 4
                    }
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                  mode: 'index',
                  intersect: false,
                },
                plugins: {
                  datalabels: {
                    display: true
                  },
                  legend: {
                    display: true,
                    position: 'top',
                    labels: {
                      color: '#64748b',
                      usePointStyle: true,
                      padding: 15,
                      font: {
                        size: 12,
                        weight: 'bold'
                      }
                    }
                  },
                  tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    padding: 12,
                    titleFont: {
                      size: 14,
                      weight: 'bold'
                    },
                    bodyFont: {
                      size: 13
                    },
                    callbacks: {
                      label: function (context) {
                        const label = context.dataset.label || '';
                        // CORRECCI√ìN: Sin decimales usando maximumFractionDigits: 0
                        const value = new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(context.parsed.y);
                        if (context.datasetIndex === 0) {
                          return label + ': $' + value + ' (Precio que pagas hoy)';
                        }
                        return label + ': $' + value;
                      },
                      afterLabel: function (context) {
                        if (context.datasetIndex === 1 && ttv.yearsToCatchUp !== null && context.dataIndex === ttv.yearsToCatchUp) {
                          return 'üéØ Punto de Convergencia';
                        }
                        return '';
                      }
                    }
                  },
                  annotation: ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 ? {
                    annotations: {
                      convergenceLine: {
                        type: 'line',
                        xMin: ttv.yearsToCatchUp,
                        xMax: ttv.yearsToCatchUp,
                        borderColor: '#10b981',
                        borderWidth: 3,
                        borderDash: [10, 5],
                        label: {
                          display: true,
                          content: 'üéØ Convergencia',
                          position: 'start',
                          backgroundColor: 'rgba(16, 185, 129, 0.9)',
                          color: '#ffffff',
                          font: {
                            weight: 'bold',
                            size: 12
                          },
                          padding: 6,
                          borderRadius: 4
                        }
                      },
                      convergencePoint: {
                        type: 'point',
                        xValue: ttv.yearsToCatchUp,
                        yValue: ttv.precioMercado,
                        backgroundColor: '#10b981',
                        borderColor: '#ffffff',
                        borderWidth: 3,
                        radius: 10
                      }
                    }
                  } : {} // No mostrar l√≠nea de convergencia si est√° subvaluada (yearsToCatchUp === 0)
                },
                scales: {
                  x: {
                    title: {
                      display: true,
                      text: 'A√±o',
                      color: '#64748b',
                      font: {
                        size: 12,
                        weight: 'bold'
                      }
                    },
                    ticks: {
                      color: '#94a3b8',
                      font: {
                        size: 11
                      }
                    },
                    grid: {
                      color: 'rgba(148, 163, 184, 0.1)',
                      drawBorder: false
                    }
                  },
                  y: {
                    title: {
                      display: true,
                      text: 'Valor (CLP)',
                      color: '#64748b',
                      font: {
                        size: 12,
                        weight: 'bold'
                      }
                    },
                    ticks: {
                      color: '#94a3b8',
                      font: {
                        size: 11
                      },
                      // CORRECCI√ìN: Sin decimales usando maximumFractionDigits: 0
                      callback: (val) => '$' + new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(val)
                    },
                    grid: {
                      color: 'rgba(148, 163, 184, 0.1)',
                      drawBorder: false
                    }
                  }
                }
              }
            });
            chartRegistry.push(chart);
          }
        }, 100);
      }
    }

    function buildRecommendation(diff) {
      if (diff >= 0.25) return 'Comprar (descuento >25%)';
      if (diff >= 0.10) return 'Comprar moderado';
      if (diff > -0.10) return 'Mantener';
      if (diff > -0.25) return 'Reducir';
      return 'Vender (sobrevalorada)';
    }

    function renderPriceProjection(module0) {
      const canvas = document.getElementById('chart-dcf');
      if (!canvas) return;
      const labels = ['Hoy'];
      const data = [module0.pDCF];
      module0.yearsProj.forEach((year, idx) => {
        labels.push(year);
        const projectedPrice = module0.pDCF * Math.pow(1 + module0.gExplicita, idx + 1);
        data.push(projectedPrice);
      });
      const ctx = canvas.getContext('2d');
      const chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Precio proyectado (CLP)',
            data,
            backgroundColor: (context) => {
              const gradient = context.chart.ctx.createLinearGradient(0, 0, 0, 300);
              gradient.addColorStop(0, '#3b82f6');
              gradient.addColorStop(1, '#22c55e');
              return gradient;
            },
            borderWidth: 0,
          }],
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            datalabels: {
              anchor: 'end',
              align: 'top',
              color: '#fff',
              formatter: (value) => fmtNumber(value, 0),
            },
          },
          scales: {
            x: { ticks: { color: '#94a3b8' } },
            y: {
              ticks: {
                color: '#94a3b8',
                callback: (val) => new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(val),
              },
            },
          },
        },
      });
      chartRegistry.push(chart);
    }

    function renderModule1(module, container) {
      if (!module) {
        container.textContent = 'No se pudo calcular el m√≥dulo 1.';
        return;
      }
      const actual = module.actual || {};
      const estructural = module.estructural || {};
      const cagr = module.cagr || {};
      const series = module.series || {};
      const formatValue = (value, formatter, decimals = 2) => {
        if (formatter === 'text') return value || 'N/A';
        if (value === null || value === undefined || Number.isNaN(value)) return 'N/A';
        if (formatter === 'percent') return fmtPercent(value, decimals);
        if (formatter === 'number') return fmtNumber(value, decimals);
        return value;
      };
      const renderRatioCard = (config) => {
        const {
          id,
          label,
          value,
          formatter = 'number',
          decimals = 2,
          className = 'bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4',
        } = config;
        const displayValue = formatValue(value, formatter, decimals);
        const chip = ratioChip(id, getRatioColorClass(id, actual, estructural, cagr), ratioLabels[id] || label, `ratio-${id}`);

        // Mapeo completo de IDs de ratios a IDs de tooltips
        const tooltipMap = {
          // Ratios Actuales (A1-A14)
          'A1': 'EPS', 'A2': 'BVPS', 'A3': 'PER', 'A4': 'P_BV',
          'A5': 'ROE', 'A6': 'ROA', 'A7': 'MARGEN_NETO', 'A8': 'MARGEN_OP',
          'A9': 'PAYOUT', 'A10': 'RETENCION', 'A11': 'LIQUIDEZ',
          'A12': 'DEUDA_PATRIMONIO', 'A13': 'COBERTURA_INTERESES', 'A14': 'DEUDA_NETA',
          // Ratios Estructurales (B1-B11)
          'B1': 'ROE', 'B2': 'ROA', 'B3': 'MARGEN_NETO', 'B4': 'MARGEN_OP',
          'B5': 'PAYOUT', 'B6': 'RETENCION',
          'B9': 'CAGR_VENTAS', 'B10': 'CAGR_BENEFICIO', 'B11': 'CAGR_PATRIMONIO'
        };
        const tooltipId = tooltipMap[id];
        const tooltipAttr = tooltipId ? `data-tooltip="${getTooltipText(tooltipId)}"` : '';

        return `
          <div id="ratio-${id}" class="${className}">
            <div class="flex flex-col gap-2 min-h-[70px]">
              <div class="flex items-center gap-2">
                <p class="text-xs uppercase text-slate-400 flex-1" ${tooltipAttr}>${label}</p>
                ${chip}
              </div>
              <p class="text-xl font-bold">${displayValue}</p>
            </div>
          </div>
        `;
      };
      const renderConclusionsList = (items = []) => {
        if (!items.length) return '<p class="text-sm text-slate-500">Sin conclusiones autom√°ticas.</p>';
        // CLEANUP: Eliminados los "chips" (badges) visuales. Solo texto limpio.
        return `<ul class="space-y-2 text-sm text-slate-700 dark:text-slate-300 list-none pl-0">
          ${items.map((item) => `<li class="leading-relaxed text-left">${item.text}</li>`).join('')}
        </ul>`;
      };

      const actualMainRatios = [
        { id: 'A1', label: 'EPS (CLP)', value: actual.epsCLP, formatter: 'number', decimals: 0 },
        { id: 'A2', label: 'BVPS (CLP)', value: actual.bvpsCLP, formatter: 'number', decimals: 0 },
        { id: 'A3', label: 'PER actual', value: actual.perReal, formatter: 'number', decimals: 1 },
        { id: 'A4', label: 'P/BV actual', value: actual.pbvReal, formatter: 'number', decimals: 2 },
        { id: 'A5', label: 'ROE √∫ltimo a√±o', value: actual.roeUltimo, formatter: 'percent' },
        { id: 'A6', label: 'ROA √∫ltimo a√±o', value: actual.roaUltimo, formatter: 'percent' },
        { id: 'A7', label: 'Margen neto √∫ltimo', value: actual.margenNetoUltimo, formatter: 'percent' },
        { id: 'A8', label: 'Margen operacional √∫ltimo', value: actual.margenOperacionalUltimo, formatter: 'percent' },
        { id: 'A9', label: 'Payout √∫ltimo a√±o', value: actual.payoutUltimo, formatter: 'percent' },
        { id: 'A10', label: 'Retenci√≥n √∫ltima', value: actual.retencionUltimo, formatter: 'percent' },
      ];

      const financialRatios = [
        { id: 'A11', label: 'Liquidez corriente', value: actual.liquidezCorriente, formatter: 'number', decimals: 2, className: 'bg-slate-100 dark:bg-slate-900/40 rounded-xl p-4' },
        { id: 'A12', label: 'Deuda neta / Patrimonio', value: actual.deudaNetaSobrePatrimonio, formatter: 'number', decimals: 2, className: 'bg-slate-100 dark:bg-slate-900/40 rounded-xl p-4' },
        { id: 'A13', label: 'Cobertura intereses', value: actual.coberturaIntereses, formatter: 'number', decimals: 2, className: 'bg-slate-100 dark:bg-slate-900/40 rounded-xl p-4' },
        { id: 'A14', label: 'Deuda neta (moneda base)', value: actual.deudaNetaBase, formatter: 'number', decimals: 0, className: 'bg-slate-100 dark:bg-slate-900/40 rounded-xl p-4' },
      ];

      const estructuralRatios = [
        { id: 'B1', label: 'ROE promedio normalizado', value: estructural.roePromedioNormalizado, formatter: 'percent' },
        { id: 'B2', label: 'ROA promedio normalizado', value: estructural.roaPromedioNormalizado, formatter: 'percent' },
        { id: 'B3', label: 'Margen neto promedio', value: estructural.margenNetoPromedioNormalizado, formatter: 'percent' },
        { id: 'B4', label: 'Margen operacional promedio', value: estructural.margenOperacionalPromedioNormalizado, formatter: 'percent' },
        { id: 'B5', label: 'Payout promedio', value: estructural.payoutPromedioNormalizado, formatter: 'percent' },
        { id: 'B6', label: 'Retenci√≥n promedio', value: estructural.retencionPromedioNormalizado, formatter: 'percent' },
        { id: 'B7', label: 'Volatilidad ROE', value: estructural.volatilidadROE, formatter: 'percent' },
        { id: 'B8', label: 'Consistencia ROE', value: estructural.consistenciaROE || 'No concluyente', formatter: 'text' },
      ];

      // Check for specific Net Income CAGR failure due to negative last year
      let cagrBeneficioVal = cagr.beneficio;
      let cagrBeneficioFmt = 'percent';

      if (cagrBeneficioVal === null || cagrBeneficioVal === undefined) {
        // If null, check if it's because of negative last year
        // We can check the last value of the benefit series
        const benefValues = Object.values(series.beneficio || {});
        if (benefValues.length > 0) {
          const lastBenef = benefValues[benefValues.length - 1];
          if (lastBenef < 0) {
            cagrBeneficioVal = 'no valido por a√±o neg';
            cagrBeneficioFmt = 'text'; // Use 'text' formatter to print string as-is
          }
        }
      }

      const growthRatios = [
        { id: 'B9', label: 'Ventas (CAGR 5A)', value: cagr.ventas, formatter: 'percent' },
        { id: 'B10', label: 'Beneficio neto (CAGR 5A)', value: cagrBeneficioVal, formatter: cagrBeneficioFmt },
        { id: 'B11', label: 'Patrimonio (CAGR 5A)', value: cagr.patrimonio, formatter: 'percent' },
      ];

      // UI CLEANUP START
      // MOD1V2 UI - Calcular y preparar datos para subm√≥dulos 1.1-1.7
      let mod1v2Html = '';
      let mod1v2Computed = null;
      try {
        if (financialData && module.yearBase) {
          const dataset = buildMod1Dataset(financialData);
          const anomalies = detectAnomaliesMod1V2(dataset.lastYear);
          const snapshotStatus = getSnapshotStatus(anomalies);
          const investigations = suggestInvestigationsMod1V2(anomalies, dataset.lastYear);
          const recurrence = analyzeRecurrence(dataset.history);
          const diagnosis = diagnoseBusinessState(dataset.lastYear, anomalies, recurrence);
          const decision = methodologyDecision(diagnosis, anomalies, recurrence);
          const conclusion = buildMod1Conclusion(snapshotStatus, diagnosis, decision);

          mod1v2Computed = {
            snapshotStatus,
            anomalies,
            investigations,
            recurrence,
            diagnosis,
            decision,
            conclusion,
          };

          mod1v2Html = `
            <section class="mb-6">
              <div class="mb-4">
                <h3 class="text-lg font-semibold">1.1 ANALISIS DE DIAGNOSTICO SITUACION ACTUAL (INTEGRAL)</h3>
                <p class="text-sm text-slate-500">Flujo de an√°lisis: Foto integral (√öltimo a√±o + Anomal√≠as + Recurrencia) ‚Üí Diagn√≥stico ‚Üí Decisi√≥n metodol√≥gica ‚Üí Conclusi√≥n</p>
                
                <h3 class="text-md font-semibold mt-4 mb-2">1.2 DIAGNOSTICO DEL ESTADO</h3>
              </div>
              
              <div class="space-y-4">
                <!-- Fusi√≥n 1: 1.1A + 1.2A + 1.4A -->
                <div class="bg-slate-100 dark:bg-slate-900/50 rounded-xl p-4">
                  <!-- Subtitulo 1.1A Eliminado -->
                  <div id="mod1v2-merged-initial"></div>
                </div>

                <!-- 1.6A Decisi√≥n metodol√≥gica fusionada en Conclusi√≥n (1.7A) -->
                
                <!-- Subm√≥dulo 1.7A - Conclusi√≥n DESTACADA -->
                <!-- Estilos aplicados: Fondo contraste, Borde izquierdo grueso oro, Sombra, Padding -->
                <div class="bg-white dark:bg-slate-800 rounded-r-xl border-l-[6px] border-amber-500 shadow-md p-6">
                  <!-- Header 1.3A Eliminado -->
                  <div id="mod1v2-conclusion"></div>
                </div>
              </div>
            </section>
          `;
        }
      } catch (err) {
        console.warn('Error en MOD1V2:', err);
        mod1v2Html = '';
      }

      container.innerHTML = `
        <div class="space-y-6">
          ${mod1v2Html}
          <section class="break-before-page">
            <div class="mb-4">
            <div class="mb-4">
              <h3 class="text-lg font-semibold">1.3 MEDICION DE LA CALIDAD DEL NEGOCIO EN EL TIEMPO</h3>
              <p class="text-sm text-slate-500">Indicadores calculados sobre m√∫ltiples a√±os para evaluar sostenibilidad. Promedios excluyen a√±os negativos por ser m√©tricas sensibles.</p>
            </div>
            <div class="grid sm:grid-cols-2 xl:grid-cols-4 gap-4">
              ${estructuralRatios.map((ratio) => renderRatioCard(ratio)).join('')}
            </div>
            <div class="mt-5 bg-slate-50 dark:bg-slate-900/40 rounded-xl p-4">
              <p class="text-sm font-semibold">Crecimiento hist√≥rico</p>
              <div class="grid sm:grid-cols-3 gap-3 mt-3">
                ${growthRatios.map((ratio) => renderRatioCard({ ...ratio, className: 'bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4' })).join('')}
              </div>
            </div>
            <!-- List Removed as per request -->
            ${mod1v2Computed ? (() => {
          const qualityConclusion = generateQualityConclusion(
            estructural.roePromedioNormalizado || 0,
            cagr.ventas || 0,
            estructural.margenOperacionalPromedioNormalizado || 0,
            mod1v2Computed.diagnosis,
            estructural.roaPromedioNormalizado || 0,
            estructural.margenNetoPromedioNormalizado || 0,
            estructural.payoutPromedioNormalizado || 0,
            estructural.retencionPromedioNormalizado || 0,
            estructural.volatilidadROE || 0,
            estructural.consistenciaROE || 'No concluyente',
            cagr.patrimonio || 0
          );
          const qualityColorClass = qualityConclusion.type === 'excellent' ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 text-purple-900 dark:text-purple-100' :
            qualityConclusion.type === 'good' ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100' :
              qualityConclusion.type === 'bad' ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100' :
                'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100';
          return `<div class="mt-5 border-2 ${qualityColorClass} rounded-xl p-5">
                <p class="text-xs uppercase text-slate-500 dark:text-slate-400 font-semibold mb-3">üìä Conclusi√≥n de Calidad Estructural</p>
                ${qualityConclusion.message}
              </div>`;
        })() : ''}
          </section>
        </div>
      `;

      // Renderizar MOD1V2 despu√©s de que el DOM est√© listo
      if (mod1v2Computed && financialData) {
        try {
          const dataset = buildMod1Dataset(financialData);
          renderMod1V2(container, dataset, mod1v2Computed);
        } catch (err) {
          console.warn('Error renderizando MOD1V2:', err);
        }
      }
      // UI CLEANUP END
      attachChipScrollHandler(container);
    }

    function generatePERvsPBVConclusion(perActual, pbvActual, perPromedio, pbvPromedio, fcfeYield, evFcfe, capexRatio, debtPaydownRatio, roe = null, ebitLastYear = 0, netIncomeLastYear = 0) {
      // 1. DEFINICI√ìN DE VALORES POR DEFECTO (Safety First)
      let conclusion = {
        title: "Datos Insuficientes",
        message: "No hay informaci√≥n suficiente para generar una conclusi√≥n de valoraci√≥n.",
        type: "neutral",
        icon: "‚ö™"
      };

      // 2. DETECCI√ìN DE BLOQUEO OPERATIVO (El "Kill Switch")
      if (ebitLastYear !== null && ebitLastYear < 0) {
        return {
          title: "‚õî Valoraci√≥n No Concluyente (D√©ficit Operativo)",
          message: "Los m√©todos de valoraci√≥n por m√∫ltiplos (PER, EV/EBIT) **no son aplicables** porque la empresa pierde dinero a nivel operativo (EBIT negativo). No existe una base de ganancias sobre la cual aplicar un m√∫ltiplo. La acci√≥n no se puede clasificar como 'barata' o 'cara' bajo estos criterios est√°ndar; es una situaci√≥n de **alto riesgo o reestructuraci√≥n**.",
          type: "bad",
          icon: "‚õî"
        };
      }

      if (netIncomeLastYear !== null && netIncomeLastYear < 0) {
        return {
          title: "‚ö†Ô∏è Valoraci√≥n por Recuperaci√≥n (P√©rdidas Netas)",
          message: "La empresa tiene Utilidad Neta negativa, lo que hace matem√°ticamente imposible usar el ratio PER actual (ser√≠a negativo). La valoraci√≥n actual depende enteramente de la expectativa de que la empresa **vuelva a ser rentable**. Cualquier precio que se pague hoy es una opci√≥n sobre la recuperaci√≥n futura, no sobre la realidad actual.",
          type: "warning",
          icon: "‚ö†Ô∏è"
        };
      }

      // 3. L√ìGICA EST√ÅNDAR
      let perVigente = perActual;
      let pbvVigente = pbvActual;
      let usingAverages = false;

      // Fallback si no hay PER actual v√°lido
      if (!Number.isFinite(perActual) || perActual <= 0) {
        return conclusion;
      }

      // --- NARRATIVA EST√ÅNDAR ---
      let narrativeParts = [];
      let conclusionType = 'neutral';
      let conclusionIcon = 'üìä';

      let parrafo1 = [];
      let tieneDescuentoPER = false;
      let tieneDescuentoPBV = false;

      // An√°lisis PER
      if (Number.isFinite(perPromedio) && perPromedio > 0) {
        const perDiffPct = ((perVigente / perPromedio) - 1) * 100;
        const perDiffAbs = Math.abs(perDiffPct);

        if (perDiffPct >= -5 && perDiffPct <= 5) {
          parrafo1.push(`La valoraci√≥n actual (PER <strong>${fmtNumber(perVigente, 1)}x</strong>) est√° <strong>en l√≠nea</strong> con su promedio hist√≥rico (${fmtNumber(perPromedio, 1)}x).`);
        } else if (perDiffPct < -5) {
          tieneDescuentoPER = true;
          parrafo1.push(`La valoraci√≥n actual por utilidades (PER <strong>${fmtNumber(perVigente, 1)}x</strong>) resulta <strong>atractiva</strong> frente a su historia (${fmtNumber(perPromedio, 1)}x), con un <strong>descuento del ${perDiffAbs.toFixed(0)}%</strong>.`);
          conclusionType = perDiffPct < -20 ? 'excellent' : 'good';
          conclusionIcon = perDiffPct < -20 ? 'üí∞' : '‚úÖ';
        } else {
          parrafo1.push(`Cotiza con una <strong>prima del ${perDiffAbs.toFixed(0)}%</strong> respecto a su promedio hist√≥rico.`);
          if (perDiffPct > 30) {
            conclusionType = 'warning';
            conclusionIcon = '‚ö†Ô∏è';
          }
        }
      }

      // An√°lisis P/BV
      if (Number.isFinite(pbvVigente) && pbvVigente > 0 && Number.isFinite(pbvPromedio) && pbvPromedio > 0) {
        const pbvDiffPct = ((pbvVigente / pbvPromedio) - 1) * 100;
        if (pbvDiffPct < -10) tieneDescuentoPBV = true;
      }

      if (tieneDescuentoPER && tieneDescuentoPBV) {
        parrafo1.push(`<strong>Doble indicio de subvaluaci√≥n relativa.</strong>`);
        if (conclusionType !== 'warning') {
          conclusionType = 'excellent';
          conclusionIcon = 'üíé';
        }
      }

      if (parrafo1.length > 0) narrativeParts.push(parrafo1.join(' '));

      // 4. Reality Check (FCFE)
      if (fcfeYield !== null) {
        if (fcfeYield > 0.08) {
          narrativeParts.push(`Adem√°s, ofrece un robusto <strong>FCFE Yield del ${fmtPercent(fcfeYield)}</strong>, lo que respalda la valoraci√≥n con caja real.`);
        } else if (fcfeYield < 0.02 && fcfeYield > 0) {
          narrativeParts.push(`Sin embargo, el FCFE Yield es bajo (${fmtPercent(fcfeYield)}), lo que deja poco margen de error.`);
          if (conclusionType === 'good' || conclusionType === 'excellent') {
            conclusionType = 'warning';
            conclusionIcon = '‚ö†Ô∏è';
          }
        }
      }

      // 5. Destino de Capital
      let parrafo3 = "";
      if (capexRatio > 1.5) {
        parrafo3 = `Nota: La empresa est√° invirtiendo agresivamente (Capex > 1.5x Beneficio), lo que deprime el flujo de caja hoy para crecer ma√±ana.`;
      } else if (debtPaydownRatio > 0.5) {
        parrafo3 = `Nota: Prioriza desapalancamiento (destina >50% de utilidad a pagar deuda), fortaleciendo el balance a costa de flujo al accionista.`;
      }
      if (parrafo3) narrativeParts.push(parrafo3);

      // Final Assembly
      if (narrativeParts.length > 0) {
        conclusion.message = narrativeParts.join('<br><br>');
        conclusion.title = conclusionType === 'excellent' ? "üíé Oportunidad de Valor Convicci√≥n Alta" :
          conclusionType === 'good' ? "‚úÖ Valoraci√≥n Atractiva" :
            conclusionType === 'warning' ? "‚ö†Ô∏è Valoraci√≥n Exigente" :
              "‚öñÔ∏è Valoraci√≥n Est√°ndar";
        conclusion.type = conclusionType;
        conclusion.icon = conclusionIcon;
      }

      // Attach legacy keys for UI compatibility if needed
      conclusion.usingAverages = usingAverages;
      conclusion.perUsed = perVigente;
      conclusion.pbvUsed = pbvVigente;

      return conclusion;
    }

    function renderModule2(module, container) {
      if (!module) {
        container.textContent = 'No se pudo calcular el m√≥dulo 2.';
        return;
      }

      const years = module.years;

      // Obtener ROE desde module1 si est√° disponible
      const roe = window.moduleResults?.module1?.roe || null;

      // Usar conclusi√≥n pre-calculada o generar con ROE
      const conclusion = module.recomendacionTexto || generatePERvsPBVConclusion(
        module.perActual,
        module.pbvActual,
        module.perPromedio,
        module.pbvPromedio,
        module.fcfeYield,
        module.evSobreFCFE,
        module.debugEV?.capexRatio || 0,
        module.debugEV?.debtPaydownRatio || 0,
        roe
      );

      // Determinar clases de color seg√∫n el tipo de conclusi√≥n
      const conclusionColorClasses = {
        good: 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100',
        growth: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800 text-blue-900 dark:text-blue-100',
        warning: 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100',
        excellent: 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 text-purple-900 dark:text-purple-100',
        neutral: 'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100'
      };

      // Calcular diferencias porcentuales para KPIs
      const perDiff = module.perPromedio > 0 ? ((module.perActual - module.perPromedio) / module.perPromedio) * 100 : 0;
      const pbvDiff = module.pbvPromedio > 0 ? ((module.pbvActual - module.pbvPromedio) / module.pbvPromedio) * 100 : 0;

      const perDiffColor = perDiff < 0 ? 'text-emerald-600 dark:text-emerald-400' : 'text-red-600 dark:text-red-400';
      const pbvDiffColor = pbvDiff < 0 ? 'text-emerald-600 dark:text-emerald-400' : 'text-red-600 dark:text-red-400';

      const perDiffIcon = perDiff < 0 ? '‚Üì' : '‚Üë';
      const pbvDiffIcon = pbvDiff < 0 ? '‚Üì' : '‚Üë';

      container.innerHTML = `
        <div class="space-y-6">
          <!-- M√©tricas Financieras (Ancho Completo) -->
          <div class="w-full">
            <h4 class="text-xs uppercase text-slate-400 font-semibold mb-3">M√©tricas Financieras (√∫ltimo a√±o)</h4>
            <div class="bg-slate-100 dark:bg-slate-900/60 rounded-xl p-5 border border-slate-200 dark:border-slate-700">
              <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 text-sm">
                <!-- Estructura de Valor -->
                <div class="text-center">
                  <span class="block text-xs text-slate-500 dark:text-slate-400 mb-1 cursor-help" title="${moduleFormulas.mult_market_cap}">Market Cap</span>
                  <span class="block font-bold text-base">${fmtNumber(module.marketCapUSD, 2)}</span>
                  <span class="block text-xs text-slate-400">USD</span>
                </div>
                <div class="text-center">
                  <span class="block text-xs text-slate-500 dark:text-slate-400 mb-1">Deuda Neta</span>
                  <span class="block font-bold text-base">${fmtNumber(module.deudaNetaUSD, 2)}</span>
                  <span class="block text-xs text-slate-400">USD</span>
                </div>
                <div class="text-center">
                  <span class="block text-xs text-slate-500 dark:text-slate-400 mb-1 cursor-help" title="${moduleFormulas.mult_ev}">EV (Enterprise)</span>
                  <span class="block font-bold text-base">${fmtNumber(module.evUSD, 2)}</span>
                  <span class="block text-xs text-slate-400">USD</span>
                </div>
                
                <!-- Separador vertical (oculto en m√≥vil) -->
                <div class="hidden lg:block border-l border-slate-300 dark:border-slate-600"></div>
                
                <!-- Flujo de Caja -->
                <div class="text-center">
                  <span class="block text-xs text-slate-500 dark:text-slate-400 mb-1">FCFE √öltimo A√±o</span>
                  <span class="block font-bold text-base">${fmtNumber(module.fcfeUltimoUSD, 2)}</span>
                  <span class="block text-xs text-slate-400">USD</span>
                </div>
                <div class="text-center">
                  <span class="block text-xs text-slate-500 dark:text-slate-400 mb-1 cursor-help" title="${moduleFormulas.mult_ev_fcfe}">EV / FCFE</span>
                  <span class="block font-bold text-xl text-blue-600 dark:text-blue-400">${fmtNumber(module.evSobreFCFE, 2)}</span>
                  <span class="block text-xs text-slate-400">Ratio</span>
                </div>
              </div>
            </div>
          </div>

          <!-- KPI Cards: PER y P/BV lado a lado -->
          <div class="grid lg:grid-cols-2 gap-6">
            <!-- KPI Card: PER -->
            <div class="bg-gradient-to-br from-blue-50 to-white dark:from-blue-900/20 dark:to-slate-800 rounded-xl p-5 border-2 border-blue-200 dark:border-blue-800 shadow-md">
              <div class="flex items-start justify-between mb-3">
                <div>
                  <p class="text-xs uppercase text-slate-500 dark:text-slate-400 font-semibold mb-1">
                    ${module.perLabel || 'PER (NORMALIZADO ULTIMO A√ëO)'}
                  </p>
                  <p class="text-3xl font-black ${module.perType === 'normalizado' ? 'text-purple-700 dark:text-purple-300' : 'text-blue-700 dark:text-blue-300'}" title="${module.perType === 'normalizado' ? 'PER calculado usando utilidad promedio hist√≥rica debido a p√©rdidas actuales' : ''}">
                    ${module.perActual !== null && Number.isFinite(module.perActual) ? fmtNumber(module.perActual, 1) + 'x' : 'N/A'}${module.perType === 'normalizado' ? '*' : ''}
                  </p>
                </div>
                <div class="text-right">
                  <p class="text-xs text-slate-500 dark:text-slate-400">vs Promedio 5A</p>
                  <p class="text-lg font-bold text-slate-600 dark:text-slate-300">${fmtNumber(module.perPromedio, 1)}x</p>
                </div>
              </div>
              <div class="flex items-center gap-2 pt-3 border-t border-blue-200 dark:border-blue-700">
                <span class="${perDiffColor} text-2xl font-bold">${perDiffIcon}</span>
                <span class="${perDiffColor} text-sm font-bold">
                  ${Math.abs(perDiff).toFixed(0)}% ${perDiff < 0 ? 'Descuento' : 'Prima'}
                </span>
              </div>
              ${module.perType === 'normalizado' && module.epsNormalizado ? `
                <div class="mt-3 pt-3 border-t border-purple-200 dark:border-purple-700">
                  <p class="text-xs text-purple-700 dark:text-purple-300 italic">
                    * Calculado sobre EPS promedio hist√≥rico (${fmtCurrency(module.epsNormalizado)}) debido a p√©rdidas actuales
                  </p>
                </div>
              ` : ''}
            </div>

            <!-- KPI Card: P/BV -->
            <div class="bg-gradient-to-br from-purple-50 to-white dark:from-purple-900/20 dark:to-slate-800 rounded-xl p-5 border-2 border-purple-200 dark:border-purple-800 shadow-md">
              <div class="flex items-start justify-between mb-3">
                <div>
                  <p class="text-xs uppercase text-slate-500 dark:text-slate-400 font-semibold mb-1">P/BV ULTIMO A√ëO (Price/Book Value)</p>
                  <p class="text-3xl font-black text-purple-700 dark:text-purple-300">${fmtNumber(module.pbvActual, 2)}x</p>
                </div>
                <div class="text-right">
                  <p class="text-xs text-slate-500 dark:text-slate-400">vs Promedio 5A</p>
                  <p class="text-lg font-bold text-slate-600 dark:text-slate-300">${fmtNumber(module.pbvPromedio, 2)}x</p>
                </div>
              </div>
              <div class="flex items-center gap-2 pt-3 border-t border-purple-200 dark:border-purple-700">
                <span class="${pbvDiffColor} text-2xl font-bold">${pbvDiffIcon}</span>
                <span class="${pbvDiffColor} text-sm font-bold">
                  ${Math.abs(pbvDiff).toFixed(0)}% ${pbvDiff < 0 ? 'Descuento' : 'Prima'}
                </span>
              </div>
            </div>
          </div>

          <!-- Gr√°fico de Evoluci√≥n Hist√≥rica (Ancho Completo) -->
          <div class="w-full">
            <h4 class="text-xs uppercase text-slate-400 font-semibold mb-3">Evoluci√≥n hist√≥rica de m√∫ltiplos</h4>
            <div class="bg-slate-50 dark:bg-slate-900/30 rounded-xl p-4">
              <canvas id="chart-module2" class="w-full" style="height: 300px;"></canvas>
            </div>
          </div>

          <!-- Conclusi√≥n Integrada (Ancho Completo) -->
          <div class="w-full border-2 ${conclusionColorClasses[conclusion.type]} rounded-xl p-5">
            <div class="flex items-start gap-4">
              <div class="text-4xl flex-shrink-0">${conclusion.icon}</div>
              <div class="flex-1">
                <h4 class="text-sm font-bold uppercase mb-3">An√°lisis de Valoraci√≥n por M√∫ltiplos</h4>
                <div class="text-base leading-relaxed">${conclusion.message}</div>
                ${conclusion.usingAverages ? `
                  <p class="text-xs mt-3 opacity-75 italic">
                    ‚ö†Ô∏è Nota: Usando promedios hist√≥ricos debido a datos negativos en el √∫ltimo a√±o.
                  </p>
                ` : ''}
              </div>
            </div>
          </div>

          <!-- Auditor√≠a de C√°lculo (Debug Output) -->
          <details class="w-full pt-4 mt-2 border-t border-slate-200 dark:border-slate-800 group">
            <summary class="cursor-pointer text-xs font-bold text-slate-400 hover:text-slate-600 dark:hover:text-slate-300 transition-colors list-none flex items-center gap-2 select-none">
                <span class="transform group-open:rotate-90 transition-transform">‚ñ∂</span>
                üîç Auditor√≠a de C√°lculo (Debug Output)
            </summary>
            <div class="mt-3 overflow-x-auto bg-white dark:bg-slate-800 rounded-lg p-3 border border-slate-200 dark:border-slate-700 shadow-sm">
                <table class="w-full text-xs text-left border-collapse">
                    <thead>
                        <tr class="border-b border-slate-200 dark:border-slate-700 text-slate-500 uppercase tracking-wider">
                            <th class="p-2 font-semibold">A√±o</th>
                            <th class="p-2 font-semibold">Precio (CLP)</th>
                            <th class="p-2 font-semibold">EPS (Raw)</th>
                            <th class="p-2 font-semibold">TC</th>
                            <th class="p-2 font-semibold">EPS Final (CLP)</th>
                            <th class="p-2 font-semibold">PER Calc</th>
                            <th class="p-2 font-semibold">Estado (Trimmed Mean)</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-slate-100 dark:divide-slate-700/50">
                      ${module.debugRows ? module.debugRows.map((row, idx) => `
                        <tr class="hover:bg-slate-50 dark:hover:bg-slate-700/30 transition-colors ${row.isExcluded ? 'opacity-60 grayscale' : 'font-medium'}">
                            <td class="p-2 text-slate-600 dark:text-slate-300">${row.year}</td>
                            <td class="p-2 text-slate-500 font-mono">${fmtCurrency(row.price)}</td>
                            <td class="p-2 text-slate-500 font-mono">${fmtNumber(row.epsRaw, 2)} <span class="text-[10px] text-slate-400">${row.epsCurrency}</span></td>
                            <td class="p-2 text-slate-500 font-mono">${fmtNumber(row.tcUsed, 2)}</td>
                            <td class="p-2 text-slate-600 dark:text-slate-300 font-mono">${fmtCurrency(row.epsFinalCLP)}</td>
                            <td class="p-2 font-bold font-mono text-blue-600 dark:text-blue-400">${row.perCalc ? fmtNumber(row.perCalc, 1) + 'x' : '-'}</td>
                            <td class="p-2">
                              <span class="px-2 py-0.5 rounded-full text-[10px] border ${row.isExcluded
          ? 'bg-slate-100 text-slate-500 border-slate-200 dark:bg-slate-800 dark:text-slate-400 dark:border-slate-600'
          : 'bg-emerald-50 text-emerald-700 border-emerald-200 dark:bg-emerald-900/20 dark:text-emerald-400 dark:border-emerald-800'
        }">
                                ${row.exclusionReason || 'Incluido'}
                              </span>
                            </td>
                        </tr>
                      `).join('') : '<tr><td colspan="7" class="p-4 text-center text-slate-400">Sin datos de auditor√≠a disponibles</td></tr>'}
                    </tbody>
                </table>
                <div class="mt-3 text-[10px] text-slate-500 dark:text-slate-400 flex items-start gap-2 bg-slate-50 dark:bg-slate-900/50 p-2 rounded">
                  <span>‚ÑπÔ∏è</span>
                  <span><strong>Nota sobre Filtrado:</strong> El c√°lculo "Trimmed Mean" elimina autom√°ticamente el valor m√≠nimo y m√°ximo de la muestra de 5 a√±os para evitar que eventos at√≠picos (como crisis o beneficios extraordinarios) distorsionen la valoraci√≥n promedio hist√≥rica.</span>
                </div>
            </div>
          </details>
        </div>
      `;

      const ctx = document.getElementById('chart-module2').getContext('2d');
      const isDarkTheme = document.documentElement.classList.contains('dark');
      const axisColor = isDarkTheme ? '#ffffff' : '#94a3b8';
      const dataLabelColor = isDarkTheme ? '#ffffff' : '#1e293b';

      // Crear gradientes para fill
      const perGradient = ctx.createLinearGradient(0, 0, 0, 300);
      perGradient.addColorStop(0, 'rgba(59, 130, 246, 0.3)');
      perGradient.addColorStop(1, 'rgba(59, 130, 246, 0.0)');

      const evFcfeGradient = ctx.createLinearGradient(0, 0, 0, 300);
      evFcfeGradient.addColorStop(0, 'rgba(139, 92, 246, 0.3)');
      evFcfeGradient.addColorStop(1, 'rgba(139, 92, 246, 0.0)');

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: years,
          datasets: [
            {
              label: 'PER',
              data: years.map((year) => module.perPorAnio[year]),
              borderColor: '#3b82f6',
              backgroundColor: perGradient,
              tension: 0.4,
              fill: true,
              borderWidth: 3,
              pointRadius: 5,
              pointHoverRadius: 7,
              datalabels: {
                align: 'top',
                anchor: 'end',
                offset: 4,
                color: dataLabelColor,
                font: { weight: 'bold', size: 11 },
                formatter: (value) => (value === null || value === undefined ? '' : Number(value).toFixed(1) + 'x'),
              },
            },
            {
              label: 'P/BV',
              data: years.map((year) => module.pbvPorAnio[year]),
              borderColor: '#f97316',
              backgroundColor: 'transparent',
              tension: 0.4,
              fill: false,
              borderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6,
              datalabels: {
                align: 'bottom',
                anchor: 'start',
                offset: 4,
                color: dataLabelColor,
                font: { weight: 'bold', size: 10 },
                formatter: (value) => (value === null || value === undefined ? '' : Number(value).toFixed(2) + 'x'),
              },
            },
            {
              label: 'EV/FCFE',
              data: years.map((year) => module.evFcfePorAnio[year]),
              borderColor: '#8b5cf6',
              backgroundColor: evFcfeGradient,
              tension: 0.4,
              fill: true,
              borderWidth: 3,
              pointRadius: 5,
              pointHoverRadius: 7,
              borderDash: [5, 5],
              datalabels: {
                align: 'top',
                anchor: 'start',
                offset: 4,
                color: dataLabelColor,
                font: { weight: 'bold', size: 11 },
                formatter: (value) => (value === null || value === undefined ? '' : Number(value).toFixed(1) + 'x'),
              },
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: dataLabelColor,
                font: { size: 12, weight: 'bold' },
                padding: 15,
                usePointStyle: true,
              }
            },
            datalabels: {
              display: true,
            },
            annotation: {
              annotations: {
                perPromedioLine: {
                  type: 'line',
                  yMin: module.perPromedio,
                  yMax: module.perPromedio,
                  borderColor: isDarkTheme ? 'rgba(148, 163, 184, 0.6)' : 'rgba(100, 116, 139, 0.6)',
                  borderWidth: 2,
                  borderDash: [10, 5],
                  label: {
                    display: true,
                    content: `Promedio PER: ${fmtNumber(module.perPromedio, 1)}x`,
                    position: 'start',
                    backgroundColor: isDarkTheme ? 'rgba(51, 65, 85, 0.9)' : 'rgba(226, 232, 240, 0.9)',
                    color: dataLabelColor,
                    font: { size: 11, weight: 'bold' },
                    padding: 6,
                    borderRadius: 4,
                    xAdjust: 10,
                    yAdjust: 0,
                  }
                }
              }
            }
          },
          scales: {
            x: {
              ticks: { color: axisColor, font: { size: 11, weight: 'bold' } },
              grid: { color: isDarkTheme ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)' }
            },
            y: {
              ticks: { color: axisColor, font: { size: 11 } },
              grid: { color: isDarkTheme ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.05)' },
              beginAtZero: false,
            },
          },
        },
      });
      chartRegistry.push(chart);
    }


    // ============================================
    // MODULE 9 YIELD - RENDER FUNCTION
    // ============================================

    function renderModule9Yield(data, container) {
      if (!container) return;

      if (!data || !data.company || !data.benchmarks) {
        container.innerHTML = '<div class="p-4 bg-slate-100 text-slate-500 rounded text-center text-xs">Simulador no disponible.</div>';
        return;
      }

      try {
        const { company, benchmarks } = data;
        const growthRate = data.gUsed || 0;

        const rnd = Math.floor(Math.random() * 10000);
        const chartLineId = `chart_yield_line_${rnd}`;
        const inputId = `invest_input_${rnd}`;
        const displayId = `invest_display_${rnd}`;
        const resultsId = `results_container_${rnd}`;
        const wrapperId = `wrapper_${rnd}`;

        const html = `
            <div id="${wrapperId}" class="space-y-6">
                <div class="bg-white dark:bg-slate-800 p-5 rounded-xl border border-blue-100 dark:border-blue-900 shadow-sm">
                    <div class="flex flex-col sm:flex-row items-center justify-between gap-6">
                        <div class="flex items-center gap-4 w-full sm:w-auto">
                            <div>
                                <label class="block text-[10px] font-bold text-blue-500 uppercase tracking-wider mb-1">Monto a Invertir</label>
                                <div class="flex items-center gap-3">
                                    <input type="number" id="${inputId}" value="1000000" step="100000" min="0" 
                                        class="text-xl font-bold text-slate-500 bg-slate-50 dark:bg-slate-900/50 outline-none border border-slate-200 rounded px-2 py-1 w-32 font-mono focus:border-blue-500 transition-all">
                                    <span id="${displayId}" class="text-2xl font-black text-slate-800 dark:text-white tracking-tight font-mono">$ 1.000.000</span>
                                </div>
                            </div>
                        </div>
                        <div class="text-right bg-slate-50 dark:bg-slate-700/50 px-3 py-2 rounded-lg border border-slate-100 dark:border-slate-600">
                             <p class="text-[10px] uppercase text-slate-400 font-bold mb-1">Tasa Crecimiento (g)</p>
                             <p class="text-lg font-mono font-bold text-blue-600 dark:text-blue-400">${fmtPercent(growthRate)}</p>
                        </div>
                    </div>
                </div>

                <div class="grid lg:grid-cols-3 gap-6">
                    <div class="lg:col-span-2 flex flex-col items-stretch space-y-4">
                        <div class="flex justify-between items-center">
                            <h4 class="font-bold text-slate-500 uppercase text-xs"><span>üìà</span> Evoluci√≥n Rentabilidad vs Acumulada (Dual Update)</h4>
                            <div class="flex gap-3 text-[10px] font-bold uppercase">
                                <span class="text-blue-500">‚îÄ Yield Anual (%)</span>
                                <span class="text-blue-500 opacity-50">--- Acumulado ($)</span>
                            </div>
                        </div>
                        <div class="relative w-full flex-1 min-h-[300px] bg-slate-50 dark:bg-slate-900/30 rounded-xl border border-slate-100 dark:border-slate-800 p-2">
                             <canvas id="${chartLineId}"></canvas>
                        </div>
                    </div>
                    <div class="lg:col-span-1 bg-slate-50 dark:bg-slate-900/30 p-0 rounded-xl border border-slate-200 dark:border-slate-700 overflow-hidden flex flex-col h-full">
                        <div class="p-3 border-b border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800">
                            <h4 class="font-bold text-slate-500 uppercase text-xs"><span>üí∞</span> Comparativo de Flujos ($)</h4>
                        </div>
                        <div id="${resultsId}" class="flex-1 overflow-y-auto p-2 h-[300px]"></div>
                    </div>
                </div>
            </div>
        `;
        container.innerHTML = html;

        // --- L√ìGICA DE C√ÅLCULO ---
        const initModule = () => {
          const inputEl = document.getElementById(inputId);
          const displayEl = document.getElementById(displayId);
          const resultsEl = document.getElementById(resultsId);
          const ctxLine = document.getElementById(chartLineId);

          if (!inputEl || !resultsEl || !ctxLine) return;
          if (Chart.getChart(ctxLine)) return;

          const rateFixed = benchmarks.dap; // Tasa Fija (DAP)
          const rateStock = company.fcfeYield; // Yield Inicial Acci√≥n

          // 1. Configurar Gr√°fico (Dual Axis)
          const chart = new Chart(ctxLine, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
              responsive: true, maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              layout: { padding: { top: 20, right: 20, left: 0, bottom: 0 } },
              plugins: {
                legend: { position: 'top', align: 'end' },
                tooltip: {
                  backgroundColor: 'rgba(15, 23, 42, 0.95)',
                  padding: 12,
                  callbacks: {
                    label: (c) => {
                      const val = c.parsed.y;
                      const isCurrency = c.dataset.yAxisID === 'y1';
                      return ` ${c.dataset.label}: ${isCurrency ? fmtCurrency(val) : val.toFixed(2) + '%'}`;
                    }
                  }
                },
                datalabels: {
                  display: false // Desactivamos datalabels globales para evitar superposici√≥n en dual axis
                }
              },
              scales: {
                // Eje Izquierdo: Porcentajes (Yield)
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  ticks: { callback: (v) => v + '%', font: { size: 10 } },
                  grid: { color: 'rgba(128,128,128,0.1)' }
                },
                // Eje Derecho: Dinero (Acumulado)
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  grid: { drawOnChartArea: false }, // Limpio
                  ticks: {
                    callback: (v) => fmtCurrency(v, 0), // Formato Moneda Compacto
                    font: { size: 10 },
                    color: '#64748b'
                  }
                },
                x: { grid: { display: false } }
              }
            }
          });

          // 2. Funci√≥n de Actualizaci√≥n
          const update = () => {
            const val = parseFloat(inputEl.value);
            const P = isNaN(val) ? 0 : val;
            displayEl.textContent = fmtCurrency(P); // Actualizar visual

            const years = [1, 2, 3, 4, 5];
            const pctFixed = [];
            const pctStock = [];
            const accFixedArr = [];
            const accStockArr = [];

            let tableRows = '';

            let accumulatedDAP = 0;
            let accumulatedStock = 0;

            let finalDiff = 0;
            let finalWinner = '';
            let finalPct = 0;

            years.forEach(n => {
              // --- C√ÅLCULO DAP ---
              const flowDAP = P * rateFixed;
              accumulatedDAP += flowDAP;
              const yieldDAP = rateFixed;

              // --- C√ÅLCULO ACCI√ìN ---
              const rateYearN = rateStock * Math.pow(1 + growthRate, n - 1);
              const flowStock = P * rateYearN;
              accumulatedStock += flowStock;
              const yieldStock = rateYearN;

              // Datos para Gr√°fico
              // Eje Y (Izquierdo): Tasas %
              pctFixed.push(yieldDAP * 100);
              pctStock.push(yieldStock * 100);

              // Eje Y1 (Derecho): Acumulado $
              accFixedArr.push(accumulatedDAP);
              accStockArr.push(accumulatedStock);

              // Constuir Fila Tabla
              const isWinStock = flowStock > flowDAP;
              const stockColor = isWinStock ? 'text-blue-600 bg-blue-50 dark:bg-blue-900/20' : 'text-slate-500';
              const dapColor = !isWinStock ? 'text-emerald-600 bg-emerald-50 dark:bg-emerald-900/20' : 'text-slate-500';

              tableRows += `
                  <div class="mb-3 last:mb-0 border border-slate-100 dark:border-slate-700 rounded-lg overflow-hidden text-[10px]">
                      <div class="bg-slate-50 dark:bg-slate-800 px-3 py-1 border-b border-slate-100 dark:border-slate-700 flex justify-between">
                          <span class="font-bold text-slate-500">A√ëO ${n}</span>
                      </div>
                      <div class="flex divide-x divide-slate-100 dark:divide-slate-700">
                          <!-- Columna DAP -->
                          <div class="flex-1 p-2 space-y-1 ${dapColor}">
                              <div class="flex justify-between">
                                  <span class="text-slate-400 uppercase tracking-tighter">Tasa</span>
                                  <span class="font-mono">${fmtPercent(yieldDAP)}</span>
                              </div>
                              <div class="flex justify-between font-bold">
                                  <span class="text-slate-400 uppercase tracking-tighter">Flujo</span>
                                  <span class="font-mono text-xs">${fmtCurrency(flowDAP)}</span>
                              </div>
                              <div class="flex justify-between opacity-75">
                                  <span class="text-slate-400 uppercase tracking-tighter">Acum.</span>
                                  <span class="font-mono">${fmtCurrency(accumulatedDAP)}</span>
                              </div>
                          </div>
                          
                          <!-- Columna STOCK -->
                          <div class="flex-1 p-2 space-y-1 ${stockColor}">
                              <div class="flex justify-between">
                                  <span class="text-slate-400 uppercase tracking-tighter">Yield</span>
                                  <span class="font-mono">${fmtPercent(yieldStock)}</span>
                              </div>
                              <div class="flex justify-between font-bold">
                                  <span class="text-slate-400 uppercase tracking-tighter">Flujo</span>
                                  <span class="font-mono text-xs">${fmtCurrency(flowStock)}</span>
                              </div>
                              <div class="flex justify-between opacity-75">
                                  <span class="text-slate-400 uppercase tracking-tighter">Acum.</span>
                                  <span class="font-mono">${fmtCurrency(accumulatedStock)}</span>
                              </div>
                          </div>
                      </div>
                  </div>
              `;

              // Guardar final
              if (n === 5) {
                finalDiff = accumulatedStock - accumulatedDAP;
                finalWinner = finalDiff > 0 ? 'Acci√≥n' : 'Dep√≥sito';
                const base = finalDiff > 0 ? accumulatedDAP : accumulatedStock;
                finalPct = base > 0 ? Math.abs(finalDiff) / base : 0;
              }
            });

            // Footer Resultados
            const colorDiff = finalDiff > 0 ? 'text-blue-600' : 'text-slate-500';
            resultsEl.innerHTML = `
                <div class="space-y-1">${tableRows}</div>
                <div class="mt-2 text-center p-3 bg-slate-50 dark:bg-slate-800 rounded border border-dashed border-slate-200 dark:border-slate-700">
                    <p class="text-[9px] uppercase font-bold text-slate-400">Diferencia Total (5 A√±os)</p>
                    <p class="text-lg font-black ${colorDiff}">${finalDiff > 0 ? '+' : ''}${fmtCurrency(finalDiff)}</p>
                </div>
             `;

            // Renderizar Gr√°fico
            chart.data.labels = years.map(y => `A√±o ${y}`);
            chart.data.datasets = [
              {
                label: 'Acci√≥n (Yield vs Costo %)',
                data: pctStock,
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                borderWidth: 3,
                tension: 0.3,
                fill: true,
                order: 2,
                yAxisID: 'y'
              },
              {
                label: 'Dep√≥sito (Tasa Fija %)',
                data: pctFixed,
                borderColor: '#10b981',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0,
                order: 3,
                yAxisID: 'y'
              },
              // --- NUEVOS DATASETS EJE DERECHO ---
              {
                label: 'Acumulado Acci√≥n ($)',
                data: accStockArr,
                borderColor: '#60a5fa',
                borderWidth: 2,
                borderDash: [2, 2],
                pointRadius: 3,
                fill: false,
                order: 1,
                yAxisID: 'y1'
              },
              {
                label: 'Acumulado DAP ($)',
                data: accFixedArr,
                borderColor: '#34d399',
                borderWidth: 2,
                borderDash: [2, 2],
                pointRadius: 3,
                fill: false,
                order: 1,
                yAxisID: 'y1'
              }
            ];
            chart.update();
          };

          inputEl.addEventListener('input', update);
          update();
        };

        const observer = new IntersectionObserver((entries) => {
          entries.forEach(e => { if (e.isIntersecting) { setTimeout(initModule, 100); observer.disconnect(); } });
        }, { threshold: 0.1 });
        const wrapper = document.getElementById(wrapperId);
        if (wrapper) observer.observe(wrapper);

      } catch (err) {
        console.error("Error M9:", err);
      }
    }

    // FUNCI√ìN ELIMINADA: renderExecutiveDashboard (versi√≥n antigua de 1 par√°metro)
    // Esta funci√≥n duplicada causaba conflictos. La versi√≥n correcta de 3 par√°metros est√° en l√≠nea 6552.

    // Funci√≥n para generar la narrativa del M√≥dulo 3
    function generateMultiplesConclusion(module3Data) {
      const { perHist, perGrow, perObj, epsBase, bvpsBase, pbvObj, precioPerObj, precioPbvObj, ke } = module3Data;

      // 1. Validaci√≥n de Viabilidad
      if (!Number.isFinite(epsBase) || epsBase <= 0) {
        return {
          title: "Valoraci√≥n No Concluyente",
          message: "No se puede establecer un precio objetivo fiable por m√∫ltiplos porque la empresa no tiene beneficios base positivos (EPS normalizado ‚â§ 0).",
          type: "neutral",
          icon: "‚ö†Ô∏è"
        };
      }

      if (!Number.isFinite(perHist) || !Number.isFinite(perGrow)) {
        return {
          title: "Datos Insuficientes",
          message: "Faltan datos hist√≥ricos o de proyecci√≥n de crecimiento (PEG/g) para calcular un m√∫ltiplo objetivo robusto.",
          type: "neutral",
          icon: "ü§î"
        };
      }

      // 2. Construcci√≥n del Tooltip Detallado
      const tooltipContent = `M√âTODO PER (Ganancias):
EPS Base Normalizado: ${fmtCurrency(epsBase)}
PER Objetivo: ${fmtNumber(perObj, 1)}x
=> Precio: ${fmtCurrency(precioPerObj)}

M√âTODO P/BV (Patrimonio):
BVPS Base: ${fmtCurrency(bvpsBase)}
P/BV Objetivo: ${fmtNumber(pbvObj, 2)}x
=> Precio: ${fmtCurrency(precioPbvObj)}

Tasa de Descuento (Ke): ${fmtPercent(ke, 1)}`;

      // 3. An√°lisis de la Tensi√≥n: Historia vs. Crecimiento
      const threshold = 0.20; // 20% de diferencia significativa
      let title = "";
      let message = "";
      let type = "neutral";
      let icon = "‚öñÔ∏è";

      // Texto explicativo de los componentes con tooltip interactivo
      const componentsText = `<br><span class="text-xs opacity-80">Basado en un PER Hist√≥rico de ${fmtNumber(perHist, 1)}x y un PER te√≥rico por Crecimiento de ${fmtNumber(perGrow, 1)}x. Se utiliza un PER Objetivo ponderado de ${fmtNumber(perObj, 1)}x sobre un EPS Base de ${fmtCurrency(epsBase)}.<span class="cursor-help text-blue-600 dark:text-blue-400 font-bold ml-1 text-lg" title="${tooltipContent}">[*]</span></span>`;

      // Advertencia de riesgo si el Ke es muy alto
      const riskWarning = (ke && ke > 0.15) ? `<br><br><strong>‚ö†Ô∏è Nota de Riesgo:</strong> El alto Costo de Capital (Ke: ${fmtPercent(ke)}) indica que el mercado percibe un riesgo significativo, lo que podr√≠a presionar los m√∫ltiplos a la baja independientemente del crecimiento.` : "";



      if (perGrow < perHist * (1 - threshold)) {
        // Escenario: De-rating (El crecimiento ya no justifica la historia)
        title = "üìâ Ajuste de Expectativas (De-rating)";
        message = `Existe una desconexi√≥n de expectativas. El mercado ha pagado hist√≥ricamente un m√∫ltiplo de ${fmtNumber(perHist, 1)}x, una cifra que el crecimiento actual proyectado (que te√≥ricamente justifica solo ${fmtNumber(perGrow, 1)}x) ya no respalda plenamente. Para corregir esto y valorar la empresa, el modelo utiliza un PER Objetivo Ponderado aplicado sobre una utilidad normalizada.`;
        type = "warning"; // No es necesariamente malo, pero es una alerta de contracci√≥n de m√∫ltiplo.
        icon = "üìâ";


      } else if (perGrow > perHist * (1 + threshold)) {
        // Escenario: Prima de Crecimiento (Growth Premium)
        title = "üöÄ Historia de Aceleraci√≥n";
        message = `Las proyecciones de crecimiento (basadas en PEG/g) justifican un m√∫ltiplo (${fmtNumber(perGrow, 1)}x) superior al promedio hist√≥rico. Si la empresa cumple, el mercado deber√≠a empezar a pagar esta prima de crecimiento.`;
        type = "growth";
        icon = "üöÄ";

      } else {
        // Escenario: Estabilidad / Vuelta a la media
        title = "‚öñÔ∏è Valoraci√≥n en Rango Hist√≥rico";
        message = `Las expectativas de crecimiento est√°n alineadas con la valoraci√≥n que el mercado ha asignado hist√≥ricamente. El precio objetivo refleja una evoluci√≥n estable del negocio sin una re-calificaci√≥n dr√°stica del m√∫ltiplo.`;
        type = "good"; // Usamos 'good' para denotar estabilidad/neutralidad positiva.
        icon = "‚öñÔ∏è";
      }

      return {
        title,
        message: message + componentsText + riskWarning,
        type,
        icon
      };
    }

    function renderModule3(module, container) {
      if (!module) {
        container.textContent = 'No se pudo calcular el m√≥dulo 3.';
        return;
      }

      // 1. Generar la Conclusi√≥n Narrativa
      const conclusion = generateMultiplesConclusion(module);

      // 2. Definir estilos de color para la caja de conclusi√≥n
      const conclusionColorClasses = {
        good: 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100',
        growth: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800 text-blue-900 dark:text-blue-100',
        warning: 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100',
        neutral: 'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100',
        bad: 'bg-rose-50 dark:bg-rose-900/20 border-rose-200 dark:border-rose-800 text-rose-900 dark:text-rose-100' // Por si acaso
      };

      // 3. Renderizar el nuevo Layout
      container.innerHTML = `
        <div class="space-y-6">
          <div class="grid sm:grid-cols-2 gap-4">
            <div class="bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4 border border-blue-100 dark:border-blue-900">
              <p class="text-xs uppercase text-blue-500 font-semibold cursor-help" title="${moduleFormulas.obj_price_per}">Precio Objetivo (v√≠a PER)</p>
              <p class="text-2xl font-bold text-blue-600 dark:text-blue-300">${fmtCurrency(module.precioPerObj)}</p>
            </div>
            <div class="bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4 border border-purple-100 dark:border-purple-900">
              <p class="text-xs uppercase text-purple-500 font-semibold cursor-help" title="${moduleFormulas.obj_price_pbv}">Precio Objetivo (v√≠a P/BV)</p>
              <p class="text-2xl font-bold text-purple-600 dark:text-purple-300">${fmtCurrency(module.precioPbvObj)}</p>
            </div>
          </div>

          <div class="w-full border-2 ${conclusionColorClasses[conclusion.type]} rounded-xl p-5">
            <div class="flex items-start gap-4">
              <div class="text-4xl flex-shrink-0">${conclusion.icon}</div>
              <div class="flex-1">
                <h4 class="text-sm font-bold uppercase mb-2">Veredicto del Modelo de M√∫ltiplos</h4>
                <p class="text-sm font-bold leading-relaxed">${conclusion.title}</p>
                <p class="text-sm leading-relaxed mt-1">${conclusion.message}</p>
              </div>
            </div>
          </div>

          <div>
            <details>
              <summary class="flex justify-end list-none mb-2">
                <div class="inline-flex items-center gap-2 px-3 py-1.5 rounded-lg border border-amber-200 dark:border-amber-700 bg-white/50 dark:bg-slate-800 text-xs font-bold uppercase text-amber-900 dark:text-white cursor-pointer hover:bg-amber-50 dark:hover:bg-amber-900/30 transition shadow-sm">
                  <span>Ver detalles del c√°lculo y supuestos</span>
                  <svg class="w-4 h-4 group-open:rotate-180 transition-transform text-amber-900 dark:text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                  </svg>
                </div>
              </summary>
              <div class="mt-4 overflow-x-auto bg-slate-50 dark:bg-slate-900/30 rounded-xl p-4">
                <table class="min-w-full text-sm">
                  <thead>
                     <tr class="text-left text-slate-500 border-b border-slate-200 dark:border-slate-700">
                       <th class="pb-2">Concepto</th>
                       <th class="pb-2">Valor</th>
                     </tr>
                  </thead>
                  <tbody class="divide-y divide-slate-200 dark:divide-slate-700">
                    <tr><td class="py-2 text-slate-500">EPS Base (Normalizado)</td><td class="py-2 font-semibold">${fmtNumber(module.epsBase)}</td></tr>
                    <tr><td class="py-2 text-slate-500">BVPS Base (Normalizado)</td><td class="py-2 font-semibold">${fmtNumber(module.bvpsBase)}</td></tr>
                    <tr><td class="py-2 text-slate-500 cursor-help" title="${moduleFormulas.obj_per_hist}">PER Hist√≥rico (Promedio)</td><td class="py-2">${fmtNumber(module.perHist, 1)}x</td></tr>
                    <tr><td class="py-2 text-slate-500 cursor-help" title="${moduleFormulas.obj_per_growth}">PER Te√≥rico por Crecimiento (PEG*g)</td><td class="py-2">${fmtNumber(module.perGrow, 1)}x</td></tr>
                    <tr class="bg-slate-100 dark:bg-slate-800/50"><td class="py-2 text-slate-700 dark:text-slate-300 font-semibold cursor-help" title="${moduleFormulas.obj_per_final}">PER Objetivo Final (Utilizado)</td><td class="py-2 font-bold text-blue-600 dark:text-blue-300">${fmtNumber(module.perObj, 1)}x</td></tr>
                    <tr><td class="py-2 text-slate-500 cursor-help" title="${moduleFormulas.obj_pbv}">P/BV Objetivo Impl√≠cito</td><td class="py-2 font-semibold text-purple-600 dark:text-purple-300">${fmtNumber(module.pbvObj, 2)}x</td></tr>
                  </tbody>
                </table>
                <div class="mt-3 text-xs text-slate-400 flex flex-wrap gap-4">
                  <span>Ke (Riesgo): ${fmtPercent(module.ke)}</span>
                  <span>g Perpetua: ${fmtPercent(module.gPerp)}</span>
                  <span>CAGR EPS (5y): ${fmtPercent(module.cagrEPS)}</span>
                  <span>PEG Dato: ${fmtNumber(module.pegDato, 2) || 'N/A'}</span>
                </div>
              </div>
            </details>
          </div>
        </div>`;
    }

    function renderModule4(module, container) {
      // Renderizar KPIs Superiores
      const kpiHtml = `
        <div class="grid md:grid-cols-3 gap-3 mb-4">
          <div class="bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4 border border-slate-200 dark:border-slate-700">
             <p class="text-xs uppercase text-slate-400 font-semibold">Payout (Pol√≠tica)</p>
             <p class="text-xl font-bold text-slate-700 dark:text-slate-200">${fmtPercent(module.payoutBase)}</p>
          </div>
          <div class="bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4 border border-slate-200 dark:border-slate-700">
             <p class="text-xs uppercase text-slate-400 font-semibold">Retenci√≥n (Reinversi√≥n)</p>
             <p class="text-xl font-bold text-slate-700 dark:text-slate-200">${fmtPercent(module.retencion)}</p>
          </div>
          <div class="bg-blue-50 dark:bg-blue-900/20 rounded-xl p-4 border border-blue-100 dark:border-blue-800">
             <p class="text-xs uppercase text-blue-500 font-semibold">Crecimiento (g) Input</p>
             <p class="text-xl font-bold text-blue-600 dark:text-blue-300">${fmtPercent(module.gExp)}</p>
          </div>
        </div>
      `;

      // Renderizar Bloque de Conclusi√≥n (NUEVA NARRATIVA ROBUSTA)

      // 1. CAPTURA ROBUSTA DEL DIAGN√ìSTICO (Conexi√≥n M√≥dulo 1)
      const m1 = window.moduleResults?.module1;
      let diagLabel = "Diagn√≥stico No Disponible";
      let diagSeverity = "neutral";

      // Ruta A: Debug del M√≥dulo 1 (Ideal)
      if (m1?.debug?.diagnosis?.label) {
        diagLabel = m1.debug.diagnosis.label;
        diagSeverity = m1.debug.diagnosis.severity; // 'red', 'yellow', 'green'
      }
      // Ruta B: Contexto Global (Fallback)
      else if (state.context?.method?.reason) {
        diagLabel = state.context.method.reason;
        if (diagLabel.toLowerCase().includes('deterioro') || diagLabel.toLowerCase().includes('crisis') || diagLabel.toLowerCase().includes('negativo')) {
          diagSeverity = 'red';
        }
      }

      // KPIs B√°sicos
      const payout = fmtPercent(module.payoutBase);
      const retencion = fmtPercent(module.retencion);
      const gExpFormatted = fmtPercent(module.gExp);
      const roeHistorico = m1?.estructural?.roePromedioNormalizado || 0.10;

      // 2. L√ìGICA DE NARRATIVA 1: "INTERPRETACI√ìN DE LA TRAYECTORIA"
      let tituloInterpretacion = 'üìà Interpretaci√≥n de la Trayectoria';
      let iconInterpretacion = 'üìà';
      let textoInterpretacion = ''; // Se llena abajo

      // Condici√≥n de Crisis: Diagn√≥stico Rojo O (Retenci√≥n Extrema >95% Y Crecimiento Pobre <6%)
      // Esto captura "Capital Destroyers" que retienen todo para no quebrar, no para crecer.
      const isSurvivalMode = (diagSeverity === 'red') || (module.retencion > 0.95 && module.gExp < 0.06);

      if (isSurvivalMode) {
        tituloInterpretacion = '‚ö†Ô∏è Capitalizaci√≥n por Supervivencia';
        iconInterpretacion = '‚ö†Ô∏è';
        textoInterpretacion = `
           La empresa retiene el <strong>${retencion}</strong> de sus utilidades, pero en este contexto de baja rentabilidad (ROE impl√≠cito d√©bil), esto sugiere una <strong>necesidad defensiva de fortalecer el patrimonio</strong> m√°s que una estrategia de expansi√≥n agresiva.
           <br><br>
           La proyecci√≥n de crecimiento del <strong>${gExpFormatted}</strong> es te√≥rica y depende de que la empresa logre revertir su deterioro estructural detectado en el diagn√≥stico inicial.
         `;
      } else {
        // CASO NORMAL / SANO
        tituloInterpretacion = 'üìà Interpretaci√≥n de la Trayectoria';
        iconInterpretacion = 'üìà';
        textoInterpretacion = `
           El gr√°fico visualiza la tesis de crecimiento del negocio. Esta proyecci√≥n se sustenta en una pol√≠tica de asignaci√≥n de capital donde la empresa <strong>retiene el ${retencion}</strong> de sus utilidades para reinversi√≥n, distribuyendo el <strong>${payout}</strong> restante a los accionistas.
           <br><br>
           Esta pol√≠tica de reinversi√≥n es el motor matem√°tico que genera el crecimiento compuesto del <strong>${gExpFormatted}</strong>, reflejado en la curva ascendente de EPS y BVPS.
         `;
      }

      const interpretacionHtml = `
        <div class="mb-4 bg-slate-50 dark:bg-slate-900/50 border border-slate-200 dark:border-slate-700 rounded-xl p-5">
          <div class="flex items-start gap-3 mb-3">
            <div class="text-2xl flex-shrink-0">${iconInterpretacion}</div>
            <h4 class="text-sm font-bold uppercase text-slate-700 dark:text-slate-300">${tituloInterpretacion}</h4>
          </div>
          <p class="text-sm text-slate-700 dark:text-slate-300 leading-relaxed mb-3">
            ${textoInterpretacion}
          </p>
        </div>
      `;

      // --- 3. RENDERIZADO DE CONCLUSI√ìN (Usando l√≥gica del M√≥dulo) ---
      const conc = module.conclusion;
      let conclusionBoxHtml = "";

      if (conc) {
        const conclusionColorClasses = {
          'excellent': 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-300 dark:border-emerald-700 text-emerald-900 dark:text-emerald-100',
          'good': 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-800 dark:text-emerald-200',
          'warning': 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100',
          'bad': 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100',
          'info': 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800 text-blue-900 dark:text-blue-100' // NUEVO TIPO
        };

        const colorClass = conclusionColorClasses[conc.type] || conclusionColorClasses['warning'];

        conclusionBoxHtml = `
          <div class="mb-4 ${colorClass} border rounded-xl p-5">
            <div class="flex items-start gap-3 mb-3">
              <div class="text-2xl flex-shrink-0">${conc.icon || 'üìù'}</div>
              <h4 class="text-sm font-bold uppercase">${conc.title}</h4>
            </div>
            <p class="text-sm leading-relaxed">
              ${conc.message}
            </p>
          </div>
        `;
      }

      const conclusionHtml = interpretacionHtml + conclusionBoxHtml;

      // Tabla de Proyecci√≥n - ELIMINADA (datos preservados para el gr√°fico)

      // Canvas Gr√°fico
      const chartHtml = `<div class="mt-6 bg-white dark:bg-slate-800 p-4 rounded-xl border border-slate-200 dark:border-slate-700"><canvas id="chart-module4" class="w-full h-64"></canvas></div>`;

      container.innerHTML = kpiHtml + chartHtml + conclusionHtml;

      // Render Chart
      const ctx = document.getElementById('chart-module4').getContext('2d');
      const isDark = document.documentElement.classList.contains('dark');
      const textColor = isDark ? '#94a3b8' : '#64748b';

      // Filtramos la fila base para el gr√°fico si se desea, o la incluimos
      const dataRows = module.tabla;

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dataRows.map(r => r.year),
          datasets: [
            { label: 'EPS Proyectado', data: dataRows.map(r => r.eps), borderColor: '#2563eb', backgroundColor: '#2563eb', tension: 0.3, borderWidth: 3 },
            { label: 'BVPS Proyectado', data: dataRows.map(r => r.bvps), borderColor: '#9333ea', backgroundColor: '#9333ea', tension: 0.3, borderWidth: 3 }
          ]
        },
        options: {
          plugins: {
            legend: { labels: { color: textColor } },
            datalabels: {
              color: textColor,
              formatter: (value) => Math.round(value).toLocaleString(),
              align: 'top',
              anchor: 'end'
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  return context.dataset.label + ': ' + Math.round(context.parsed.y).toLocaleString();
                }
              }
            }
          },
          scales: {
            y: {
              ticks: {
                color: textColor,
                callback: (value) => Math.round(value).toLocaleString()
              },
              grid: { color: isDark ? '#1e293b' : '#f1f5f9' }
            },
            x: { ticks: { color: textColor }, grid: { display: false } }
          }
        }
      });
      chartRegistry.push(chart);
    }

    function renderModule5(module, container) {
      if (!module) return;

      // 1. Tarjetas de KPIs (Sem√°foros)
      const renderCard = (label, value, suffix, thresholdBad, thresholdGood, isHigherBetter = true, tooltipId = null) => {
        if (value === null) return `<div class="bg-slate-50 dark:bg-slate-900/50 p-4 rounded-xl"><p class="text-xs text-slate-400">${label}</p><p class="text-xl font-bold text-slate-300">--</p></div>`;

        let color = "text-slate-700 dark:text-slate-200";
        let bg = "bg-slate-100 dark:bg-slate-900/50";

        // L√≥gica de Sem√°foro
        if (isHigherBetter) {
          if (value < thresholdBad) { color = "text-red-600 dark:text-red-400"; bg = "bg-red-50 dark:bg-red-900/20 border border-red-100 dark:border-red-900"; }
          else if (value > thresholdGood) { color = "text-emerald-600 dark:text-emerald-400"; bg = "bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-100 dark:border-emerald-900"; }
          else { color = "text-amber-600 dark:text-amber-400"; bg = "bg-amber-50 dark:bg-amber-900/20 border border-amber-100 dark:border-amber-900"; }
        } else { // Lower is better (e.g. Debt/Equity)
          if (value > thresholdBad) { color = "text-red-600 dark:text-red-400"; bg = "bg-red-50 dark:bg-red-900/20 border border-red-100 dark:border-red-900"; }
          else if (value < thresholdGood) { color = "text-emerald-600 dark:text-emerald-400"; bg = "bg-emerald-50 dark:bg-emerald-900/20 border border-emerald-100 dark:border-emerald-900"; }
          else { color = "text-amber-600 dark:text-amber-400"; bg = "bg-amber-50 dark:bg-amber-900/20 border border-amber-100 dark:border-amber-900"; }
        }

        const tooltipAttr = tooltipId ? `data-tooltip="${getTooltipText(tooltipId)}"` : '';

        return `
            <div class="${bg} p-4 rounded-xl flex flex-col justify-center items-center text-center">
               <p class="text-xs uppercase text-slate-500 dark:text-slate-400 font-semibold mb-1" ${tooltipAttr}>${label}</p>
               <p class="text-2xl font-bold ${color}">${fmtNumber(value)}<span class="text-sm ml-1 text-slate-400">${suffix}</span></p>
            </div>
         `;
      };

      const cardsHtml = `
        <div class="grid grid-cols-3 gap-4 mb-6">
           ${renderCard("Liquidez Corriente", module.liquidezCorriente, "x", 1.0, 1.5, true, 'LIQUIDEZ')}
           ${renderCard("Solvencia (Deuda/Patrimonio)", module.deudaSobrePatrimonio, "x", 1.5, 0.8, false, 'DEUDA_PATRIMONIO')}
           ${renderCard("Cobertura Intereses", module.coberturaIntereses, "x", 2.0, 5.0, true, 'COBERTURA_INTERESES')}
        </div>
      `;

      // 2. Conclusi√≥n Narrativa
      const conclusionColor = module.conclusion.type === 'bad' ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100' :
        module.conclusion.type === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100' :
          module.conclusion.type === 'excellent' ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 text-purple-900 dark:text-purple-100' :
            'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100';

      const conclusionHtml = `
          <div class="mb-6 w-full border-2 ${conclusionColor} rounded-xl p-5">
            <div class="flex items-start gap-4">
              <div class="text-3xl flex-shrink-0">${module.conclusion.icon}</div>
              <div class="flex-1">
                <h4 class="text-sm font-bold uppercase mb-1 opacity-90">${module.conclusion.title}</h4>
                <p class="text-sm leading-relaxed opacity-90">${module.conclusion.message}</p>
              </div>
            </div>
          </div>
      `;

      // 3. Gr√°fico Mixto: Estructura de Capital (Barras Apiladas) + Ratios (L√≠neas)
      const magnitudLabel = state.financialData?.datos?.magnitudLabel || 'MM$';
      const chartHtml = `
        <div class="bg-white dark:bg-slate-800 p-4 rounded-xl border border-slate-200 dark:border-slate-700">
           <h4 class="text-xs font-bold uppercase text-slate-400 mb-4 text-center">Estructura de Capital y Salud Financiera</h4>
           <canvas id="chart-module5" class="w-full h-64"></canvas>
        </div>
      `;

      container.innerHTML = cardsHtml + chartHtml + conclusionHtml;

      // Render Chart
      const ctx = document.getElementById('chart-module5').getContext('2d');
      const isDark = document.documentElement.classList.contains('dark');
      const textColor = isDark ? '#94a3b8' : '#64748b';
      const labelColor = isDark ? '#ffffff' : '#000000';

      const chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: module.chartData.map(d => d.year),
          datasets: [
            // Dataset 1: Patrimonio (Base de la barra apilada - Azul)
            {
              type: 'bar',
              label: 'Patrimonio',
              data: module.chartData.map(d => d.patrimonio),
              backgroundColor: '#3b82f6',
              borderRadius: 4,
              stack: 'capitalTotal',
              yAxisID: 'y-axis-money',
              order: 2, // Dibujar debajo de las l√≠neas
              datalabels: {
                display: false // No mostrar labels en la base
              }
            },
            // Dataset 2: Deuda Neta (Tope de la barra apilada - Naranja)
            {
              type: 'bar',
              label: 'Deuda Neta',
              data: module.chartData.map(d => d.deudaNeta),
              backgroundColor: '#f97316',
              borderRadius: 4,
              stack: 'capitalTotal',
              yAxisID: 'y-axis-money',
              order: 2, // Dibujar debajo de las l√≠neas
              datalabels: {
                color: labelColor,
                anchor: 'end',
                align: 'top',
                formatter: (value, context) => {
                  const solvencia = module.chartData[context.dataIndex].solvencia;
                  return solvencia !== null ? solvencia.toFixed(2) + 'x' : '';
                }
              }
            },
            // Dataset 3: Liquidez Corriente (L√≠nea Verde)
            {
              type: 'line',
              label: 'Liquidez (Ratio)',
              data: module.chartData.map(d => d.liquidez),
              borderColor: '#10b981',
              backgroundColor: '#10b981',
              tension: 0.3,
              borderWidth: 3,
              pointBackgroundColor: '#fff',
              pointBorderColor: '#10b981',
              pointBorderWidth: 2,
              pointRadius: 5,
              yAxisID: 'y-axis-ratios',
              order: 1, // Dibujar encima de las barras
              datalabels: {
                display: false // Evitar sobrecarga visual
              }
            },
            // Dataset 4: Cobertura Intereses (L√≠nea Gris Punteada)
            {
              type: 'line',
              label: 'Cobertura (Ratio)',
              data: module.chartData.map(d => d.cobertura),
              borderColor: '#94a3b8',
              backgroundColor: '#94a3b8',
              borderDash: [5, 5],
              tension: 0.3,
              borderWidth: 2,
              pointBackgroundColor: '#fff',
              pointBorderColor: '#94a3b8',
              pointBorderWidth: 2,
              pointRadius: 5,
              yAxisID: 'y-axis-ratios',
              order: 1, // Dibujar encima de las barras
              datalabels: {
                display: false // Evitar sobrecarga visual
              }
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              labels: { color: textColor },
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  const datasetLabel = context.dataset.label;
                  const value = context.parsed.y;

                  if (datasetLabel.includes('Ratio')) {
                    return datasetLabel + ': ' + (value !== null ? value.toFixed(2) + 'x' : 'N/A');
                  } else {
                    return datasetLabel + ': ' + Math.round(value).toLocaleString('es-CL') + ' ' + magnitudLabel;
                  }
                }
              }
            }
          },
          scales: {
            'y-axis-money': {
              type: 'linear',
              display: true,
              position: 'left',
              stacked: true,
              title: {
                display: true,
                text: magnitudLabel + ' (Estructura de Capital)',
                color: textColor
              },
              ticks: {
                color: textColor,
                callback: (value) => Math.round(value).toLocaleString('es-CL')
              },
              grid: { color: isDark ? '#1e293b' : '#f1f5f9' }
            },
            'y-axis-ratios': {
              type: 'linear',
              display: true,
              position: 'right',
              stacked: false,
              title: {
                display: true,
                text: 'Ratios (Veces)',
                color: textColor
              },
              ticks: {
                color: textColor,
                callback: (value) => value.toFixed(1) + 'x'
              },
              grid: {
                drawOnChartArea: false,
              },
            },
            x: {
              stacked: true,
              ticks: { color: textColor },
              grid: { display: false }
            }
          }
        }
      });
      chartRegistry.push(chart);
    }

    function renderModule6(module, container) {
      if (!module) return;

      // 1. KPIs (Formato arreglado)
      const renderKpi = (label, value, trendPct, tooltipId = null) => {
        // Formato: 2 decimales, comas y puntos
        const valStr = value !== null ? fmtNumber(value, 2) + "x" : "--";
        let trendIcon = "‚û°Ô∏è";
        let trendClass = "text-slate-400 dark:text-slate-500";

        if (trendPct > 0.05) { trendIcon = "‚ÜóÔ∏è"; trendClass = "text-emerald-500 dark:text-emerald-400"; }
        if (trendPct < -0.05) { trendIcon = "‚ÜòÔ∏è"; trendClass = "text-amber-500 dark:text-amber-400"; }

        const tooltipAttr = tooltipId ? `data-tooltip="${getTooltipText(tooltipId)}"` : '';

        return `
            <div class="bg-slate-50 dark:bg-slate-900/40 p-4 rounded-xl border border-slate-200 dark:border-slate-700">
               <p class="text-[10px] uppercase text-slate-500 dark:text-slate-400 font-bold mb-1 tracking-wider" ${tooltipAttr}>${label}</p>
               <div class="flex items-end justify-between">
                  <span class="text-2xl font-bold text-slate-700 dark:text-slate-200">${valStr}</span>
                  <div class="text-right">
                     <span class="text-xs font-medium ${trendClass}">${trendIcon} ${fmtPercent(trendPct)}</span>
                     <p class="text-[8px] text-slate-400 dark:text-slate-500 uppercase font-medium">vs Promedio</p>
                  </div>
               </div>
            </div>
         `;
      };

      const kpiHtml = `
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
           ${renderKpi("Rotaci√≥n Activos (√öltimo A√±o)", module.tabla[module.tabla.length - 1].rotActivos, module.trends.assets, 'ROT_ACTIVOS')}
           ${renderKpi("Rotaci√≥n Inventarios (√öltimo A√±o)", module.tabla[module.tabla.length - 1].rotInventarios, module.trends.inventory, 'ROT_INVENTARIOS')}
           ${renderKpi("Rotaci√≥n Cap. Trabajo (√öltimo A√±o)", module.tabla[module.tabla.length - 1].rotCapitalTrabajo, module.trends.workingCap)}
        </div>
      `;

      // 2. Conclusi√≥n
      const conclusionColor = module.conclusion.type === 'bad' ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100' :
        module.conclusion.type === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100' :
          module.conclusion.type === 'excellent' ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 text-purple-900 dark:text-purple-100' :
            'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100';

      const conclusionHtml = `
          <div class="mb-6 w-full border-2 ${conclusionColor} rounded-xl p-5">
            <div class="flex items-start gap-4">
              <div class="text-3xl flex-shrink-0">${module.conclusion.icon}</div>
              <div class="flex-1">
                <h4 class="text-sm font-bold uppercase mb-1 opacity-90">${module.conclusion.title}</h4>
                <p class="text-sm leading-relaxed opacity-90">${module.conclusion.message}</p>
              </div>
            </div>
          </div>
      `;

      // 3. Gr√°fico H√≠brido (CORREGIDO: Incluye Inventarios)
      const chartHtml = `
        <div class="bg-white dark:bg-slate-800 p-4 rounded-xl border border-slate-200 dark:border-slate-700">
           <div class="flex justify-between items-center mb-4">
               <h4 class="text-xs font-bold uppercase text-slate-400">Contexto: Ventas (Barras) vs. Eficiencia (L√≠neas)</h4>
               <span class="text-[10px] text-slate-400 hidden sm:inline">Barras: Ventas (Eje Izq) | L√≠neas: Rotaci√≥n (Eje Der)</span>
           </div>
           <canvas id="chart-module6" class="w-full h-64"></canvas>
        </div>
      `;

      // Tabla eliminada de la visualizaci√≥n (c√°lculos preservados en module.tabla)

      container.innerHTML = kpiHtml + chartHtml + conclusionHtml;

      // Render Chart Config (Ejes Dobles + Formato ES-CL)
      const ctx = document.getElementById('chart-module6').getContext('2d');
      const isDark = document.documentElement.classList.contains('dark');
      const textColor = isDark ? '#94a3b8' : '#64748b';

      const chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: module.tabla.map(d => d.year),
          datasets: [
            {
              label: 'Ventas',
              data: module.tabla.map(d => d.ventas),
              type: 'bar',
              backgroundColor: isDark ? 'rgba(100, 116, 139, 0.6)' : 'rgba(148, 163, 184, 0.7)',
              borderColor: isDark ? 'rgba(148, 163, 184, 0.8)' : 'rgba(100, 116, 139, 0.8)',
              borderWidth: 1,
              borderRadius: 4,
              order: 4,
              yAxisID: 'y',
              datalabels: { display: false }
            },
            {
              label: 'Rot. Activos',
              data: module.tabla.map(d => d.rotActivos),
              type: 'line',
              borderColor: '#3b82f6',
              backgroundColor: '#3b82f6',
              tension: 0.3,
              borderWidth: 2,
              pointRadius: 3,
              order: 1,
              yAxisID: 'y1',
              datalabels: {
                color: isDark ? '#fff' : '#000',
                anchor: 'end',
                align: 'top',
                formatter: (value) => value !== null ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value) : ''
              }
            },
            {
              label: 'Rot. Inventarios',
              data: module.tabla.map(d => d.rotInventarios),
              type: 'line',
              borderColor: '#f59e0b',
              backgroundColor: '#f59e0b',
              tension: 0.3,
              borderWidth: 2,
              pointRadius: 3,
              order: 2,
              yAxisID: 'y1',
              datalabels: {
                color: isDark ? '#fff' : '#000',
                anchor: 'end',
                align: 'top',
                formatter: (value) => value !== null ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value) : ''
              }
            },
            {
              label: 'Rot. Cap. Trabajo',
              data: module.tabla.map(d => d.rotCapitalTrabajo),
              type: 'line',
              borderColor: '#10b981',
              backgroundColor: '#10b981',
              tension: 0.3,
              borderWidth: 2,
              borderDash: [3, 3],
              pointRadius: 0,
              pointHoverRadius: 0,
              order: 3,
              yAxisID: 'y1',
              datalabels: {
                color: isDark ? '#fff' : '#000',
                anchor: 'end',
                align: 'top',
                formatter: (value) => value !== null ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(value) : ''
              }
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { labels: { color: textColor, usePointStyle: true, boxWidth: 6, font: { size: 11 } } },
            tooltip: {
              callbacks: {
                label: function (context) {
                  let label = context.dataset.label || '';
                  if (label) { label += ': '; }
                  if (context.parsed.y !== null) {
                    // Formato tooltip consistente: 2 decimales fijos
                    label += new Intl.NumberFormat('es-CL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(context.parsed.y);
                    if (context.dataset.yAxisID === 'y1') label += 'x';
                  }
                  return label;
                }
              }
            }
          },
          scales: {
            x: { ticks: { color: textColor }, grid: { display: false } },
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: { display: false },
              // Formato Eje Y (Ventas)
              ticks: {
                color: textColor,
                font: { size: 10 },
                callback: (v) => new Intl.NumberFormat('es-CL', { notation: "compact", minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(v)
              },
              grid: { display: false }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: { display: false },
              // Formato Eje Y1 (Ratios): 2 decimales fijos
              ticks: {
                color: '#64748b',
                font: { size: 10 },
                callback: (v) => new Intl.NumberFormat('es-CL', { minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(v) + 'x'
              },
              grid: { color: isDark ? 'rgba(30, 41, 59, 0.5)' : 'rgba(241, 245, 249, 0.8)' }
            }
          }
        }
      });
      chartRegistry.push(chart);
    }

    function renderModule7(module, container) {
      if (!module) return;

      // 1. Tarjetas CAGR (Visualizaci√≥n con periodos y manejo de errores)
      const renderCagrCard = (label, cagrObj, tooltipId = null) => {
        // cagrObj tiene: { value, startYear, endYear, error }
        let valStr = "N/A";
        let colorClass = "text-slate-500 dark:text-slate-400";
        let periodStr = "";
        let errorMsg = "";

        if (cagrObj.error === "P√©rdida final") {
          valStr = "N/A";
          colorClass = "text-red-600 dark:text-red-400";
          errorMsg = "P√©rdida en √∫ltimo a√±o";
        } else if (cagrObj.error === "Sin base positiva") {
          valStr = "N/A";
          colorClass = "text-amber-600 dark:text-amber-400";
          errorMsg = "Sin base positiva";
        } else if (cagrObj.value !== null) {
          valStr = fmtPercent(cagrObj.value);
          if (cagrObj.value > 0.10) colorClass = "text-emerald-600 dark:text-emerald-400";
          else if (cagrObj.value < 0) colorClass = "text-red-500 dark:text-red-400";

          // Mostrar periodo si est√° disponible
          if (cagrObj.startYear && cagrObj.endYear) {
            periodStr = `<span class="text-[9px] text-slate-400 mt-1 block">Periodo: ${cagrObj.startYear}-${cagrObj.endYear}</span>`;
          }
        }

        const tooltipAttr = tooltipId ? `data-tooltip="${getTooltipText(tooltipId)}"` : '';

        return `
            <div class="bg-slate-50 dark:bg-slate-900/40 p-3 rounded-xl border border-slate-200 dark:border-slate-700 text-center">
               <p class="text-[10px] uppercase text-slate-400 font-bold mb-1" ${tooltipAttr}>${label}</p>
               <p class="text-xl font-bold ${colorClass}">${valStr}</p>
               ${errorMsg ? `<p class="text-[9px] text-slate-500 mt-1">${errorMsg}</p>` : periodStr}
            </div>
          `;
      };

      const kpiHtml = `
        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
           ${renderCagrCard("CAGR Ventas (5A)", module.cagrs.ventas, 'CAGR_VENTAS')}
           ${renderCagrCard("CAGR Utilidad", module.cagrs.beneficio, 'CAGR_UTILIDAD')}
           ${renderCagrCard("CAGR Patrimonio", module.cagrs.patrimonio, 'CAGR_PATRIMONIO')}
           ${renderCagrCard("CAGR FCFE", module.cagrs.fcfe, 'CAGR_FCFE')}
        </div>
      `;

      // 2. Conclusi√≥n
      const conclusionColor = module.conclusion.type === 'bad' ? 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-900 dark:text-red-100' :
        module.conclusion.type === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-200 dark:border-amber-800 text-amber-900 dark:text-amber-100' :
          module.conclusion.type === 'excellent' ? 'bg-purple-50 dark:bg-purple-900/20 border-purple-200 dark:border-purple-800 text-purple-900 dark:text-purple-100' :
            module.conclusion.type === 'good' ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-200 dark:border-emerald-800 text-emerald-900 dark:text-emerald-100' :
              'bg-slate-50 dark:bg-slate-900/20 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100';

      const conclusionHtml = `
          <div class="mb-6 w-full border-2 ${conclusionColor} rounded-xl p-5">
            <div class="flex items-start gap-4">
              <div class="text-3xl flex-shrink-0">${module.conclusion.icon}</div>
              <div class="flex-1">
                <h4 class="text-sm font-bold uppercase mb-1 opacity-90">${module.conclusion.title}</h4>
                <p class="text-sm leading-relaxed opacity-90">${module.conclusion.message}</p>
              </div>
            </div>
          </div>
      `;

      // 3. Gr√°fico de Evoluci√≥n (Raw Values para evitar confusi√≥n con negativos)
      const chartHtml = `
        <div class="bg-white dark:bg-slate-800 p-4 rounded-xl border border-slate-200 dark:border-slate-700">
           <h4 class="text-xs font-bold uppercase text-slate-400 mb-4 text-center">Trayectoria de Crecimiento: Ventas vs Rentabilidad</h4>
           <canvas id="chart-module7" class="w-full h-72"></canvas>
        </div>
      `;

      container.innerHTML = kpiHtml + chartHtml + conclusionHtml;

      // Render Chart (Usando Eje Izq para Ventas y Der para Utilidad para comparar pendientes)
      const ctx = document.getElementById('chart-module7').getContext('2d');
      const isDark = document.documentElement.classList.contains('dark');
      const textColor = isDark ? '#94a3b8' : '#64748b';

      const years = module.years;
      // Extraemos datos alineados con los a√±os
      const getData = (seriesArr) => years.map(y => seriesArr.find(s => s.year === y)?.value || 0);

      const chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: years,
          datasets: [
            {
              label: 'Ventas (Izq)',
              data: getData(module.series.ventas),
              type: 'bar',
              backgroundColor: isDark ? 'rgba(148, 163, 184, 0.5)' : 'rgba(148, 163, 184, 0.6)',
              borderColor: '#94a3b8',
              borderWidth: 1,
              borderRadius: 4,
              yAxisID: 'y',
              order: 3,
              datalabels: {
                color: isDark ? '#94a3b8' : '#64748b',
                anchor: 'end',
                align: 'top',
                formatter: (value) => value !== null ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(value) : ''
              }
            },
            {
              label: 'Utilidad Neta (Der)',
              data: getData(module.series.beneficio),
              borderColor: '#2563eb',
              backgroundColor: '#2563eb',
              tension: 0.3,
              borderWidth: 3,
              pointRadius: 4,
              yAxisID: 'y1',
              datalabels: {
                color: isDark ? '#fff' : '#000',
                anchor: 'end',
                align: 'top',
                formatter: (value) => value !== null ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(value) : ''
              }
            },
            {
              label: 'Patrimonio (Der)',
              data: getData(module.series.patrimonio),
              borderColor: '#10b981',
              backgroundColor: '#10b981',
              tension: 0.3,
              borderWidth: 2,
              pointRadius: 3,
              yAxisID: 'y1',
              datalabels: {
                color: isDark ? '#fff' : '#000',
                anchor: 'end',
                align: 'bottom',
                formatter: (value) => value !== null ? new Intl.NumberFormat('es-CL', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(value) : ''
              }
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { labels: { color: textColor } },
            tooltip: {
              callbacks: {
                label: function (context) {
                  let label = context.dataset.label || '';
                  if (label) { label += ': '; }
                  if (context.parsed.y !== null) {
                    label += new Intl.NumberFormat('es-CL', { minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(context.parsed.y);
                  }
                  return label;
                }
              }
            }
          },
          scales: {
            x: { ticks: { color: textColor }, grid: { display: false } },
            y: {
              type: 'linear', display: true, position: 'left',
              title: { display: true, text: 'Ventas', color: '#94a3b8', font: { size: 9 } },
              ticks: {
                color: '#94a3b8',
                callback: (v) => new Intl.NumberFormat('es-CL', { notation: "compact", minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(v)
              },
              grid: { display: false }
            },
            y1: {
              type: 'linear', display: true, position: 'right',
              title: { display: true, text: 'Utilidad / Patrimonio', color: textColor, font: { size: 9 } },
              ticks: {
                color: textColor,
                callback: (v) => new Intl.NumberFormat('es-CL', { notation: "compact", minimumFractionDigits: 0, maximumFractionDigits: 0 }).format(v)
              },
              grid: { color: isDark ? '#1e293b' : '#f1f5f9' }
            }
          }
        }
      });
      chartRegistry.push(chart);
    }

    function renderModule8(module, container, results) {
      if (!module) return;

      try {
        // Get access to module0 and module3 data from results object
        const module0 = results?.module0 || null;
        const module3 = results?.module3 || null;

        // ========== 1. ACCORDION-BASED BREAKDOWN LIST ==========
        const breakdownTableHtml = `
        <div class="mb-6 bg-white dark:bg-slate-800 rounded-xl border border-slate-200 dark:border-slate-700 overflow-hidden">
          <div class="bg-gradient-to-r from-slate-100 to-slate-50 dark:from-slate-700 dark:to-slate-800 px-6 py-4 border-b border-slate-200 dark:border-slate-700">
            <h3 class="text-sm font-black uppercase text-slate-700 dark:text-slate-300 tracking-wide">üìä Desglose de Valoraci√≥n</h3>
            <p class="text-xs text-slate-500 dark:text-slate-400 mt-1">Haz clic en cada m√©todo para ver los detalles del c√°lculo</p>
          </div>
          
          <!-- Accordion Table -->
          <table class="w-full">
            <thead>
              <tr class="bg-slate-50 dark:bg-slate-900/50 border-b border-slate-200 dark:border-slate-700 text-xs font-bold text-slate-600 dark:text-slate-400 uppercase">
                <th class="px-6 py-3 text-left" style="width: 50%;">Componente</th>
                <th class="px-6 py-3 text-right" style="width: 25%;">Precio Calculado</th>
                <th class="px-6 py-3 text-center" style="width: 25%;">Ponderaci√≥n</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-slate-200 dark:divide-slate-700">
            
              <!-- Item 1: DCF -->
              <tr>
                <td colspan="3" class="p-0">
                  <details class="group">
                    <summary class="px-6 py-4 cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-900/30 transition-colors">
                      <table class="w-full">
                        <tr>
                          <td class="flex items-center gap-2" style="width: 50%;">
                            <span class="text-2xl">üí∞</span>
                            <span class="text-sm font-bold text-slate-800 dark:text-slate-200">Precio justo - Intr√≠nseco (DCF)</span>
                            <svg class="w-4 h-4 text-slate-400 group-open:rotate-180 transition-transform ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                          </td>
                          <td class="text-right text-sm font-bold text-blue-600 dark:text-blue-400 pr-6" style="width: 25%;">${fmtCurrency(module.pDCF)}</td>
                          <td class="text-center" style="width: 25%;">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-bold bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300">40%</span>
                          </td>
                        </tr>
                      </table>
                    </summary>
                    
                    <div class="px-6 py-6 bg-slate-50 dark:bg-slate-900/50 space-y-4">
                      ${module0 ? `
                        <h4 class="text-sm font-bold text-slate-700 dark:text-slate-300 uppercase mb-3">C√°lculo DCF - Flujos de Caja Descontados</h4>
                        
                        <!-- KPIs Grid -->
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
                          <div class="bg-white dark:bg-slate-800 rounded-lg p-3 border border-slate-200 dark:border-slate-700">
                            <p class="text-xs text-slate-500 dark:text-slate-400 mb-1">VNA Total</p>
                            <p class="text-lg font-bold text-slate-800 dark:text-slate-200">${fmtCurrency(module0.vnaCLP)}</p>
                          </div>
                          <div class="bg-white dark:bg-slate-800 rounded-lg p-3 border border-slate-200 dark:border-slate-700">
                            <p class="text-xs text-slate-500 dark:text-slate-400 mb-1">Tasa Ke</p>
                            <p class="text-lg font-bold text-slate-800 dark:text-slate-200">${fmtPercent(module0.ke)}</p>
                          </div>
                          <div class="bg-white dark:bg-slate-800 rounded-lg p-3 border border-slate-200 dark:border-slate-700">
                            <p class="text-xs text-slate-500 dark:text-slate-400 mb-1">g Expl√≠cita</p>
                            <p class="text-lg font-bold text-slate-800 dark:text-slate-200">${fmtPercent(module0.gExplicita)}</p>
                          </div>
                          <div class="bg-white dark:bg-slate-800 rounded-lg p-3 border border-slate-200 dark:border-slate-700">
                            <p class="text-xs text-slate-500 dark:text-slate-400 mb-1">g Perpetua</p>
                            <p class="text-lg font-bold text-slate-800 dark:text-slate-200">${fmtPercent(module0.gPerpetuidad)}</p>
                          </div>
                        </div>

                        <!-- Formula Card -->
                        <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                          <p class="text-sm text-blue-900 dark:text-blue-100 font-mono">
                            Precio DCF = VNA (${fmtCurrency(module0.vnaCLP)}) / Acciones (${fmtNumber(financialData.datos.numeroAcciones, 0)}) = ${fmtCurrency(module.pDCF)}
                          </p>
                        </div>

                        <!-- FCFE Projections -->
                        <div class="mt-3">
                          <p class="text-xs uppercase text-slate-400 font-bold mb-2">Flujos Proyectados (FCFE):</p>
                          <div class="flex flex-wrap gap-2">
                            ${module0.fcfeProyectados.map((v, i) => `<span class="bg-white dark:bg-slate-800 px-3 py-1 rounded border border-slate-200 dark:border-slate-700 text-xs font-mono">A√±o ${i + 1}: ${fmtNumber(v, 0)}</span>`).join('')}
                          </div>
                        </div>
                      ` : '<p class="text-sm text-slate-500">Datos DCF no disponibles</p>'}
                    </div>
                  </details>
                </td>
              </tr>

              <!-- Item 2: M√∫ltiplo PER -->
              <tr>
                <td colspan="3" class="p-0">
                  <details class="group">
                    <summary class="px-6 py-4 cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-900/30 transition-colors">
                      <table class="w-full">
                        <tr>
                          <td class="flex items-center gap-2" style="width: 50%;">
                            <span class="text-2xl">üìà</span>
                            <span class="text-sm font-bold text-slate-800 dark:text-slate-200">M√∫ltiplo PER</span>
                            <svg class="w-4 h-4 text-slate-400 group-open:rotate-180 transition-transform ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                          </td>
                          <td class="text-right text-sm font-bold text-purple-600 dark:text-purple-400 pr-6" style="width: 25%;">${fmtCurrency(module.pPerObj)}</td>
                          <td class="text-center" style="width: 25%;">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-bold bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300">20%</span>
                          </td>
                        </tr>
                      </table>
                    </summary>
                    
                    <div class="px-6 py-6 bg-slate-50 dark:bg-slate-900/50 space-y-4">
                      ${module3 ? `
                        <h4 class="text-sm font-bold text-slate-700 dark:text-slate-300 uppercase mb-3">Valoraci√≥n por M√∫ltiplo PER</h4>
                        
                        <!-- Formula Card -->
                        <div class="bg-purple-50 dark:bg-purple-900/20 border border-purple-200 dark:border-purple-800 rounded-lg p-4">
                          <p class="text-sm text-purple-900 dark:text-purple-100 font-mono mb-2">
                            <strong>F√≥rmula:</strong> EPS Base √ó PER Objetivo = Precio
                          </p>
                          <p class="text-sm text-purple-900 dark:text-purple-100 font-mono">
                            ${fmtCurrency(module3.epsBase)} √ó ${fmtNumber(module3.perObj, 1)}x = ${fmtCurrency(module.pPerObj)}
                          </p>
                        </div>

                        <!-- Conclusion -->
                        <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-4">
                          <p class="text-sm text-slate-700 dark:text-slate-300 leading-relaxed">
                            <strong>Valoraci√≥n basada en la capacidad de generaci√≥n de utilidades.</strong> El PER de ${fmtNumber(module3.perObj, 1)}x pondera la historia (${fmtNumber(module3.perHist, 1)}x) con el crecimiento proyectado (${fmtNumber(module3.perGrow, 1)}x).
                          </p>
                        </div>
                      ` : '<p class="text-sm text-slate-500">Datos de m√∫ltiplos PER no disponibles</p>'}
                    </div>
                  </details>
                </td>
              </tr>

              <!-- Item 3: M√∫ltiplo P/BV -->
              <tr>
                <td colspan="3" class="p-0">
                  <details class="group">
                    <summary class="px-6 py-4 cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-900/30 transition-colors">
                      <table class="w-full">
                        <tr>
                          <td class="flex items-center gap-2" style="width: 50%;">
                            <span class="text-2xl">üè¶</span>
                            <span class="text-sm font-bold text-slate-800 dark:text-slate-200">M√∫ltiplo P/BV</span>
                            <svg class="w-4 h-4 text-slate-400 group-open:rotate-180 transition-transform ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                          </td>
                          <td class="text-right text-sm font-bold text-pink-600 dark:text-pink-400 pr-6" style="width: 25%;">${fmtCurrency(module.pPbvObj)}</td>
                          <td class="text-center" style="width: 25%;">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-bold bg-pink-100 dark:bg-pink-900/30 text-pink-700 dark:text-pink-300">20%</span>
                          </td>
                        </tr>
                      </table>
                    </summary>
                    
                    <div class="px-6 py-6 bg-slate-50 dark:bg-slate-900/50 space-y-4">
                      ${module3 ? `
                        <h4 class="text-sm font-bold text-slate-700 dark:text-slate-300 uppercase mb-3">Valoraci√≥n por M√∫ltiplo P/BV</h4>
                        
                        <!-- Formula Card -->
                        <div class="bg-pink-50 dark:bg-pink-900/20 border border-pink-200 dark:border-pink-800 rounded-lg p-4">
                          <p class="text-sm text-pink-900 dark:text-pink-100 font-mono mb-2">
                            <strong>F√≥rmula:</strong> BVPS Base √ó P/BV Objetivo = Precio
                          </p>
                          <p class="text-sm text-pink-900 dark:text-pink-100 font-mono">
                            ${fmtCurrency(module3.bvpsBase)} √ó ${fmtNumber(module3.pbvObj, 2)}x = ${fmtCurrency(module.pPbvObj)}
                          </p>
                        </div>

                        <!-- Conclusion -->
                        <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-4">
                          <p class="text-sm text-slate-700 dark:text-slate-300 leading-relaxed">
                            <strong>Valoraci√≥n patrimonial ajustada por la rentabilidad (ROE) esperada.</strong> Este m√©todo valora la empresa seg√∫n su valor en libros multiplicado por la capacidad de generar retornos sobre el patrimonio.
                          </p>
                        </div>
                      ` : '<p class="text-sm text-slate-500">Datos de m√∫ltiplos P/BV no disponibles</p>'}
                    </div>
                  </details>
                </td>
              </tr>

              <!-- Item 4: Promedio Hist√≥rico -->
              <tr>
                <td colspan="3" class="p-0">
                  <details class="group">
                    <summary class="px-6 py-4 cursor-pointer hover:bg-slate-50 dark:hover:bg-slate-900/30 transition-colors">
                      <table class="w-full">
                        <tr>
                          <td class="flex items-center gap-2" style="width: 50%;">
                            <span class="text-2xl">üìä</span>
                            <span class="text-sm font-bold text-slate-800 dark:text-slate-200">Promedio Hist√≥rico</span>
                            <svg class="w-4 h-4 text-slate-400 group-open:rotate-180 transition-transform ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                          </td>
                          <td class="text-right text-sm font-bold text-amber-600 dark:text-amber-400 pr-6" style="width: 25%;">${fmtCurrency(module.pInternoPromedio)}</td>
                          <td class="text-center" style="width: 25%;">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-bold bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-300">20%</span>
                          </td>
                        </tr>
                      </table>
                    </summary>
                    
                    <div class="px-6 py-6 bg-slate-50 dark:bg-slate-900/50 space-y-4">
                      <h4 class="text-sm font-bold text-slate-700 dark:text-slate-300 uppercase mb-3">Comportamiento Hist√≥rico del Precio</h4>
                      
                      <!-- Components Breakdown -->
                      <div class="grid grid-cols-2 gap-4">
                        <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-4">
                          <p class="text-xs text-slate-500 dark:text-slate-400 mb-2">Precio v√≠a PER Hist√≥rico</p>
                          <p class="text-lg font-bold text-slate-800 dark:text-slate-200">${fmtCurrency(module.pPerHist || 0)}</p>
                          <p class="text-xs text-slate-500 dark:text-slate-400 mt-2">Basado en m√∫ltiplos hist√≥ricos de ganancias</p>
                        </div>
                        <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-lg p-4">
                          <p class="text-xs text-slate-500 dark:text-slate-400 mb-2">Precio v√≠a P/BV Hist√≥rico</p>
                          <p class="text-lg font-bold text-slate-800 dark:text-slate-200">${fmtCurrency(module.pPbvHist || 0)}</p>
                          <p class="text-xs text-slate-500 dark:text-slate-400 mt-2">Basado en m√∫ltiplos hist√≥ricos de valor libro</p>
                        </div>
                      </div>

                      <!-- Conclusion -->
                      <div class="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
                        <p class="text-sm text-amber-900 dark:text-amber-100 leading-relaxed">
                          <strong>Promedio de valoraciones hist√≥ricas.</strong> Este m√©todo proporciona un "piso" o nivel de soporte basado en c√≥mo el mercado ha valorado hist√≥ricamente esta acci√≥n.
                        </p>
                      </div>
                    </div>
                  </details>
                </td>
              </tr>

            </tbody>
          </table>
        </div>
      `;

        // ========== 2. BANNER DE PRECIO FINAL (MEJORADO) ==========
        const upsideColor = module.upside > 0 ? "text-emerald-500 dark:text-emerald-400" : "text-red-500 dark:text-red-400";

        const bannerHtml = `
        <div class="relative overflow-hidden bg-gradient-to-br from-blue-700 via-blue-600 to-blue-800 dark:from-blue-800 dark:via-blue-700 dark:to-blue-900 rounded-xl border-2 border-blue-500 dark:border-blue-600 p-4 mb-6 shadow-2xl">
          <!-- Decorative Background Icons -->
          <div class="absolute top-1 right-1 text-5xl opacity-10 select-none pointer-events-none">üéØ</div>
          <div class="absolute bottom-1 left-1 text-4xl opacity-10 select-none pointer-events-none">üíé</div>
          
          <div class="relative z-10 flex flex-col md:flex-row justify-between items-center gap-3">
            <!-- Left: Final Price -->
            <div class="text-center md:text-left flex-1">
              <div class="flex items-center gap-2 mb-1 justify-center md:justify-start">
                <span class="text-2xl">üéØ</span>
                <p class="text-xs font-black uppercase text-blue-100 tracking-widest">Precio Objetivo Final</p>
              </div>
              <p class="text-4xl font-black text-yellow-400 mb-1 tracking-tight drop-shadow-lg">${fmtCurrency(module.pFinal)}</p>
              <p class="text-xs text-blue-100 font-semibold">
                <span class="inline-flex items-center gap-1">
                  <span>üí∞</span>
                  <span>vs Precio Actual: ${fmtCurrency(module.precioActual)}</span>
                </span>
              </p>
            </div>
            
            <!-- Right: Upside -->
            <div class="text-center bg-white/10 dark:bg-black/20 backdrop-blur-sm rounded-lg p-3 border border-blue-400 dark:border-blue-500 shadow-lg">
              <div class="flex items-center gap-1 mb-1 justify-center">
                <span class="text-xl">${module.upside > 0 ? 'üìà' : 'üìâ'}</span>
                <p class="text-xs font-black uppercase text-blue-100 tracking-widest">Potencial</p>
              </div>
              <p class="text-3xl font-black ${upsideColor} tracking-tight drop-shadow-sm">${fmtPercent(module.upside)}</p>
              <p class="text-xs text-blue-100 mt-1 font-semibold">${module.upside > 0 ? 'Upside' : 'Downside'}</p>
            </div>
          </div>
        </div>
      `;



        // 4. Gr√°fico de Convergencia Temporal (Time to Value)
        // Usar timeToValue desde module (ya calculado con validaci√≥n estricta)
        const timeToValue = module.timeToValue;

        let timeToValueHTML = '';
        if (timeToValue && timeToValue.error) {
          // Mostrar error si gExplicita no est√° disponible
          timeToValueHTML = `
          <div class="break-before-page">
            <div class="bg-red-100 dark:bg-red-900/30 border-2 border-red-300 dark:border-red-700 rounded-xl p-6 mb-6">
              <div class="flex items-start gap-4">
                <div class="text-4xl">‚ö†Ô∏è</div>
                <div class="flex-1">
                  <h4 class="text-lg font-bold text-red-700 dark:text-red-300 mb-2">Error en An√°lisis de Convergencia</h4>
                  <p class="text-sm text-red-600 dark:text-red-400 leading-relaxed">${timeToValue.error}</p>
                  <p class="text-xs text-red-500 dark:text-red-500 mt-3 italic">
                    üí° Sugerencia: Verifique que el M√≥dulo 2 (DCF) se haya calculado correctamente y que los datos de entrada sean v√°lidos.
                  </p>
                </div>
              </div>
            </div>
          </div>
        `;
        } else if (timeToValue) {
          const ttv = timeToValue;
          const conclusionColorClass = ttv.conclusionType === 'excellent' ? 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-300 dark:border-emerald-700' :
            ttv.conclusionType === 'good' ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-300 dark:border-blue-700' :
              ttv.conclusionType === 'warning' ? 'bg-amber-50 dark:bg-amber-900/20 border-amber-300 dark:border-amber-700' :
                'bg-red-50 dark:bg-red-900/20 border-red-300 dark:border-red-700';

          timeToValueHTML = `
          <div class="break-before-page">
            <div class="bg-white dark:bg-slate-800 rounded-xl p-5 border border-slate-200 dark:border-slate-700 mb-6">
              <h4 class="text-sm font-bold text-slate-700 dark:text-slate-300 uppercase mb-3 flex items-center gap-2">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                Convergencia Temporal de Valor
              </h4>
              <p class="text-xs text-slate-500 dark:text-slate-400 mb-3">¬øCu√°ntos a√±os tarda el valor fundamental en alcanzar el precio de mercado?</p>
              
              <!-- Canvas para Chart.js -->
              <div class="mb-4">
                <canvas id="chart-module8-ttv" class="w-full" style="height: 300px;"></canvas>
              </div>
              
              <!-- Nota de tope del 20% si se aplic√≥ -->
              ${ttv.growthRateCapped ? `
                <div class="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-700 rounded-lg p-3 mb-4">
                  <p class="text-xs text-amber-700 dark:text-amber-300 flex items-start gap-2">
                    <span class="text-lg">‚ö†Ô∏è</span>
                    <span><strong>Nota de Seguridad:</strong> La tasa de crecimiento original (${fmtPercent(ttv.originalGrowthRate)}) excede el l√≠mite prudencial. Se ha limitado a un m√°ximo del <strong>20% anual</strong> para evitar proyecciones excesivamente optimistas.</span>
                  </p>
                </div>
              ` : ''}
              
              <!-- Tarjeta de Conclusi√≥n -->
              <div class="border-2 ${conclusionColorClass} rounded-lg p-4">
                <p class="text-sm leading-relaxed">${ttv.conclusion}</p>
                ${ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 ? `
                  <div class="mt-3 pt-3 border-t border-slate-200 dark:border-slate-600 grid grid-cols-3 gap-2 text-center text-xs">
                    <div>
                      <p class="text-slate-500 dark:text-slate-400 uppercase mb-1">Valor Hoy</p>
                      <p class="font-bold">${fmtCurrency(ttv.precioDCF)}</p>
                    </div>
                    <div>
                      <p class="text-slate-500 dark:text-slate-400 uppercase mb-1">Precio Mercado</p>
                      <p class="font-bold text-red-600 dark:text-red-400">${fmtCurrency(ttv.precioMercado)}</p>
                    </div>
                    <div>
                      <p class="text-slate-500 dark:text-slate-400 uppercase mb-1">A√±os Convergencia</p>
                      <p class="font-bold text-blue-600 dark:text-blue-400">${ttv.yearsToCatchUp === 0 ? 'Hoy' : ttv.yearsToCatchUp + ' a√±os'}</p>
                    </div>
                  </div>
                ` : ''}
              </div>
            </div>
          </div>
        `;
        } else {
          timeToValueHTML = `
          <div class="bg-slate-100 dark:bg-slate-800 rounded-xl p-5 border border-slate-200 dark:border-slate-700 text-center text-slate-500 mb-6">
            <p>An√°lisis de convergencia temporal no disponible</p>
            <p class="text-xs mt-2">Falta precio de mercado o par√°metros de crecimiento</p>
          </div>
        `;
        }

        // ========== 4. PANEL DE RECOMENDACI√ìN ESTRAT√âGICA (NUEVO) ==========
        // L√≥gica de Sem√°foro con Buffer del 10%
        let recommendationColor, recommendationBorder, holdersMessage, potentialMessage, recommendationIcon;

        if (module.upside > 0.10) {
          // CASO 1: SUBVALUADA (Upside > +10%)
          recommendationColor = 'bg-emerald-50 dark:bg-emerald-900/20';
          recommendationBorder = 'border-emerald-300 dark:border-emerald-700';
          recommendationIcon = '‚úÖ';
          holdersMessage = `
          <div class="flex items-start gap-3">
            <span class="text-3xl">üõ°Ô∏è</span>
            <div>
              <h5 class="text-sm font-black uppercase text-emerald-700 dark:text-emerald-300 mb-2">MANTENER / ACUMULAR</h5>
              <p class="text-sm text-emerald-700 dark:text-emerald-300 leading-relaxed">
                El mercado est√° infravalorando su activo. <strong>No venda ahora</strong>; los fundamentales sugieren un valor superior al precio actual.
              </p>
            </div>
          </div>
        `;
          potentialMessage = `
          <div class="flex items-start gap-3">
            <span class="text-3xl">üõí</span>
            <div>
              <h5 class="text-sm font-black uppercase text-emerald-700 dark:text-emerald-300 mb-2">COMPRAR</h5>
              <p class="text-sm text-emerald-700 dark:text-emerald-300 leading-relaxed">
                Existe un <strong>Margen de Seguridad atractivo</strong> (${fmtPercent(module.upside)}). Es un punto de entrada racional basado en valor.
              </p>
            </div>
          </div>
        `;
        } else if (module.upside < -0.10) {
          // CASO 2: SOBREVALORADA (Upside < -10%)
          recommendationColor = 'bg-rose-50 dark:bg-rose-900/20';
          recommendationBorder = 'border-rose-300 dark:border-rose-700';
          recommendationIcon = '‚õî';
          holdersMessage = `
          <div class="flex items-start gap-3">
            <span class="text-3xl">üí∞</span>
            <div>
              <h5 class="text-sm font-black uppercase text-rose-700 dark:text-rose-300 mb-2">VENDER / REDUCIR</h5>
              <p class="text-sm text-rose-700 dark:text-rose-300 leading-relaxed">
                El precio de mercado <strong>supera significativamente</strong> el valor fundamental. Considere tomar ganancias.
              </p>
            </div>
          </div>
        `;
          potentialMessage = `
          <div class="flex items-start gap-3">
            <span class="text-3xl">‚õî</span>
            <div>
              <h5 class="text-sm font-black uppercase text-rose-700 dark:text-rose-300 mb-2">NO COMPRAR</h5>
              <p class="text-sm text-rose-700 dark:text-rose-300 leading-relaxed">
                El precio es <strong>excesivo</strong> respecto a los fundamentos (${fmtPercent(module.upside)}). Espere una correcci√≥n para entrar a un valor justo.
              </p>
            </div>
          </div>
        `;
        } else {
          // CASO 3: ZONA NEUTRA (-10% a +10%)
          recommendationColor = 'bg-slate-50 dark:bg-slate-900/20';
          recommendationBorder = 'border-slate-300 dark:border-slate-700';
          recommendationIcon = '‚öñÔ∏è';
          holdersMessage = `
          <div class="flex items-start gap-3">
            <span class="text-3xl">‚úã</span>
            <div>
              <h5 class="text-sm font-black uppercase text-slate-700 dark:text-slate-300 mb-2">MANTENER</h5>
              <p class="text-sm text-slate-700 dark:text-slate-300 leading-relaxed">
                La valoraci√≥n es <strong>justa</strong>. Mantenga su posici√≥n si busca exposici√≥n a largo plazo o dividendos.
              </p>
            </div>
          </div>
        `;
          potentialMessage = `
          <div class="flex items-start gap-3">
            <span class="text-3xl">üëÄ</span>
            <div>
              <h5 class="text-sm font-black uppercase text-slate-700 dark:text-slate-300 mb-2">OBSERVAR</h5>
              <p class="text-sm text-slate-700 dark:text-slate-300 leading-relaxed">
                No hay descuento suficiente (${fmtPercent(module.upside)}). Monitoree la acci√≥n esperando volatilidad para un mejor precio.
              </p>
            </div>
          </div>
        `;
        }

        const recommendationPanelHtml = `
        <div class="mb-6">
          <div class="flex items-center gap-3 mb-4">
            <span class="text-4xl">${recommendationIcon}</span>
            <h3 class="text-lg font-black uppercase text-slate-700 dark:text-slate-300 tracking-wide">Recomendaci√≥n Estrat√©gica (Corto Plazo)</h3>
          </div>
          <div class="grid grid-cols-1 grid-cols-1 gap-4">
            <!-- Tarjeta Izquierda: Tenedores Actuales -->
            <div class="${recommendationColor} border-2 ${recommendationBorder} rounded-xl p-5 shadow-md">
              <p class="text-xs font-black uppercase text-slate-500 dark:text-slate-400 tracking-wider mb-4 text-center">ACTUALES TENEDORES DE ACCIONES</p>
              ${holdersMessage}
            </div>
            
            <!-- Tarjeta Derecha: Potenciales Inversores -->
            <div class="${recommendationColor} border-2 ${recommendationBorder} rounded-xl p-5 shadow-md">
              <p class="text-xs font-black uppercase text-slate-500 dark:text-slate-400 tracking-wider mb-4 text-center">POTENCIALES INVERSORES</p>
              ${potentialMessage}
            </div>
          </div>
        </div>
      `;

        // ========== 5. ESTRATEGIA DE MEDIANO Y LARGO PLAZO (NUEVO) ==========
        let longTermStrategyColor, longTermStrategyBorder, longTermStrategyIcon, longTermStrategyTitle, longTermStrategyMessage;

        if (module.score > 60 && module.upside < 0) {
          // CASO A: Buena Calidad pero Cara (Growth/Quality Long)
          longTermStrategyColor = 'bg-blue-50 dark:bg-blue-900/20';
          longTermStrategyBorder = 'border-blue-300 dark:border-blue-700';
          longTermStrategyIcon = '‚è≥';
          longTermStrategyTitle = 'WATCHLIST (ESPERAR CORRECCI√ìN)';
          const correctionPercent = Math.abs(module.upside * 100).toFixed(0);
          longTermStrategyMessage = `La empresa proyecta crecimiento y tiene buenos fundamentales (Score: ${module.score}/100), pero el precio actual descuenta un escenario demasiado optimista. La recomendaci√≥n t√°ctica es <strong>esperar una correcci√≥n de aprox. ${correctionPercent}%</strong> (hacia los <strong>${fmtCurrency(module.pFinal)}</strong>) para tomar posiciones pensando en una recuperaci√≥n a largo plazo.`;
        } else if (module.score < 50) {
          // CASO B: Mala Calidad / Riesgo Fundamental (Value Trap)
          longTermStrategyColor = 'bg-red-50 dark:bg-red-900/20';
          longTermStrategyBorder = 'border-red-300 dark:border-red-700';
          longTermStrategyIcon = '‚õî';
          longTermStrategyTitle = 'EVITAR (RIESGO ESTRUCTURAL)';
          longTermStrategyMessage = `Las proyecciones a largo plazo y la calidad actual del negocio presentan <strong>riesgos elevados</strong> (Score: ${module.score}/100). Independiente de si el precio cae, los fundamentales no ofrecen la seguridad necesaria para una posici√≥n de largo plazo (Buy & Hold). Se sugiere <strong>buscar compa√±√≠as con bases m√°s s√≥lidas</strong>.`;
        } else {
          // CASO C: Oportunidad Integral (Value Buy)
          longTermStrategyColor = 'bg-emerald-50 dark:bg-emerald-900/20';
          longTermStrategyBorder = 'border-emerald-300 dark:border-emerald-700';
          longTermStrategyIcon = 'üíé';
          longTermStrategyTitle = 'INVERSI√ìN DE VALOR (LONG)';
          longTermStrategyMessage = `Coinciden la <strong>calidad fundamental a largo plazo</strong> (Score: ${module.score}/100) con un <strong>precio de entrada atractivo hoy</strong> (Upside: ${fmtPercent(module.upside)}). Es un escenario ideal para construir una posici√≥n pensando en la materializaci√≥n del valor intr√≠nseco en el tiempo.`;
        }

        const longTermStrategyHtml = `
        <div class="${longTermStrategyColor} border-2 ${longTermStrategyBorder} rounded-xl p-6 shadow-lg">
          <div class="flex items-start gap-4">
            <span class="text-5xl flex-shrink-0">${longTermStrategyIcon}</span>
            <div class="flex-1">
              <div class="flex items-center gap-3 mb-3">
                <h3 class="text-base font-black uppercase tracking-wide text-orange-600 dark:text-orange-400">
                  Estrategia de Mediano y Largo Plazo
                </h3>
              </div>
              <h4 class="text-lg font-black mb-3 text-orange-700 dark:text-orange-300">
                ${longTermStrategyTitle}
              </h4>
              <p class="text-sm leading-relaxed text-orange-800 dark:text-orange-200">
                ${longTermStrategyMessage}
              </p>
            </div>
          </div>
        </div>
      `;

        // Ensamblar HTML final con nuevo orden
        container.innerHTML = breakdownTableHtml + bannerHtml + timeToValueHTML + recommendationPanelHtml + longTermStrategyHtml;

        // Renderizar gr√°fico de Time to Value si existe
        if (timeToValue && !timeToValue.error) {
          setTimeout(() => {
            const canvas = document.getElementById('chart-module8-ttv');
            if (canvas) {
              const ttv = timeToValue;
              const ctx = canvas.getContext('2d');

              // CRITICAL: Destroy existing chart to prevent canvas conflicts
              const existingChart = Chart.getChart(canvas);
              if (existingChart) {
                existingChart.destroy();
                console.log('[MODULE 8] Destroyed existing chart');
              }

              const years = window.financialData?.years || [];

              // Preparar datos - Solo hasta convergencia o m√°ximo calculado
              const maxYearsToShow = ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0
                ? Math.min(ttv.yearsToCatchUp + 2, ttv.years.length)
                : ttv.years.length;

              const yearsToShow = ttv.years.slice(0, maxYearsToShow);
              const valuesToShow = ttv.values.slice(0, maxYearsToShow);

              // Usar a√±os calendario reales
              const currentYear = new Date().getFullYear();
              const labels = yearsToShow.map((y) => currentYear + y);
              const marketPriceLine = new Array(yearsToShow.length).fill(ttv.precioMercado);

              const chart = new Chart(ctx, {
                type: 'line',
                data: {
                  labels,
                  datasets: [
                    {
                      label: 'Precio Mercado Objetivo (Hoy)',
                      data: marketPriceLine,
                      borderColor: '#ef4444',
                      backgroundColor: 'transparent',
                      borderWidth: 2,
                      borderDash: [8, 4],
                      pointRadius: 0,
                      fill: false,
                      tension: 0,
                      datalabels: {
                        display: function (context) {
                          return context.dataIndex === 0;
                        },
                        align: 'top',
                        anchor: 'start',
                        backgroundColor: 'rgba(255, 255, 255, 0.9)',
                        borderRadius: 4,
                        color: '#dc2626',
                        font: { weight: 'bold', size: 13 },
                        formatter: function (value) {
                          return '$' + new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(value);
                        },
                        padding: 6
                      }
                    },
                    {
                      label: 'Valor Fundamental',
                      data: valuesToShow,
                      borderColor: '#3b82f6',
                      backgroundColor: 'rgba(59, 130, 246, 0.1)',
                      borderWidth: 3,
                      pointRadius: (context) => {
                        if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                          return 8;
                        }
                        return 5;
                      },
                      pointBackgroundColor: (context) => {
                        if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                          return '#10b981';
                        }
                        return '#3b82f6';
                      },
                      pointBorderColor: '#fff',
                      pointBorderWidth: 2,
                      fill: true,
                      tension: 0.3,
                      datalabels: {
                        display: true,
                        align: 'top',
                        anchor: 'end',
                        backgroundColor: function (context) {
                          if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                            return 'rgba(16, 185, 129, 0.9)';
                          }
                          return 'rgba(255, 255, 255, 0.8)';
                        },
                        borderRadius: 4,
                        color: function (context) {
                          if (ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 && context.dataIndex === ttv.yearsToCatchUp) {
                            return '#ffffff';
                          }
                          return '#1e40af';
                        },
                        font: { weight: 'bold', size: 11 },
                        formatter: function (value) {
                          return '$' + new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(value);
                        },
                        padding: 4
                      }
                    }
                  ]
                },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  interaction: {
                    mode: 'index',
                    intersect: false,
                  },
                  plugins: {
                    datalabels: {
                      display: true
                    },
                    legend: {
                      display: true,
                      position: 'top',
                      labels: {
                        color: '#64748b',
                        usePointStyle: true,
                        padding: 15,
                        font: {
                          size: 12,
                          weight: 'bold'
                        }
                      }
                    },
                    tooltip: {
                      backgroundColor: 'rgba(0, 0, 0, 0.8)',
                      padding: 12,
                      titleFont: {
                        size: 14,
                        weight: 'bold'
                      },
                      bodyFont: {
                        size: 13
                      },
                      callbacks: {
                        label: function (context) {
                          const label = context.dataset.label || '';
                          const value = new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(context.parsed.y);
                          if (context.datasetIndex === 0) {
                            return label + ': $' + value + ' (Precio que pagas hoy)';
                          }
                          return label + ': $' + value;
                        },
                        afterLabel: function (context) {
                          if (context.datasetIndex === 1 && ttv.yearsToCatchUp !== null && context.dataIndex === ttv.yearsToCatchUp) {
                            return 'üéØ Punto de Convergencia';
                          }
                          return '';
                        }
                      }
                    },
                    annotation: ttv.yearsToCatchUp !== null && ttv.yearsToCatchUp > 0 ? {
                      annotations: {
                        convergenceLine: {
                          type: 'line',
                          xMin: ttv.yearsToCatchUp,
                          xMax: ttv.yearsToCatchUp,
                          borderColor: '#10b981',
                          borderWidth: 3,
                          borderDash: [10, 5],
                          label: {
                            display: true,
                            content: 'üéØ Convergencia',
                            position: 'start',
                            backgroundColor: 'rgba(16, 185, 129, 0.9)',
                            color: '#ffffff',
                            font: {
                              weight: 'bold',
                              size: 12
                            },
                            padding: 6,
                            borderRadius: 4
                          }
                        },
                        convergencePoint: {
                          type: 'point',
                          xValue: ttv.yearsToCatchUp,
                          yValue: ttv.precioMercado,
                          backgroundColor: '#10b981',
                          borderColor: '#ffffff',
                          borderWidth: 3,
                          radius: 10
                        }
                      }
                    } : {}
                  },
                  scales: {
                    x: {
                      title: {
                        display: true,
                        text: 'A√±o',
                        color: '#64748b',
                        font: {
                          size: 12,
                          weight: 'bold'
                        }
                      },
                      ticks: {
                        color: '#94a3b8',
                        font: {
                          size: 11
                        }
                      },
                      grid: {
                        color: 'rgba(148, 163, 184, 0.1)',
                        drawBorder: false
                      }
                    },
                    y: {
                      title: {
                        display: true,
                        text: 'Valor (CLP)',
                        color: '#64748b',
                        font: {
                          size: 12,
                          weight: 'bold'
                        }
                      },
                      ticks: {
                        color: '#94a3b8',
                        font: {
                          size: 11
                        },
                        callback: (val) => '$' + new Intl.NumberFormat('es-CL', { maximumFractionDigits: 0 }).format(val)
                      },
                      grid: {
                        color: 'rgba(148, 163, 184, 0.1)',
                        drawBorder: false
                      }
                    }
                  }
                }
              });
              chartRegistry.push(chart);
            }
          }, 100);
        }
      } catch (err) {
        console.error("Critical Render Error in Module 8:", err);
        container.innerHTML = `
        <div class="bg-red-50 dark:bg-red-900/30 border-2 border-red-200 dark:border-red-800 rounded-xl p-6 text-center">
           <h3 class="text-lg font-bold text-red-700 dark:text-red-300 mb-2">Error de Visualizaci√≥n</h3>
           <p class="text-sm text-red-600 dark:text-red-400">Ocurri√≥ un problema al dibujar el M√≥dulo 8.</p>
           <p class="text-xs font-mono text-red-500 mt-2 p-2 bg-white/50 rounded">${err.message}</p>
        </div>
      `;
      }
    }

    function renderModule8Debug(debug = {}) {
      const inputs = debug.inputs || {};
      const weights = debug.weights || {};
      const components = debug.components || {};
      const labels = ['DCF', 'PER obj', 'P/BV obj', 'Interno (prom.)'];
      const weightsArr = [weights.dcf, weights.perObj, weights.pbvObj, weights.internos];
      const basesArr = [inputs.pDCF, inputs.pPerObj, inputs.pPbvObj, inputs.pInternoPromedio];
      const contribsArr = [components.dcf, components.perObj, components.pbvObj, components.internos];
      const breakdown = weightsArr.map((peso, idx) => ({
        label: labels[idx],
        peso,
        base: basesArr[idx],
        contrib: contribsArr[idx],
      }));

      return `
        <div class="mt-6 bg-slate-100 dark:bg-slate-900/60 rounded-xl p-4">
          <p class="text-xs uppercase text-slate-400 font-semibold mb-2">Ponderaciones y aportes</p>
          <table class="min-w-full text-sm">
            <thead>
              <tr class="text-left text-slate-500 text-xs">
                <th>M√©todo</th>
                <th>Precio base</th>
                <th>Peso</th>
                <th>Aporte</th>
              </tr>
            </thead>
            <tbody>
              ${breakdown
          .map(
            ({ label, peso, base, contrib }) => `
                    <tr>
                      <td class="py-1 text-slate-500">${label}</td>
                      <td class="py-1">${fmtCurrency(base ?? null)}</td>
                      <td class="py-1">${fmtPercent(peso ?? null)}</td>
                      <td class="py-1 font-semibold">${fmtCurrency(contrib ?? null)}</td>
                    </tr>`
          )
          .join('')}
            </tbody>
          </table>
        </div>`;
    }

    function runModule9Benchmark(fd, m1, m2, m5, m7) {
      const ind = fd.industry || {};
      const metrics = [];

      // Helper to evaluate status
      const evaluate = (companyVal, industryVal, safeThreshold, higherIsBetter = true) => {
        if (companyVal === null || companyVal === undefined || Number.isNaN(companyVal)) return 'no_data';
        if (industryVal === null || industryVal === undefined || Number.isNaN(industryVal)) return 'neutral';

        const better = higherIsBetter ? companyVal > industryVal : companyVal < industryVal;
        if (better) return 'good'; // GREEN: Better than industry

        // If worse than industry, check if it's still "Safe/Good" in absolute terms
        const safe = higherIsBetter ? companyVal > safeThreshold : companyVal < safeThreshold;
        if (safe) return 'warning'; // YELLOW: Worse than ind but safe

        return 'bad'; // RED: Worse than ind and unsafe
      };

      // 1. ROE (Rentabilidad)
      const roeComp = m1.estructural?.roePromedioNormalizado ?? null;
      const roeInd = ind.roe ?? null;
      metrics.push({
        name: 'ROE Estructural',
        company: roeComp,
        industry: roeInd,
        format: 'percent',
        status: evaluate(roeComp, roeInd, 0.15, true)
      });

      // 2. Margen Operativo
      const margComp = m1.estructural?.margenOperacionalPromedioNormalizado ?? null;
      const margInd = ind.margenOperativo ?? null;
      metrics.push({
        name: 'Margen Operativo',
        company: margComp,
        industry: margInd,
        format: 'percent',
        status: evaluate(margComp, margInd, 0.10, true)
      });

      // 3. Deuda/Patrimonio
      const deComp = m5.deudaSobrePatrimonio ?? null;
      const deInd = ind.deudaPatrimonio ?? null;
      metrics.push({
        name: 'Deuda / Patrimonio',
        company: deComp,
        industry: deInd,
        format: 'number',
        status: evaluate(deComp, deInd, 1.5, false) // Lower is better
      });

      // 4. CAGR Ventas
      // FIX: m7.cagrs.ventas ahora es un objeto { value, startYear, endYear, error }
      // Extracci√≥n segura que soporta n√∫mero simple u objeto complejo
      const getCagrValue = (cagrObj) => (cagrObj && typeof cagrObj === 'object') ? cagrObj.value : cagrObj;
      const cagrComp = getCagrValue(m7.cagrs?.ventas);
      const cagrInd = ind.cagrVentas ?? null;
      metrics.push({
        name: 'CAGR Ventas (5A)',
        company: cagrComp,
        industry: cagrInd,
        format: 'percent',
        status: evaluate(cagrComp, cagrInd, 0.05, true)
      });

      // 5. PER (Actual/Promedio vs Industria)
      // CORRECCI√ìN: Usar m2.perActual que tiene normalizaci√≥n correcta cuando hay p√©rdidas
      const perComp = m2?.perActual ?? m1.actual?.perReal ?? null;
      const perInd = ind.per ?? null;

      // DEBUG TEMPORAL: Verificar de d√≥nde viene perComp
      console.log('üîç [Benchmark] Calculando PER:');
      console.log('   m2?.perActual:', m2?.perActual);
      console.log('   m1.actual?.perReal:', m1.actual?.perReal);
      console.log('   ‚Üí perComp final:', perComp);
      console.log('   ‚Üí perInd:', perInd);


      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // DEBUG: PER & P/BV - RASTREO COMPLETO DE VALORES
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üîç DEBUG BENCHMARK: PER & P/BV');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üìä EMPRESA - Inputs para c√°lculo PER:');
      console.log('   ‚Ä¢ Precio Actual CLP (fd.datos):', fd.datos?.precioActualCLP);
      console.log('   ‚Ä¢ EPS CLP (m1.actual.epsCLP):', m1.actual?.epsCLP);
      console.log('   ‚Ä¢ PER Calculado (m1.actual.perReal):', m1.actual?.perReal);
      console.log('   ‚Üí PER usado en Benchmark:', perComp);
      console.log('');
      console.log('üìä EMPRESA - Inputs para c√°lculo P/BV:');
      console.log('   ‚Ä¢ Precio Actual CLP:', fd.datos?.precioActualCLP);
      console.log('   ‚Ä¢ BVPS CLP (m1.actual.bvpsCLP):', m1.actual?.bvpsCLP);
      console.log('   ‚Ä¢ P/BV Calculado (m1.actual.pbvReal):', m1.actual?.pbvReal);
      console.log('   ‚Üí P/BV usado en Benchmark:', m1.actual?.pbvReal ?? null);
      console.log('');
      console.log('üè≠ INDUSTRIA - Valores extra√≠dos de Excel (pesta√±a RATIOS):');
      console.log('   ‚Ä¢ PER Industria (ind.per):', ind.per);
      console.log('   ‚Ä¢ P/BV Industria (ind.pbv):', ind.pbv);
      console.log('   ‚Ä¢ ROE Industria (ind.roe):', ind.roe);
      console.log('   ‚Ä¢ Margen Op Industria (ind.margenOperativo):', ind.margenOperativo);
      console.log('   ‚Ä¢ CAGR Ventas Industria (ind.cagrVentas):', ind.cagrVentas);
      console.log('');
      console.log('üìã Objeto Industry completo:', JSON.stringify(ind, null, 2));
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

      metrics.push({
        name: 'PER (Actual)',
        company: perComp,
        industry: perInd,
        format: 'number',
        status: evaluate(perComp, perInd, 25, false)
      });

      // 6. PBV
      // CORRECCI√ìN: Usar m2.pbvActual que tiene c√°lculo correcto
      const pbvComp = m2?.pbvActual ?? m1.actual?.pbvReal ?? null;
      const pbvInd = ind.pbv ?? null;

      // DEBUG TEMPORAL: Verificar de d√≥nde viene pbvComp
      console.log('üîç [Benchmark] Calculando P/BV:');
      console.log('   m2?.pbvActual:', m2?.pbvActual);
      console.log('   m1.actual?.pbvReal:', m1.actual?.pbvReal);
      console.log('   ‚Üí pbvComp final:', pbvComp);
      console.log('   ‚Üí pbvInd:', pbvInd);

      metrics.push({
        name: 'P/BV (Actual)',
        company: pbvComp,
        industry: pbvInd,
        format: 'number',
        status: evaluate(pbvComp, pbvInd, 3, false)
      });

      // 7. Liquidez
      const liqComp = m1.actual?.liquidezCorriente ?? null;
      const liqInd = ind.liquidez ?? null;
      metrics.push({
        name: 'Liquidez (Test √Åcido)',
        company: liqComp,
        industry: liqInd,
        format: 'number',
        status: evaluate(liqComp, liqInd, 1.0, true)
      });

      // ============================================
      // FUNCI√ìN DE DIAGN√ìSTICO: Posicionamiento Competitivo
      // ============================================

      function generateBenchmarkConclusion(metrics, valRoe, valVentas, valIndVentas) {
        // 1. Obtener M√©tricas Clave para status relativo
        const getMetric = (name) => metrics.find(m => m.name === name);

        const roeMetric = getMetric('ROE Estructural');
        const margenMetric = getMetric('Margen Operativo');
        const cagrMetric = getMetric('CAGR Ventas (5A)');
        const perMetric = getMetric('PER (Actual)');
        const deudaMetric = getMetric('Deuda / Patrimonio');

        // Valores Absolutos - Usamos los pasados expl√≠citamente (Decimals expected: 0.15 = 15%)
        // Si no vienen definidos, fallback a parseo (Safety) o 0
        // Nota: Asumimos que val* vienen como decimales desde el runner.

        // Scores Relativos (Comparaci√≥n simple: ¬øGana o Pierde?)
        const winsQuality = (roeMetric?.status === 'good' || roeMetric?.status === 'neutral') &&
          (margenMetric?.status === 'good' || margenMetric?.status === 'neutral');

        const winsValuation = perMetric?.status === 'good'; // Est√° m√°s barata
        const winsGrowth = cagrMetric?.status === 'good';   // Crece m√°s

        // 2. √ÅRBOL DE DECISI√ìN (Priority Filters)

        // FILTRO 1: "FALSA CALIDAD" (Eficiencia Defensiva en Contracci√≥n)
        // Condici√≥n: Gana Calidad pero se contrae dr√°sticamente (< -5%) o el retorno es pobre absoluto (< 8%)
        if (winsQuality && (valVentas < -0.05 || valRoe < 0.08)) {
          return {
            title: "üõ°Ô∏è Eficiencia Defensiva (En Contracci√≥n)",
            message: `La empresa muestra mejores m√°rgenes y retornos que el promedio de su industria, lo cual destaca su gesti√≥n operativa. Sin embargo, no clasifica como 'Premium' porque su negocio se est√° achicando dr√°sticamente (Ventas <strong>${fmtPercent(valVentas)}</strong>) o su retorno absoluto es bajo (ROE <strong>${fmtPercent(valRoe)}</strong>). Es el 'mejor de la clase' en un entorno dif√≠cil, pero est√° perdiendo tama√±o.`,
            type: "warning", // Warning porque contracci√≥n es riesgo estructural
            icon: "üõ°Ô∏è"
          };
        }

        // FILTRO 2: "L√çDER REAL" (Premium)
        // Condici√≥n: Gana Calidad Y Buenos fundamentales absolutos (ROE > 12%, Crecimiento Positivo)
        if (winsQuality && valRoe > 0.12 && valVentas > 0) {
          return {
            title: "üåü L√≠der de Calidad (Premium)",
            message: "Dominante. Supera a su industria en calidad y rentabilidad con fundamentales absolutos s√≥lidos. Es el benchmark de excelencia del sector que justifica una prima de valoraci√≥n.",
            type: "excellent",
            icon: "üåü"
          };
        }

        // FILTRO 3: "TRAMPA DE VALOR RELATIVA" (Descuento por falta de Competitividad)
        // Condici√≥n: Gana Valoraci√≥n (Barata) pero crece mucho menos que la industria (> 5% gap)
        const growthGap = (valIndVentas || 0) - (valVentas || 0);
        if (winsValuation && !winsGrowth && growthGap > 0.05) {
          return {
            title: "‚ö†Ô∏è Descuento por P√©rdida de Competitividad",
            message: `La acci√≥n cotiza con descuento (m√∫ltiplos m√°s bajos que la industria), pero esto parece justificado. Mientras la industria crece al <strong>${fmtPercent(valIndVentas)}</strong>, la empresa crece al <strong>${fmtPercent(valVentas)}</strong>. El mercado castiga esta p√©rdida de relevancia/cuota.`,
            type: "warning",
            icon: "‚ö†Ô∏è"
          };
        }

        // FILTRO 4: REZAGADA (Pierde en todo)
        if (!winsQuality && !winsGrowth) {
          return {
            title: "üìâ REZAGADA COMPETITIVA",
            message: "Posici√≥n competitiva d√©bil. Es menos rentable y crece menos que sus pares. Riesgo de p√©rdida de relevancia en el sector.",
            type: "bad",
            icon: "üìâ"
          };
        }

        // FILTRO 5: OPORTUNIDAD VALUE (Standard)
        const safeDebt = deudaMetric?.status === 'good';
        if (winsValuation && !winsGrowth && safeDebt) {
          return {
            title: "üíé OPORTUNIDAD DE VALOR (VALUE PLAY)",
            message: "M√°s barata y segura que la industria, aunque crece menos. Es una compra defensiva cl√°sica: s√≥lidos fundamentales y bajo precio compensan la falta de expansi√≥n agresiva.",
            type: "good",
            icon: "üíé"
          };
        }

        // DEFAULT: MIXTA
        return {
          title: "üìä POSICI√ìN COMPETITIVA MIXTA",
          message: "La empresa muestra fortalezas y debilidades balanceadas frente a la industria. No destaca claramente como l√≠der ni como rezagada cr√≠tica.",
          type: "neutral",
          icon: "üìä"
        };
      }

      // Generar conclusi√≥n
      // 1. Extraer valores clave de forma segura antes de llamar a la conclusi√≥n
      const getVal = (keyword) => {
        const m = metrics.find(x => x.name.includes(keyword));
        // Si el valor es un objeto (caso CAGR), extraer .value, si no, usar directo.
        let val = m ? m.company : null;
        if (val && typeof val === 'object') val = val.value;
        return val;
      };
      const getInd = (keyword) => {
        const m = metrics.find(x => x.name.includes(keyword));
        // Si el valor es un objeto (caso CAGR), extraer .value
        let val = m ? m.industry : null;
        if (val && typeof val === 'object') val = val.value;
        return val;
      };

      const valRoe = getVal('ROE');
      const valVentas = getVal('Ventas'); // CAGR Ventas 
      const valIndVentas = getInd('Ventas');

      const conclusion = generateBenchmarkConclusion(metrics, valRoe, valVentas, valIndVentas);

      return { metrics, conclusion };
    }

    // ----------------- DATA RUNNERS -----------------
    function runAllModules(options) {
      moduleResults = {};
      // 1. Ratios (M√≥dulo 1)
      moduleResults.module1 = runModule1Ratios(financialData);
      // 2. DCF (M√≥dulo 2, interno mod0)
      moduleResults.module0 = runModule0DCF(financialData, options);

      // Multiples require module1 context
      // 3. Historical (M√≥dulo 3, interno mod2)
      moduleResults.module2 = runModule2Multiples(financialData, moduleResults.module1);

      // 4. Objective (M√≥dulo 4, interno mod3)
      moduleResults.module3 = runModule3MultiplesObj(financialData, moduleResults.module1, moduleResults.module2, moduleResults.module0.ke);

      // 5. Projections (M√≥dulo 5, interno mod4)
      moduleResults.module4 = runModule4Proyecciones(financialData, options);

      // 6. Solvency (M√≥dulo 6, interno mod5)
      moduleResults.module5 = runModule5Deuda(financialData);

      // 7. Efficiency (M√≥dulo 7, interno mod6)
      moduleResults.module6 = runModule6Eficiencia(financialData, moduleResults.module1);

      // 8. Growth (M√≥dulo 8, interno mod7)
      moduleResults.module7 = runModule7Crecimiento(financialData);

      // 9. Benchmark (NUEVO, M√≥dulo 9, interno modBenchmark)
      moduleResults.moduleBenchmark = runModule9Benchmark(financialData, moduleResults.module1, moduleResults.module2, moduleResults.module5, moduleResults.module7);

      // 10. Final Price (M√≥dulo 10, interno mod8)
      moduleResults.module8 = runModule8PrecioFinal(
        financialData,
        moduleResults.module0,
        moduleResults.module1,
        moduleResults.module2,
        moduleResults.module3,
        moduleResults.module4,
        moduleResults.module5,
        moduleResults.module6,
        moduleResults.module7
      );

      // 10. Yield & Opp Cost (M√≥dulo 9 - Yield, interno modYield)
      moduleResults.module9Yield = runModule9Yield(
        financialData,
        moduleResults.module1,
        moduleResults.module2,
        moduleResults.module8,
        moduleResults.module0 // <--- NUEVO: Pasamos el m√≥dulo DCF
      );

      renderExecutiveDashboard(moduleResults, financialData, options);
      renderResults(moduleResults);
    }

    // ===========================================
    // GENERADOR DE VEREDICTO DE CALIDAD (DYNAMIC VERDICT)
    // ===========================================
    function generateDynamicVerdict(results, m1) {
      // Mapeo seguro de resultados
      const mB = results.moduleBenchmark || {};
      const m5 = results.module5 || {}; // Deuda
      const m6 = results.module6 || {}; // Eficiencia
      const m7 = results.module7 || {}; // Crecimiento

      // 1. POSICIONAMIENTO
      const esSuperior = mB.conclusion?.type === 'excellent' || mB.conclusion?.type === 'good';
      const txtIndustria = esSuperior ? "Empresa superior a la industria" : "Negocio alineado al promedio";

      // 2. CONTEXTO (Excepcional vs Persistente) Y CAUSA
      const diagState = m1?.diagnosis?.stateCode || "";
      const esExcepcional = diagState.includes('CYCLICAL') ||
        diagState.includes('HEALTHY') ||
        (m1?.conclusionFinal || "").toUpperCase().includes("PUNTUAL");

      const txtContexto = esExcepcional ? "ante un tropiezo excepcional" : "ante un declive persistente";

      const causaRaw = m1?.diagnosis?.reason || "";
      // Solo si existe, par√©ntesis y min√∫sculas
      const txtCausa = causaRaw ? ` (${causaRaw.toLowerCase()})` : "";

      // 3. PILARES: OPERACI√ìN Y DEUDA
      // Operaci√≥n (M6)
      const esOpMala = m6.conclusion?.type === 'bad' || m6.conclusion?.type === 'warning';
      const txtOp = esOpMala ? "rotaci√≥n ineficiente" : "gesti√≥n de activos √°gil";

      // Deuda (M5): Bad/Warning O cobertura < 1.5
      // Buscar cobertura en ratioAnalysis
      const cobertura = m5.ratioAnalysis?.find(r => r.name === 'Cobertura Intereses')?.value ?? 100;
      // Regla estricta: bad/warning OR cobertura < 1.5
      const esDebtMala = (m5.conclusion?.type === 'bad' || m5.conclusion?.type === 'warning') || (cobertura < 1.5);
      const txtDebt = esDebtMala ? "un endeudamiento preocupante" : "finanzas s√≥lidas";

      // Conector Inteligente: distinta polaridad -> pero con, misma -> y
      const mismaPolaridad = (esOpMala === esDebtMala);
      const conector = mismaPolaridad ? "y" : "pero con";

      // 4. CRECIMIENTO (M7)
      // Regla: Ventas > 5% AND FCFE < 0 -> ventas suben pero ca√≠da caja
      // Ventas <= 0 -> contracci√≥n
      // Else -> expansi√≥n real
      const vtasVal = m7.cagrs?.ventas?.value ?? m7.cagrs?.ventas ?? 0;
      const fcfeVal = m7.cagrs?.fcfe?.value ?? m7.cagrs?.fcfe ?? 0;

      let txtGrowth = "una expansi√≥n real del valor";
      if (vtasVal > 0.05 && fcfeVal < 0) {
        txtGrowth = "un aumento de ventas pero con ca√≠da de caja";
      } else if (vtasVal <= 0) {
        txtGrowth = "una contracci√≥n de sus ingresos y valor";
      }

      // 5. FUTURO
      const txtFuturo = esExcepcional
        ? "deber√≠a recuperar su valor tras este ciclo"
        : "su viabilidad a largo plazo est√° comprometida";

      // ENSAMBLE FINAL
      // [Posicionamiento] [Contexto][ (Causa)]. Muestra [Operaci√≥n], [Conector] [Deuda]. Registra [Crecimiento], por lo que [Futuro].
      const finalSentence = `${txtIndustria} ${txtContexto}${txtCausa}. Muestra ${txtOp}, ${conector} ${txtDebt}. Registra ${txtGrowth}, por lo que ${txtFuturo}.`;

      return {
        text: finalSentence,
        status: esExcepcional ? 'exceptional' : 'persistent'
      };
    }

    // ============================================
    // EXECUTIVE DASHBOARD RENDERER (FINAL SUMMARY)
    // ============================================
    function renderExecutiveDashboard(results, fd, options = {}) {
      console.log("=== EXECUTING renderExecutiveDashboard V3 ===");
      const dbContainer = document.getElementById('executive-dashboard');
      if (!results || !results.module8) {
        dbContainer.classList.add('hidden');
        return;
      }
      dbContainer.classList.remove('hidden');

      // Robust EBIT Extraction
      let valEbit = 0;
      if (fd && fd.eerr && fd.years && fd.years.length > 0) {
        const lastYear = fd.years[fd.years.length - 1];
        if (fd.eerr.ebitUltimo !== undefined && fd.eerr.ebitUltimo !== null) {
          valEbit = fd.eerr.ebitUltimo;
        } else if (fd.eerr.ebit && fd.eerr.ebit[lastYear] !== undefined) {
          valEbit = fd.eerr.ebit[lastYear];
        }
      }

      // Robust Efficiency Extraction
      const mEffDebug = (results && results.module6) ? results.module6 : {};
      const lastEffDebug = (mEffDebug.tabla && mEffDebug.tabla.length > 0) ? mEffDebug.tabla[mEffDebug.tabla.length - 1] : {};
      const valRotActivos = lastEffDebug.rotActivos || 0;
      const valRotInventarios = lastEffDebug.rotInventarios || 0;
      const valRotKT = lastEffDebug.rotCapitalTrabajo || 0;

      // ------------------------------------------
      // 1. DATA EXTRACTION LAYER
      // ------------------------------------------
      const safeVal = (val, formatFn = fmtNumber, suffix = '', decimals = 2) => {
        if (val === null || val === undefined || Number.isNaN(val)) return '<span class="text-slate-300 dark:text-slate-600">--</span>';
        if (formatFn === fmtPercent) return fmtPercent(val, decimals);
        return formatFn(val, decimals) + suffix;
      };

      // --- M√≥dulo 1 (Calidad & Estructura) ---
      const m1 = results.module1 || {};
      const struct = m1.estructural || {};
      const actualHealth = m1.actual || {};
      // CAMBIO: El score real est√° en module8, no en module1.estructural
      const m8 = results.module8 || {};
      const scoreRaw = m8.score || 0;
      const score100 = Math.round(scoreRaw);

      // Clasificaci√≥n
      let classification = "Especulativa";
      let classColor = "text-slate-400";
      let classIcon = "‚ö†Ô∏è";
      if (score100 >= 90) { classification = "ELITE QUALITY"; classColor = "text-amber-400"; classIcon = "üëë"; }
      else if (score100 >= 75) { classification = "COMPOUNDER"; classColor = "text-emerald-400"; classIcon = "üíé"; }
      else if (score100 >= 50) { classification = "STANDARD"; classColor = "text-blue-400"; classIcon = "üõ°Ô∏è"; }

      const anomalies = [];
      // CAMBIO: Usar roeUltimo y margenNetoUltimo en lugar de roeReal y margenNetoReal
      if (actualHealth.roeUltimo < 0.05) anomalies.push({ label: "ROE Cr√≠tico", val: actualHealth.roeUltimo, type: 'bad' });
      if (actualHealth.margenNetoUltimo < 0.02) anomalies.push({ label: "Margen Muy Bajo", val: actualHealth.margenNetoUltimo, type: 'bad' });
      if (anomalies.length === 0 && actualHealth.roeUltimo > 0.20) anomalies.push({ label: "ROE Excelente", val: actualHealth.roeUltimo, type: 'good' });

      // --- M√≥dulo 5 (Deuda/Solvencia) ---
      const mDebt = results.module5 || {};
      const debtMetrics = mDebt.ratioAnalysis || [];
      // Intentar buscar en el array primero, si no existe usar propiedades directas
      const getDebt = (n, directProp) => {
        const normalize = (str) => str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\s+/g, '');
        const searchTerm = normalize(n);
        const x = debtMetrics.find(i => normalize(i.name).includes(searchTerm));
        if (x) return { v: x.value, s: x.status };
        // Si no se encuentra en el array, usar propiedad directa
        const directVal = mDebt[directProp];
        if (directVal !== undefined && directVal !== null) {
          // Determinar status basado en valores est√°ndar
          let status = 'neutral';
          if (directProp === 'liquidezCorriente') status = directVal > 1.5 ? 'good' : (directVal < 1 ? 'bad' : 'neutral');
          if (directProp === 'deudaSobrePatrimonio') status = directVal < 1 ? 'good' : (directVal > 2 ? 'bad' : 'neutral');
          if (directProp === 'coberturaIntereses') status = directVal > 3 ? 'good' : (directVal < 1.5 ? 'bad' : 'neutral');
          return { v: directVal, s: status };
        }
        return { v: null, s: 'neutral' };
      };
      const liq = getDebt('liquidez', 'liquidezCorriente');
      const dp = getDebt('patrimonio', 'deudaSobrePatrimonio');
      const cob = getDebt('cobertura', 'coberturaIntereses');
      const debtComment = mDebt.conclusion?.message || "Estructura de capital estable.";

      // --- M√≥dulo 6 (Eficiencia/Gesti√≥n) ---
      const mEff = results.module6 || {};
      const trends = mEff.trends || {};
      const effTable = mEff.tabla || [];
      const lastEff = effTable[effTable.length - 1] || {};
      const effComment = mEff.conclusion?.message || "Gesti√≥n operativa est√°ndar.";

      // --- M√≥dulo Benchmark ---
      const mBench = results.moduleBenchmark || {};
      const bMetrics = mBench.metrics || [];
      const getBench = (k) => {
        const normalize = (str) => str.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\s+/g, '');
        const searchTerms = Array.isArray(k) ? k : [k];

        for (const term of searchTerms) {
          const normTerm = normalize(term);
          const found = bMetrics.find(x => normalize(x.name).includes(normTerm));
          if (found) {
            const ex = (v) => (v && typeof v === 'object' && v.value !== undefined) ? v.value : v;
            return { c: ex(found.company), i: ex(found.industry), signal: found.status };
          }
        }
        return { c: null, i: null, signal: 'neutral' };
      };
      const bRoe = getBench(['roe', 'roeestruct', 'rendefondos']);
      const bMargen = getBench(['margen', 'margenop', 'margenoperac']);
      const bDebt = getBench(['deuda', 'apalancamiento', 'deudapatrimonio']);
      const bCagr = getBench(['crecimiento', 'cagr', 'ventas']);
      const bPer = getBench(['utilidad', 'per', 'preciobeneficio']);
      const bPbv = getBench(['libro', 'pbv', 'preciovalorlibro']);

      // Declarar m2 y m4 primero para usarlos en el logging
      const m2 = results.module2 || {}; // Necesario para gr√°ficos de PER y P/BV hist√≥ricos
      const m3 = results.module3 || {}; // Necesario para conclusi√≥n integrada de valoraci√≥n
      const m4 = results.module4 || {}; // Necesario para gr√°fico de Proyecci√≥n
      const m7 = results.module7 || {}; // Necesario para gr√°fico de Crecimiento Hist√≥rico

      // DEBUG: Verificar valores de PER y P/BV
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('üîç DEBUG DASHBOARD: Valores PER y P/BV extra√≠dos');
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
      console.log('bPer:', bPer);
      console.log('  ‚Ä¢ Empresa (bPer.c):', bPer.c);
      console.log('  ‚Ä¢ Industria (bPer.i):', bPer.i);
      console.log('  ‚Ä¢ Se√±al:', bPer.signal);
      console.log('');
      console.log('bPbv:', bPbv);
      console.log('  ‚Ä¢ Empresa (bPbv.c):', bPbv.c);
      console.log('  ‚Ä¢ Industria (bPbv.i):', bPbv.i);
      console.log('  ‚Ä¢ Se√±al:', bPbv.signal);
      console.log('');
      console.log('M√≥dulo 2 (para comparaci√≥n):');
      console.log('  ‚Ä¢ m2.perActual:', m2.perActual);
      console.log('  ‚Ä¢ m2.perPromedio:', m2.perPromedio);
      console.log('  ‚Ä¢ m2.pbvActual:', m2.pbvActual);
      console.log('  ‚Ä¢ m2.pbvPromedio:', m2.pbvPromedio);
      console.log('  ‚Ä¢ m2.perType:', m2.perType);
      console.log('  ‚Ä¢ m2.perLabel:', m2.perLabel);
      console.log('');
      console.log('üîç DEBUG: moduleBenchmark.metrics completo:');
      console.log('  Total m√©tricas:', bMetrics.length);
      const perMetric = bMetrics.find(m => m.name && m.name.toLowerCase().includes('per'));
      const pbvMetric = bMetrics.find(m => m.name && m.name.toLowerCase().includes('p/bv'));
      console.log('  M√©trica PER encontrada:', perMetric);
      console.log('  M√©trica P/BV encontrada:', pbvMetric);
      console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');



      const leadersCount = bMetrics.filter(x => x.signal === 'good').length;
      const isLeader = leadersCount > (bMetrics.length / 2);

      // --- M√≥dulo 8 (Valoraci√≥n) ---
      const mVal = results.module8 || {};
      // CAMBIO: La propiedad correcta es pFinal, no finalPriceCLP
      const fairValue = mVal.pFinal || 0;
      const currentPrice = fd.datos.precioActualCLP || 0;
      const upside = currentPrice > 0 ? (fairValue - currentPrice) / currentPrice : 0;
      const decision = mVal.decision || "NEUTRAL";
      const dColor = decision === 'COMPRAR' ? 'emerald' : (decision === 'VENDER' ? 'red' : 'amber');
      const diag = state.context?.diagnosis || { label: 'Sin Diagn√≥stico', severity: 'neutral', emoji: '‚ö™' };

      // Obtener la conclusi√≥n final del m√≥dulo 1 y resumirla
      const createDiagnosticSummary = (fullConclusion) => {
        if (!fullConclusion) return diag.label || 'No hay informaci√≥n de diagn√≥stico disponible';

        // Extraer palabras clave seg√∫n patrones
        let summary = '';

        if (fullConclusion.includes('ESTRUCTURAL') || fullConclusion.includes('problema ESTRUCTURAL')) {
          summary = 'Problema ESTRUCTURAL. Debilidades en operaci√≥n central del negocio comprometen generaci√≥n de valor.';
        } else if (fullConclusion.includes('RIESGO DE SOLVENCIA')) {
          summary = 'RIESGO DE SOLVENCIA. Empresa operativa pero estructura de deuda asfixia rentabilidad por apalancamiento excesivo.';
        } else if (fullConclusion.includes('PUNTUAL') || fullConclusion.includes('ESPEC√çFICA')) {
          // Buscar los factores completos
          const startIdx = fullConclusion.indexOf('factores no operativos:');
          if (startIdx !== -1) {
            const afterStart = fullConclusion.substring(startIdx + 'factores no operativos:'.length);
            // Buscar hasta punto seguido de espacio y may√∫scula, o punto final
            const endMatch = afterStart.match(/\.\s+[A-Z]|\.$/);
            const factors = endMatch ? afterStart.substring(0, afterStart.indexOf(endMatch[0])).trim() : afterStart.split('.')[0].trim();
            summary = `Situaci√≥n PUNTUAL. EBIT positivo descarta falla estructural. Deterioro por ${factors}.`;
          } else {
            summary = 'Situaci√≥n PUNTUAL. EBIT positivo descarta falla estructural. Deterioro por factores financieros/tributarios.';
          }
        } else if (fullConclusion.includes('saludable') || fullConclusion.includes('positivo')) {
          summary = 'Posici√≥n SALUDABLE. Empresa con capacidad demostrada de generar valor operativo.';
        } else {
          // Extraer primera oraci√≥n como resumen
          const firstSentence = fullConclusion.split('.')[0] + '.';
          summary = firstSentence.length > 150 ? firstSentence.substring(0, 147) + '...' : firstSentence;
        }

        return summary;
      };

      const diagSummary = createDiagnosticSummary(m1.conclusionFinal);

      // Styles
      const cardBase = "bg-white dark:bg-[#1e293b] rounded-xl shadow-sm overflow-hidden flex flex-col";
      const subTitle = "text-[10px] font-bold uppercase text-slate-800 dark:text-white tracking-wider mb-1 flex items-center gap-1";
      const valText = "font-mono font-bold text-slate-700 dark:text-slate-200";

      // Calculate veredicto border color
      const veredictoType = m8?.veredicto?.type || 'neutral';
      const vBorderColor = veredictoType === 'excellent' || veredictoType === 'good' ? 'emerald' : veredictoType === 'bad' ? 'red' : 'amber';

      // ------------------------------------------
      // 2. RENDER GRID (50/50 Split Layout - V7 SYMMETRY FIX)
      // ------------------------------------------
      dbContainer.innerHTML = `
        <div class="font-sans text-slate-800 dark:text-slate-200">


          <!-- GRID 2-COLUMNS (58% / 42%) -->
          <div class="grid grid-cols-1 lg:grid-cols-12 gap-5 items-stretch">

            <!-- COL 1: MEGA CARD "CALIDAD DEL NEGOCIO" (58%) -->
            <div class="${cardBase} lg:col-span-7 p-0 h-full flex flex-col border-2 border-indigo-400">
               <!-- Header Banner (Compact Padding) -->
               <div class="bg-slate-100 dark:bg-slate-800/80 px-4 py-2 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center">
                  <h2 class="font-bold text-sm text-slate-700 dark:text-slate-200 flex items-center gap-2">
                     <span class="w-1.5 h-5 bg-indigo-500 rounded-full"></span>
                     1. Calidad del Negocio
                  </h2>
                  <div class="flex items-center gap-2">
                      ${(() => {
          const lbl = (diag.label || 'Neutro').toUpperCase();
          let badgeClass = "bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300";

          if (lbl.includes('C√çCLICA') || lbl.includes('FASE BAJA')) {
            badgeClass = "bg-gradient-to-r from-violet-100 to-fuchsia-100 dark:from-violet-900/40 dark:to-fuchsia-900/40 text-violet-700 dark:text-white border border-violet-200 dark:border-violet-700";
          } else if (lbl.includes('ELITE') || lbl.includes('L√çDER') || lbl.includes('EXCELENTE') || lbl.includes('SALUDABLE')) {
            badgeClass = "bg-emerald-100 dark:bg-emerald-900/40 text-emerald-700 dark:text-white border border-emerald-200 dark:border-emerald-700";
          } else if (lbl.includes('PROBLEMA') || lbl.includes('RIESGO') || lbl.includes('DETERIORO') || lbl.includes('REVISAR')) {
            badgeClass = "bg-red-100 dark:bg-red-900/40 text-red-700 dark:text-white border border-red-200 dark:border-red-700";
          }

          return `<span class="px-2 py-0.5 rounded text-[9px] font-bold ${badgeClass}">${diag.label || 'Neutro'}</span>`;
        })()}
                  </div>
               </div>

               <!-- Main Content Grid -->
               <div class="px-4 pt-2 pb-2 grid grid-cols-1 lg:grid-cols-12 gap-3 flex-1">
                  
                  <!-- BLOCK A: Snapshot & Estructural (Compact Spacing) -->
                  <div class="flex flex-col gap-2 lg:col-span-4 -mt-1 h-full">
                      <!-- Snapshot -->
                      <div class="dashboard-clickable flex-none" onclick="scrollToElement('module-section-1')" title="Ver detalle en M√≥dulo 1">
                          <h3 class="${subTitle} mb-0 flex justify-between items-center">üì∏ 1.1 FOTO ULTIMO A√ëO <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition">‚Üí Detalle</span></h3>
                          <div class="rounded-lg px-2.5 py-1 border ${(actualHealth.roeUltimo > 0 && actualHealth.margenNetoUltimo > 0) ? 'bg-emerald-50/70 dark:bg-emerald-900/30 border-emerald-200/60 dark:border-emerald-700/50' : ((actualHealth.roeUltimo < 0 || actualHealth.margenNetoUltimo < 0) ? 'bg-red-50/70 dark:bg-red-900/30 border-red-200/60 dark:border-red-700/50' : 'bg-amber-50/70 dark:bg-amber-900/30 border-amber-200/60 dark:border-amber-700/50')}">
                              <div class="flex flex-col gap-0.5">
                                  <div class="grid grid-cols-3 gap-1.5 text-[10px]">
                                      <div class="flex flex-col">
                                          <span class="text-slate-500">ROE</span>
                                          <span class="${valText} ${actualHealth.roeUltimo > 0.15 ? 'text-emerald-500' : ''}">${fmtPercent(actualHealth.roeUltimo)}</span>
                                      </div>
                                      <div class="flex flex-col">
                                          <span class="text-slate-500">Mg.Neto</span>
                                          <span class="${valText}">${fmtPercent(actualHealth.margenNetoUltimo)}</span>
                                      </div>
                                      <div class="flex flex-col text-center justify-center">
                                          <span class="text-slate-500">EBIT (USD MM)</span>
                                          <span class="${valText}">${fmtCurrency(valEbit)}</span>
                                      </div>
                                  </div>
                              </div>
                              <div class="flex flex-wrap gap-1 mt-0.5 justify-end">
                              </div>
                          </div>
                      </div>

                      <!-- Diagnosis (Module 1 Results) -->
                      <div class="md:col-span-4 dashboard-clickable flex flex-col flex-grow" onclick="scrollToElement('module-section-1')" title="Ver detalle en M√≥dulo 1">
                          <h3 class="${subTitle} mb-1 flex justify-between items-center">üîç 1.2 DIAGNOSTICO SITUACION ACTUAL <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition">‚Üí Detalle</span></h3>
                          ${(() => {
          const isCyclical = (diag.label + diagSummary).toUpperCase().includes('C√çCLICA') || (diag.label + diagSummary).toUpperCase().includes('FASE BAJA');
          const bgStyle = 'bg-slate-50 dark:bg-slate-800/50 border-slate-100 dark:border-slate-700/50 text-slate-700 dark:text-slate-300';

          return `<div class="${bgStyle} rounded-lg p-1.5 border text-[10px] leading-relaxed text-justify flex-grow flex flex-col justify-center">
                               ${diag.forensicNote ? `
                                   <div class="pb-1 mb-1 border-b border-dashed border-slate-200 dark:border-slate-700/50">
                                       <span class="opacity-70 uppercase font-bold mr-1">Causa Ra√≠z:</span>
                                       <span class="font-medium">${diag.forensicNote.replace(/<br>/g, '')}</span>
                                   </div>
                                ` : ''}
                                <div class="leading-relaxed">
                                    <span class="opacity-70 uppercase font-bold mr-1">Diagn√≥stico:</span>
                                    <span class="font-medium">${diagSummary}</span>
                                </div>
                            </div>`;
        })()}
                      </div>

                      <!-- Structural Score (Gauge) -->
                      <div class="rounded-lg p-3 border relative overflow-hidden flex flex-col items-center flex-grow justify-between dashboard-clickable ${score100 >= 70 ? 'bg-emerald-50/70 dark:bg-emerald-900/30 border-emerald-200/60 dark:border-emerald-700/50' : (score100 >= 50 ? 'bg-amber-50/70 dark:bg-amber-900/30 border-amber-200/60 dark:border-amber-700/50' : 'bg-red-50/70 dark:bg-red-900/30 border-red-200/60 dark:border-red-700/50')}" onclick="scrollToElement('module-section-1')" title="Ver detalle en M√≥dulo 1">
                          <h3 class="text-[10px] font-bold text-slate-400 uppercase mb-2 w-full text-center border-b border-dashed border-slate-200 dark:border-slate-700 pb-1 flex justify-center items-center gap-2">1.3 TERMOMETRO GAUGE <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition normal-case">‚Üí Detalle</span></h3>
                          
                          <!-- Gauge Container -->
                          <div class="relative w-48 h-28 mb-2">
                              <canvas id="gauge-structure-chart"></canvas>
                              <!-- Score Text Overlay -->
                              <div class="absolute inset-0 flex items-end justify-center pb-2 text-5xl font-black text-slate-700 dark:text-slate-200 drop-shadow-sm z-10">
                                  ${score100}
                              </div>
                          </div>

                          <!-- Metrics -->
                          <div class="w-full space-y-1 mb-2 px-1">
                             <div class="flex justify-between text-[10px] text-slate-500 dark:text-slate-400 border-b border-slate-100 dark:border-slate-700/50 pb-0.5">
                                <span>ROE Prom. Norm</span>
                                <span class="font-mono font-bold text-slate-700 dark:text-slate-200">${safeVal(bRoe.c, fmtPercent)}</span>
                             </div>
                             <div class="flex justify-between text-[10px] text-slate-500 dark:text-slate-400">
                                <span>CAGR Ventas (5A)</span>
                                <span class="font-mono font-bold text-slate-700 dark:text-slate-200">${safeVal(bCagr.c, fmtPercent)}</span>
                             </div>
                          </div>

                          <!-- Footer Classification -->
                          <div class="w-full text-center border-t border-slate-100 dark:border-slate-700/50 pt-2 mt-auto">
                              <div class="text-sm ${classColor} font-black uppercase tracking-wider flex items-center justify-center gap-1">
                                  <span>${classIcon}</span> ${classification} <span>${classIcon}</span>
                              </div>
                              <div class="text-[10px] font-medium text-slate-500 dark:text-slate-400 leading-tight mt-1">
                                  ${score100 >= 70 ? 'Alta rentabilidad estructural + crecimiento' : (score100 >= 50 ? 'Calidad media con potencial de mejora' : 'Baja rentabilidad o problemas estructurales')}
                              </div>
                          </div>
                      </div>
                  </div>

                   <!-- BLOCK B: Solvencia & Gesti√≥n (SPACIOUS AS REQUESTED) -->
                   <div class="space-y-3 lg:col-span-8 lg:border-l lg:border-slate-100 dark:lg:border-slate-700 lg:pl-4">
                        <!-- Solvencia (Full Width) -->
                        <div class="p-1.5 rounded-lg dashboard-clickable ${(liq.s === 'good' && dp.s === 'good') ? 'bg-emerald-50/70 dark:bg-emerald-900/30 border border-emerald-200/60 dark:border-emerald-700/50' : ((liq.s === 'bad' || dp.s === 'bad') ? 'bg-red-50/70 dark:bg-red-900/30 border border-red-200/60 dark:border-red-700/50' : 'bg-amber-50/70 dark:bg-amber-900/30 border border-amber-200/60 dark:border-amber-700/50')}" onclick="scrollToElement('module-section-4')" title="Ver detalle en M√≥dulo 4: Deuda y Solvencia">
                           <h3 class="${subTitle} mb-3 border-b border-dashed border-slate-300 dark:border-slate-600 pb-1 text-slate-800 dark:text-slate-200 flex justify-between items-center">üõ°Ô∏è 1.4 DEUDA Y SOLVENCIA <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition">‚Üí Detalle</span></h3>
                           <div class="flex flex-wrap gap-4 mb-1">
                               <div class="flex items-center gap-2">
                                   <span class="text-[9px] text-slate-600 dark:text-slate-300">Liquidez:</span>
                                   <span class="font-bold text-sm ${liq.s === 'good' ? 'text-emerald-500' : (liq.s === 'bad' ? 'text-red-500' : 'text-amber-500')}">${safeVal(liq.v, fmtNumber, 'x')}</span>
                               </div>
                               <div class="flex items-center gap-2">
                                   <span class="text-[9px] text-slate-600 dark:text-slate-300">D/Patr:</span>
                                   <span class="font-bold text-sm ${dp.s === 'good' ? 'text-emerald-500' : (dp.s === 'bad' ? 'text-red-500' : 'text-amber-500')}">${safeVal(dp.v, fmtNumber, 'x')}</span>
                               </div>
                               <div class="flex items-center gap-2">
                                   <span class="text-[9px] text-slate-600 dark:text-slate-300">Cobertura:</span>
                                   <span class="font-bold text-sm ${cob.s === 'good' ? 'text-emerald-500' : (cob.s === 'bad' ? 'text-red-500' : 'text-amber-500')}">${safeVal(cob.v, fmtNumber, 'x')}</span>
                               </div>
                           </div>
                           <p class="text-[10px] text-slate-700 dark:text-slate-200 italic bg-white/50 dark:bg-slate-800/50 p-1.5 rounded border border-slate-200 dark:border-slate-700 mb-1">
                              "${debtComment}"
                           </p>
                        </div>

                        <!-- GRID 50/50: Eficiencia & Competencia -->
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                             <!-- Eficiencia -->
                             <div class="p-3 rounded-lg dashboard-clickable ${(trends.assets > 0 && trends.inventory > 0) ? 'bg-emerald-50/70 dark:bg-emerald-900/30 border border-emerald-200/60 dark:border-emerald-700/50' : (trends.assets < 0 ? 'bg-red-50/70 dark:bg-red-900/30 border border-red-200/60 dark:border-red-700/50' : 'bg-amber-50/70 dark:bg-amber-900/30 border border-amber-200/60 dark:border-amber-700/50')}" onclick="scrollToElement('module-section-5')" title="Ver detalle en M√≥dulo 5: Eficiencia y Rotaci√≥n">
                                <h3 class="text-[9px] font-bold uppercase text-slate-800 dark:text-white tracking-wider mb-3 border-b border-dashed border-slate-300 dark:border-slate-600 pb-1 flex justify-between items-center whitespace-nowrap">‚öôÔ∏è 1.5 GESTION OPERATIVA <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition ml-1">‚Üí Detalle</span></h3>
                                    <div class="grid grid-cols-3 gap-1 w-full text-center">
                                        <div class="flex flex-col items-start border-r border-slate-200 dark:border-slate-600 pr-1">
                                            <span class="text-[9px] text-slate-600 dark:text-slate-300 truncate w-full text-left">Rot. Activos</span>
                                            <span class="font-bold font-mono text-xs text-slate-800 dark:text-slate-200">
                                                ${safeVal(valRotActivos, fmtNumber, 'x')}
                                            </span>
                                        </div>
                                        <div class="flex flex-col items-center border-r border-slate-200 dark:border-slate-600 px-1">
                                            <span class="text-[9px] text-slate-600 dark:text-slate-300 truncate w-full">Rot. Invent.</span>
                                            <span class="font-bold font-mono text-xs text-slate-800 dark:text-slate-200">
                                                ${safeVal(valRotInventarios, fmtNumber, 'x')}
                                            </span>
                                        </div>
                                        <div class="flex flex-col items-end pl-1">
                                            <span class="text-[9px] text-slate-600 dark:text-slate-300 truncate w-full text-right">Rot. KT</span>
                                            <span class="font-bold font-mono text-xs text-slate-800 dark:text-slate-200">
                                                ${safeVal(valRotKT, fmtNumber, 'x')}
                                            </span>
                                        </div>
                                    </div>
                                <p class="text-[10px] text-slate-700 dark:text-slate-200 italic bg-white/50 dark:bg-slate-800/50 p-2 rounded mt-2 border border-slate-200 dark:border-slate-700">
                                   "${effComment}"
                                </p>
                             </div>

                             <!-- Benchmark -->
                             <div class="dashboard-clickable" onclick="scrollToElement('module-section-7')" title="Ver detalle en M√≥dulo 7: Benchmarking Competitivo">
                                  <div class="flex justify-between items-center mb-3 border-b border-dashed border-slate-200 dark:border-slate-700 pb-1 w-full">
                                      <h3 class="text-[9px] font-bold uppercase text-slate-800 dark:text-white tracking-wider mb-0 flex justify-between items-center w-full">
                                        ‚öîÔ∏è 1.6 BENCHMARK 
                                        <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition">
                                          ‚Üí Detalle
                                        </span>
                                      </h3>
                                  </div>
                                  <table class="w-full text-[10px] text-left">
                                      <thead class="text-[9px] text-slate-400 border-b border-slate-100 dark:border-slate-700/50">
                                          <tr><th class="font-normal py-1">KPI</th><th class="font-normal text-right">Emp</th><th class="font-normal text-right">Ind</th><th class="text-center w-4"></th></tr>
                                      </thead>
                                      <tbody class="text-slate-700 dark:text-slate-200">
                                          <tr class="border-b border-slate-100 dark:border-slate-700/30 ${bRoe.signal === 'good' ? 'bg-emerald-50/70 dark:bg-emerald-900/30' : 'bg-red-50/50 dark:bg-red-900/30'}"><td class="py-1">ROE</td><td class="text-right font-bold">${safeVal(bRoe.c, fmtPercent)}</td><td class="text-right text-slate-500 dark:text-slate-400">${safeVal(bRoe.i, fmtPercent)}</td><td class="text-center text-[9px]">${bRoe.signal === 'good' ? 'üü¢' : 'üî¥'}</td></tr>
                                          <tr class="border-b border-slate-100 dark:border-slate-700/30 ${bMargen.signal === 'good' ? 'bg-emerald-50/70 dark:bg-emerald-900/30' : 'bg-red-50/50 dark:bg-red-900/30'}"><td class="py-1">Mg.Op</td><td class="text-right font-bold">${safeVal(bMargen.c, fmtPercent)}</td><td class="text-right text-slate-500 dark:text-slate-400">${safeVal(bMargen.i, fmtPercent)}</td><td class="text-center text-[9px]">${bMargen.signal === 'good' ? 'üü¢' : 'üî¥'}</td></tr>
                                          <tr class="border-b border-slate-100 dark:border-slate-700/30 ${bDebt.signal === 'good' ? 'bg-emerald-50/70 dark:bg-emerald-900/30' : 'bg-red-50/50 dark:bg-red-900/30'}"><td class="py-1">D/Patr</td><td class="text-right font-bold">${safeVal(bDebt.c, fmtNumber, 'x')}</td><td class="text-right text-slate-500 dark:text-slate-400">${safeVal(bDebt.i, fmtNumber, 'x')}</td><td class="text-center text-[9px]">${bDebt.signal === 'good' ? 'üü¢' : 'üî¥'}</td></tr>
                                          <tr class="border-b border-slate-100 dark:border-slate-700/30 ${bCagr.signal === 'good' ? 'bg-emerald-50/70 dark:bg-emerald-900/30' : 'bg-red-50/50 dark:bg-red-900/30'}"><td class="py-1">CAGR</td><td class="text-right font-bold">${safeVal(bCagr.c, fmtPercent)}</td><td class="text-right text-slate-500 dark:text-slate-400">${safeVal(bCagr.i, fmtPercent)}</td><td class="text-center text-[9px]">${bCagr.signal === 'good' ? 'üü¢' : 'üî¥'}</td></tr>
                                          <tr class="border-b border-slate-100 dark:border-slate-700/30 ${bPer.signal === 'good' ? 'bg-emerald-50/70 dark:bg-emerald-900/30' : 'bg-red-50/50 dark:bg-red-900/30'}"><td class="py-1">PER</td><td class="text-right font-bold">${safeVal(m2.perActual, fmtNumber, 'x')}</td><td class="text-right text-slate-500 dark:text-slate-400">${safeVal(fd.industry?.per, fmtNumber, 'x')}</td><td class="text-center text-[9px]">${bPer.signal === 'good' ? 'üü¢' : 'üî¥'}</td></tr>
                                          <tr class="${bPbv.signal === 'good' ? 'bg-emerald-50/70 dark:bg-emerald-900/30' : 'bg-red-50/50 dark:bg-red-900/30'}"><td class="py-1">P/BV</td><td class="text-right font-bold">${safeVal(m2.pbvActual, fmtNumber, 'x')}</td><td class="text-right text-slate-500 dark:text-slate-400">${safeVal(fd.industry?.pbv, fmtNumber, 'x')}</td><td class="text-center text-[9px]">${bPbv.signal === 'good' ? 'üü¢' : 'üî¥'}</td></tr>
                                      </tbody>
                                  </table>
                                  
                                  <!-- Status Box -->
                                  ${(() => {
          const goodSignals = [bRoe.signal, bMargen.signal, bDebt.signal, bCagr.signal, bPer.signal, bPbv.signal].filter(s => s === 'good').length;
          let statusText = '';
          let statusColor = '';
          let statusIcon = '';

          if (goodSignals >= 4) {
            statusText = 'SUPERIOR A LA INDUSTRIA';
            statusColor = 'bg-emerald-50 dark:bg-emerald-900/20 border-emerald-300 dark:border-emerald-700 text-emerald-700 dark:text-emerald-300';
            statusIcon = 'üèÜ';
          } else if (goodSignals === 3) {
            statusText = 'SIMILAR A LA INDUSTRIA';
            statusColor = 'bg-amber-50 dark:bg-amber-900/20 border-amber-300 dark:border-amber-700 text-amber-700 dark:text-amber-300';
            statusIcon = '‚öñÔ∏è';
          } else {
            statusText = 'BAJO LA INDUSTRIA';
            statusColor = 'bg-red-50 dark:bg-red-900/20 border-red-300 dark:border-red-700 text-red-700 dark:text-red-300';
            statusIcon = 'üìâ';
          }

          return `
            <div class="mt-2 px-2 py-1 rounded-lg border-2 ${statusColor} text-center">
              <p class="text-[9px] font-bold uppercase tracking-wide whitespace-nowrap">
                ${statusIcon} ${statusText}
              </p>
            </div>
          `;
        })()}
                             </div>
                        </div>

                        <!-- Crecimiento Hist√≥rico -->
                        ${(() => {
          const getCagrVal = (obj) => typeof obj === 'object' ? obj?.value : obj;
          const cagrVentas = getCagrVal(m7.cagrs?.ventas);
          const cagrUtilidad = getCagrVal(m7.cagrs?.beneficio);
          const cagrPatrimonio = getCagrVal(m7.cagrs?.patrimonio);
          const cagrFCFE = getCagrVal(m7.cagrs?.fcfe);

          // Determinar estado general basado en promedio de CAGRs v√°lidos
          const validCagrs = [cagrVentas, cagrUtilidad, cagrPatrimonio, cagrFCFE].filter(v => v !== null && v !== undefined);
          const avgCagr = validCagrs.length > 0 ? validCagrs.reduce((a, b) => a + b, 0) / validCagrs.length : 0;
          const positiveCount = validCagrs.filter(v => v >= 0.05).length;
          const negativeCount = validCagrs.filter(v => v < 0).length;

          // Estado: bueno si promedio >= 10% o mayor√≠a positivos, malo si promedio < 0 o mayor√≠a negativos
          const isGood = avgCagr >= 0.08 || positiveCount >= 3;
          const isBad = avgCagr < 0 || negativeCount >= 2;

          const containerBg = isGood
            ? 'bg-emerald-50/70 dark:bg-emerald-900/30 border-emerald-200/60 dark:border-emerald-700/50'
            : (isBad
              ? 'bg-red-50/70 dark:bg-red-900/30 border-red-200/60 dark:border-red-700/50'
              : 'bg-amber-50/70 dark:bg-amber-900/30 border-amber-200/60 dark:border-amber-700/50');

          const titleBorder = isGood
            ? 'border-emerald-300/60 dark:border-emerald-600/60'
            : (isBad
              ? 'border-red-300/60 dark:border-red-600/60'
              : 'border-amber-300/60 dark:border-amber-600/60');

          const getColor = (val) => {
            if (val === null || val === undefined) return 'text-slate-400';
            return val >= 0.10 ? 'text-emerald-600 dark:text-emerald-400' : (val >= 0 ? 'text-amber-600 dark:text-amber-400' : 'text-red-600 dark:text-red-400');
          };
          const getBg = (val) => {
            if (val === null || val === undefined) return 'bg-slate-100 dark:bg-slate-700/60';
            return val >= 0.10 ? 'bg-emerald-100/70 dark:bg-emerald-900/40' : (val >= 0 ? 'bg-amber-100/70 dark:bg-amber-900/40' : 'bg-red-100/70 dark:bg-red-900/40');
          };

          return `
                        <div class="p-1.5 rounded-lg ${containerBg} border dashboard-clickable" onclick="scrollToElement('module-section-6')" title="Ver detalle en M√≥dulo 6: Crecimiento Hist√≥rico">
                            <h3 class="text-[9px] font-bold uppercase text-slate-800 dark:text-white tracking-wider mb-1 border-b border-dashed ${titleBorder} pb-0.5 flex justify-between items-center whitespace-nowrap">üìà 1.7 CRECIMIENTO HISTORICO <span class="px-2 py-0.5 rounded-full border border-indigo-200 dark:border-indigo-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-indigo-700 dark:text-white shadow-sm cursor-pointer hover:bg-indigo-50 dark:hover:bg-indigo-900/30 transition ml-1">‚Üí Detalle</span></h3>
                            
                            <!-- CAGR Metrics Grid -->
                            <div class="grid grid-cols-4 gap-1 mb-1">
                                <div class="flex flex-col items-center py-0.5 px-1 rounded ${getBg(cagrVentas)}">
                                  <span class="text-[7px] text-slate-600 dark:text-slate-300 uppercase font-medium">Ventas</span>
                                  <span class="font-bold text-xs ${getColor(cagrVentas)}">${cagrVentas !== null ? fmtPercent(cagrVentas) : 'N/A'}</span>
                                </div>
                                <div class="flex flex-col items-center py-0.5 px-1 rounded ${getBg(cagrUtilidad)}">
                                  <span class="text-[7px] text-slate-600 dark:text-slate-300 uppercase font-medium">Utilidad</span>
                                  <span class="font-bold text-xs ${getColor(cagrUtilidad)}">${cagrUtilidad !== null ? fmtPercent(cagrUtilidad) : 'N/A'}</span>
                                </div>
                                <div class="flex flex-col items-center py-0.5 px-1 rounded ${getBg(cagrPatrimonio)}">
                                  <span class="text-[7px] text-slate-600 dark:text-slate-300 uppercase font-medium">Patrim.</span>
                                  <span class="font-bold text-xs ${getColor(cagrPatrimonio)}">${cagrPatrimonio !== null ? fmtPercent(cagrPatrimonio) : 'N/A'}</span>
                                </div>
                                <div class="flex flex-col items-center py-0.5 px-1 rounded ${getBg(cagrFCFE)}">
                                  <span class="text-[7px] text-slate-600 dark:text-slate-300 uppercase font-medium">FCFE</span>
                                  <span class="font-bold text-xs ${getColor(cagrFCFE)}">${cagrFCFE !== null ? fmtPercent(cagrFCFE) : 'N/A'}</span>
                                </div>
                            </div>
                            
                            <!-- Conclusion -->
                            <!-- Conclusion -->
                            <p class="text-[10px] text-slate-700 dark:text-slate-200 leading-snug italic bg-white/60 dark:bg-slate-800/60 p-1 rounded border border-slate-200/60 dark:border-slate-600/60">
                                "${(() => {
              let msg = m7.conclusion?.message || 'An√°lisis de trayectoria de crecimiento hist√≥rico.';
              // Eliminar saltos de l√≠nea y comprimir espacios
              msg = msg.replace(/<br\s*\/?>/gi, ' ').replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();

              // L√≥gica Espec√≠fica: Si el FCFE es negativo, buscar correlaci√≥n con Causa Ra√≠z
              if (typeof cagrFCFE !== 'undefined' && cagrFCFE < 0) {
                const rootCause = (typeof diag !== 'undefined' ? diag.forensicNote : null) || state.context?.diagnosis?.forensicNote;

                if (rootCause && rootCause.length > 5 && !rootCause.includes('Sin observaci√≥n')) {
                  // Extraer solo la "Raz√≥n Clave"
                  let reason = rootCause.toLowerCase().replace(/\.$/, '');
                  const connectors = ['impulsado por', 'causado por', 'debido a', 'asociado a', 'principalmente por', 'explica por'];

                  for (const conn of connectors) {
                    if (reason.includes(conn)) {
                      reason = reason.split(conn)[1].trim();
                      break;
                    }
                  }

                  // Fallback: Truncar si es muy largo y no se encontr√≥ conector
                  if (reason === rootCause.toLowerCase().replace(/\.$/, '')) {
                    const words = reason.split(' ');
                    if (words.length > 8) reason = words.slice(0, 8).join(' ') + '...';
                  }

                  msg += ` Nota: La contracci√≥n del FCFE podr√≠a estar influenciada por ${reason}, afectando la capacidad de generaci√≥n de caja.`;
                }
              }

              return msg;
            })()}"
                            </p>
                        </div>`;
        })()}
                   </div>
               </div>
               
                <!-- STRUCTURAL QUALITY CONCLUSION BOX (Full Width at bottom of Section 1) -->
                ${(() => {
          if (typeof generateDynamicVerdict !== 'function') return '';
          const verdict = generateDynamicVerdict(results, m1);

          const isCyclical = verdict.text.toUpperCase().includes('C√çCLICA') ||
            verdict.text.toUpperCase().includes('FASE BAJA'); // Exclude 'EXCEPCIONAL' keyword from cyclical unless specifically stated, rely on verdict.status for others

          let containerClasses = "";
          let textClasses = "";
          let borderLeftColor = "";

          if (isCyclical) {
            // Cyclical (Violet/Fuchsia - Matched Intensity)
            containerClasses = "bg-violet-50/80 dark:bg-violet-900/35 border-violet-100 dark:border-violet-700/50";
            textClasses = "text-violet-900 dark:text-white";
            borderLeftColor = "border-violet-500";
          } else if (verdict.status === 'exceptional') {
            // Good/Exceptional (Emerald - Matched Intensity)
            containerClasses = "bg-emerald-50/80 dark:bg-emerald-900/35 border-emerald-100 dark:border-emerald-700/50";
            textClasses = "text-emerald-900 dark:text-white";
            borderLeftColor = "border-emerald-500";
          } else {
            // Bad/Persistent/Neutral (Red - Matched Intensity)
            containerClasses = "bg-red-50/80 dark:bg-red-900/35 border-red-100 dark:border-red-700/50";
            textClasses = "text-red-900 dark:text-white";
            borderLeftColor = "border-red-500";
          }

          let verdictIcon = "üî¥"; // Default default
          if (isCyclical) verdictIcon = "üü£";
          else if (verdict.status === 'exceptional' || verdict.status === 'good') verdictIcon = "üü¢";
          else if (verdict.status === 'neutral') verdictIcon = "üü°";

          return `
                    <div class="mt-1 p-3 border-l-[6px] ${borderLeftColor} ${containerClasses} rounded-r-lg shadow-sm">
                        <p class="text-[12.5px] font-medium ${textClasses} leading-snug">
                           <span class="font-black uppercase mr-1">${verdictIcon} Conclusi√≥n:</span>${verdict.text}
                        </p>
                    </div>`;
        })()}
            </div>


            <!-- RIGHT COLUMN: VALUATION & VERDICT (42% Stacked) -->
            <div class="lg:col-span-5 flex flex-col gap-4 h-full">

                <!-- Bloque Veredicto: fijo al 30% de la altura de la p√°gina -->
                <div class="${cardBase} p-0 relative overflow-hidden order-1 flex-none h-[30vh] flex flex-col border-2 border-amber-400 dashboard-clickable" onclick="scrollToElement('module-section-8')" title="Ver detalle en M√≥dulo 8: Precio Objetivo Final">
                    ${(() => {
          const veredicto = m8.veredicto || { title: "N/A", message: "", type: "neutral", icon: "" };
          const vColor = veredicto.type === 'excellent' || veredicto.type === 'good' ? 'emerald' : veredicto.type === 'bad' ? 'red' : 'amber';
          const getRecs = (curr, target) => {
            const vCurr = parseFloat(curr) || 0;
            const vTarget = parseFloat(target) || 0;
            if (vTarget === 0) return { tenedores: { title: 'N/A', msg: 'Sin datos' }, inversores: { title: 'N/A', msg: 'Sin datos' } };

            const ratio = vCurr / vTarget;

            // 1) Precio > 110% Target -> Warning (Cara)
            if (ratio > 1.10) {
              return {
                tenedores: { title: 'REDUCIR / VENDER', msg: 'Asegurar ganancias' },
                inversores: { title: 'ESPERAR CORRECCI√ìN', msg: 'Cotizaci√≥n > Valor Justo' }
              };
            }
            // 2) Precio < 90% Target -> Opportunity (Barata)
            if (ratio < 0.90) {
              return {
                tenedores: { title: 'MANTENER', msg: 'Tendencia alcista' },
                inversores: { title: 'COMPRAR', msg: 'Margen seguridad > 10%' }
              };
            }
            // 3) Rango (+/- 10%) -> Equilibrio
            return {
              tenedores: { title: 'MANTENER', msg: 'En precio justo' },
              inversores: { title: 'OBSERVAR', msg: 'Esperar catalizador' }
            };
          };
          const recs = getRecs(currentPrice, fairValue || (m8 && m8.precioObjetivo) || 0);

          // Dynamic colors for recommendation boxes
          let tenColor = 'amber';
          if (recs.tenedores.title.includes('REDUCIR')) tenColor = 'orange';
          else if (recs.tenedores.title.includes('MANTENER')) tenColor = 'emerald';

          let invColor = 'amber';
          if (recs.inversores.title.includes('ESPERAR')) invColor = 'amber';
          else if (recs.inversores.title.includes('COMPRAR')) invColor = 'emerald';
          else if (recs.inversores.title.includes('OBSERVAR')) invColor = 'blue';

          // Yield / FCFE Anual Calculation
          let fcfeYieldDisplay = 'N/A';
          try {
            // 1. Try to get from module9Yield directly (preferred)
            const m9Yield = (typeof results !== 'undefined' && results.module9Yield) ? results.module9Yield : (window.moduleResults && window.moduleResults.module9Yield);
            // 2. Try to get from module9 structure
            const m9Company = (typeof results !== 'undefined' && results.module9) ? results.module9.company : (window.moduleResults && window.moduleResults.module9 ? window.moduleResults.module9.company : null);

            let rawYield = null;

            if (m9Yield && m9Yield.company && m9Yield.company.fcfeYield !== null && m9Yield.company.fcfeYield !== undefined) {
              rawYield = m9Yield.company.fcfeYield;
              console.log("LOG: Got Yield from module9Yield:", rawYield);
            } else if (m9Company && m9Company.fcfeYield !== null && m9Company.fcfeYield !== undefined) {
              rawYield = m9Company.fcfeYield;
              console.log("LOG: Got Yield from module9 (legacy):", rawYield);
            } else {
              // 3. Fallback Calculation
              console.log("LOG: Calculating Yield fallback...");
              const lastYear = fd.years[fd.years.length - 1];
              const numAcciones = fd.datos.numeroAcciones || 0;
              const marketCap = (currentPrice && numAcciones) ? currentPrice * numAcciones : 0;

              // Get FCFE components safely
              const getVal = (obj, year) => (obj && obj[year] !== undefined) ? obj[year] : 0;

              const cgo = getVal(fd.fcfe.cajaOperaciones, lastYear);
              const capex = getVal(fd.fcfe.capex, lastYear);
              const debtIssued = getVal(fd.fcfe.deudaEmitida, lastYear);
              const debtRepaid = getVal(fd.fcfe.deudaReembolsada, lastYear);

              const fcfe = cgo + capex + debtIssued + debtRepaid;
              console.log("LOG: Fallback FCFE:", fcfe, "MktCap:", marketCap);

              if (marketCap > 0 && fcfe !== 0) rawYield = fcfe / marketCap;
            }

            if (rawYield !== null) {
              fcfeYieldDisplay = fmtPercent(rawYield);
            }
          } catch (e) { console.warn('Yield calc error', e); }

          return `
                        <div class="bg-slate-100 dark:bg-slate-800/80 px-4 py-1.5 border-b border-slate-200 dark:border-slate-700">
                            <h2 class="font-bold text-sm text-slate-700 dark:text-slate-200 flex items-center justify-between w-full">
                                <div class="flex items-center gap-3">
                                    <span class="flex items-center gap-2">
                                        <span class="w-1.5 h-5 bg-${vColor}-500 rounded-full"></span>
                                        3. Veredicto de Precio y Recomendaci√≥n
                                    </span>
                                    <span class="flex items-center gap-1.5 px-2 py-0.5 rounded-full border border-${vColor}-300 bg-${vColor}-50 dark:bg-${vColor}-900/30">
                                         <span class="text-xs">${veredicto.icon}</span>
                                         <span class="text-[9px] font-black text-${vColor}-700 dark:text-${vColor}-100 uppercase tracking-wide leading-none">${veredicto.title}</span>
                                    </span>
                                </div>
                                <span class="px-2 py-0.5 rounded-full border border-${vColor}-200 dark:border-${vColor}-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-${vColor}-700 dark:text-white shadow-sm cursor-pointer hover:bg-${vColor}-50 dark:hover:bg-${vColor}-900/30 transition">‚Üí Detalle</span>
                            </h2>
                        </div>
                        <div class="p-2 flex gap-3 items-stretch flex-1">
                            <div class="w-[20%] flex flex-col gap-1 justify-between">
                                <div class="flex flex-col gap-1 h-full justify-between">
                                        <div class="text-[6px] text-slate-500 dark:text-slate-400 uppercase font-bold text-center">Precio Mercado</div>
                                        <div class="text-xs font-bold text-slate-700 dark:text-white flex items-center justify-center gap-1">${fmtCurrency(currentPrice)} <span class="text-[8px] font-normal opacity-70 leading-none">CLP</span></div>
                                    <div class="text-center p-2 rounded-lg border-2 ${upside >= 0 ? 'bg-emerald-200 dark:bg-emerald-500/30 border-emerald-300 dark:border-emerald-500' : 'bg-red-200 dark:bg-red-500/30 border-red-300 dark:border-red-500'} flex flex-col justify-center flex-1">
                                        <div class="text-[7px] text-slate-600 dark:text-slate-300 uppercase font-bold">Precio Objetivo</div>
                                        <div class="text-lg font-black text-slate-800 dark:text-white flex items-baseline gap-0.5 justify-center">${fmtCurrency(fairValue)} <span class="text-[8px] font-normal opacity-70">CLP</span></div>
                                        <div><span class="px-1.5 py-0.5 rounded-full text-[9px] font-black ${upside >= 0 ? 'bg-emerald-100 dark:bg-emerald-500/20 text-emerald-800 dark:text-emerald-100' : 'bg-red-100 dark:bg-red-500/20 text-red-800 dark:text-red-100'}">${upside > 0 ? '‚ñ≤' : '‚ñº'} ${fmtPercent(upside)}</span></div>
                                    </div>
                                    <div class="text-center p-1 rounded-lg bg-blue-200 dark:bg-blue-800 border-2 border-blue-400 dark:border-blue-500 flex flex-col justify-center h-auto mb-1 shadow-md">
                                        <div class="text-[6px] text-blue-800 dark:text-blue-200 uppercase font-black tracking-wider">Yield / FCFE Anual</div>
                                        <div class="text-sm font-black text-blue-900 dark:text-white">${fcfeYieldDisplay}</div>
                                    </div>
                                </div>
                            </div>
                            <div class="w-[80%] flex flex-col gap-1.5">
                                
                                <!-- Recomendaci√≥n Estrat√©gica Corto Plazo -->
                                <div class="flex flex-col flex-1 border rounded-lg p-1 bg-slate-50 dark:bg-slate-800/30 border-slate-200 dark:border-slate-700">
                                    <div class="text-[8px] font-black uppercase text-slate-400 dark:text-slate-500 mb-0.5 text-center tracking-wider">Recomendaci√≥n Estrat√©gica Corto Plazo</div>
                                    <div class="grid grid-cols-2 gap-1.5 flex-1">
                                        <!-- Tenedores -->
                                        <div class="p-1 rounded-lg bg-${tenColor}-50/50 dark:bg-${tenColor}-400/20 border-2 border-${tenColor}-200 dark:border-${tenColor}-300 flex flex-col justify-center items-center text-center shadow-sm">
                                            <div class="text-[7px] font-bold text-slate-800 dark:text-white mb-0.5">Tenedores</div>
                                            <div class="text-[10px] font-black text-${tenColor}-700 dark:text-${tenColor}-100 leading-none mb-0.5">${recs.tenedores.title}</div>
                                            <div class="text-[7px] text-slate-500 dark:text-white/60 leading-tight">${recs.tenedores.msg}</div>
                                        </div>
                                        <!-- Inversores -->
                                        <div class="p-1 rounded-lg bg-${invColor}-50/50 dark:bg-${invColor}-400/20 border-2 border-${invColor}-200 dark:border-${invColor}-300 flex flex-col justify-center items-center text-center shadow-sm">
                                            <div class="text-[7px] font-bold text-slate-800 dark:text-white mb-0.5">Inversores</div>
                                            <div class="text-[10px] font-black text-${invColor}-700 dark:text-${invColor}-100 leading-none mb-0.5">${recs.inversores.title}</div>
                                            <div class="text-[7px] text-slate-500 dark:text-white/60 leading-tight">${recs.inversores.msg}</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Recomendaci√≥n Estrat√©gica Largo Plazo (Moved Here) -->
                                ${(() => {
              let ltTitle = "";
              let ltMsg = "";
              let ltColor = "";
              let ltIcon = "";

              const scoreVal = m8?.score || 0;

              if (scoreVal > 60 && upside < 0) {
                ltTitle = "CALIDAD ALTA / PRECIO EXIGENTE";
                ltMsg = "Calidad fundamental s√≥lida pero precio optimista. Estrategia: Esperar correcci√≥n hacia el valor justo para iniciar posiciones seguras a largo plazo.";
                ltColor = "bg-blue-200 dark:bg-blue-900/50 border-blue-300 dark:border-blue-700 text-blue-900 dark:text-blue-100";
                ltIcon = "‚è≥";
              } else if (scoreVal < 50) {
                ltTitle = "RIESGOS ESTRUCTURALES";
                ltMsg = "La calidad del negocio presenta debilidades que comprometen la seguridad. Independiente del precio, los fundamentales no sustentan una estrategia 'Buy & Hold'.";
                ltColor = "bg-red-200 dark:bg-red-900/50 border-red-300 dark:border-red-700 text-red-900 dark:text-red-100";
                ltIcon = "‚õî";
              } else {
                ltTitle = "OPORTUNIDAD DE VALOR";
                ltMsg = "Convergencia atractiva entre calidad fundamental y precio descontado. Escenario √≥ptimo para construir una posici√≥n estrat√©gica y capturar valor intr√≠nseco.";
                ltColor = "bg-emerald-200 dark:bg-emerald-900/50 border-emerald-300 dark:border-emerald-700 text-emerald-900 dark:text-emerald-100";
                ltIcon = "üíé";
              }

              return `
                                           <div class="flex flex-col flex-1 border rounded-lg p-1.5 bg-slate-50 dark:bg-slate-800/30 border-slate-200 dark:border-slate-700 mt-0.5">
                                               <div class="text-[11px] font-black uppercase text-slate-400 dark:text-slate-500 mb-1 text-center tracking-wider">Recomendaci√≥n Estrat√©gica Largo Plazo</div>
                                               <div class="flex-1 ${ltColor} rounded-lg border-2 ${ltColor.replace('bg-', 'border-').split(' ')[2] || 'border-slate-200'} p-1.5 flex flex-col justify-center">
                                                    <div class="flex items-center gap-1.5 mb-0.5">
                                                        <span class="text-base">${ltIcon}</span>
                                                        <span class="text-[11px] font-black uppercase leading-tight tracking-tight">${ltTitle}</span>
                                                    </div>
                                                    <div class="text-[10px] leading-tight opacity-90 font-medium text-justify">${ltMsg}</div>
                                               </div>
                                           </div>
                                      `;
            })()}
                            </div>
                        </div>



            `;
        })()}
                </div>

                <!-- Bloque Convergencia: ocupa espacio restante -->
                <div class="${cardBase} p-0 relative overflow-hidden flex flex-col order-2 flex-1 border-2 border-cyan-400">
                     <div class="bg-slate-100 dark:bg-slate-800/80 px-3 py-1.5 border-b border-slate-200 dark:border-slate-700 flex justify-between items-center relative z-10">
                        <h2 class="font-bold text-sm text-slate-700 dark:text-slate-200 flex items-center gap-2"><span class="w-1.5 h-5 bg-cyan-500 rounded-full"></span>2. Convergencia de Valor: Realidad Hist√≥rica vs. Potencial Futuro</h2>
                     </div>
                     ${(() => {
          // 1. COMPARATIVA ACTUAL VS PROMEDIO HIST√ìRICO
          const perActual = m2.perActual || 0;
          const perProm = m2.perPromedio || 0;
          const pbvActual = m2.pbvActual || 0;
          const pbvProm = m2.pbvPromedio || 0;

          const perVsHist = perProm > 0 ? ((perActual - perProm) / perProm) : 0;
          const pbvVsHist = pbvProm > 0 ? ((pbvActual - pbvProm) / pbvProm) : 0;

          // 2. PROYECCI√ìN DE CRECIMIENTO
          const perObjChart = (m3?.perObj && m3.perObj > 0) ? m3.perObj : (m2.perPromedio || 15);
          let precioProyectadoFinal = 0;
          let hayDatosProyeccion = false;

          if (m4 && m4.tabla && m4.tabla.length > 0) {
            const idxFinal = Math.min(5, m4.tabla.length - 1);
            const filaFinal = m4.tabla[idxFinal];
            if (filaFinal && filaFinal.eps) {
              precioProyectadoFinal = filaFinal.eps * perObjChart;
              hayDatosProyeccion = true;
            }
          }

          const currentPriceLocal = currentPrice || 0;
          const hayCrecimiento = hayDatosProyeccion && (precioProyectadoFinal > currentPriceLocal * 1.15);

          // 3. EVALUACI√ìN DE SE√ëALES
          const perAtractivo = perVsHist < -0.05;
          const pbvAtractivo = pbvVsHist < -0.05;
          const perCaro = perVsHist > 0.05;
          const pbvCaro = pbvVsHist > 0.05;

          // 4. L√ìGICA DE ESCENARIOS - Textos separados
          let valColor, valIcon, comparativaText, proyeccionText, conclusionText;

          // TEXTO PROYECCI√ìN (Interpretaci√≥n de Trayectoria de M√≥dulo 4)
          const m4Retencion = m4?.retencion || 0;
          const m4G = m4?.gExp || 0;

          // Reutilizando l√≥gica de "Survival Mode" vs "Growth" para narrativa coherente
          // Si no hay m1 disponible, asumimos modo normal a menos que los datos sean extremos
          const diagSev = results.module1?.debug?.diagnosis?.severity || 'neutral';
          const isSurvival = (diagSev === 'red') || (m4Retencion > 0.95 && m4G < 0.06);

          if (isSurvival) {
            proyeccionText = `Estrategia Defensiva: Retenci√≥n del <strong>${fmtPercent(m4Retencion)}</strong> por necesidad de capitalizaci√≥n, no expansi√≥n. Crecimiento proyectado (${fmtPercent(m4G)}) limitado por salud financiera.`;
          } else {
            proyeccionText = `Motor de Crecimiento: Pol√≠tica de reinversi√≥n del <strong>${fmtPercent(m4Retencion)}</strong> impulsa una expansi√≥n compuesta del <strong>${fmtPercent(m4G)}</strong> anual en EPS y Valor Libro, creando valor sostenible.`;
          }

          if (perAtractivo && pbvAtractivo && hayCrecimiento) {
            valColor = 'emerald';
            valIcon = '‚úÖ';
            comparativaText = `La acci√≥n (PER <strong>${perActual.toFixed(1)}x</strong>) cotiza con descuento frente a su promedio (<strong>${perProm.toFixed(1)}x</strong>) y en P/BV (<strong>${pbvActual.toFixed(1)}x</strong> vs <strong>${pbvProm.toFixed(1)}x</strong>). <strong>Esta subvaloraci√≥n hist√≥rica sugiere un punto de entrada atractivo.</strong>`;
            conclusionText = `<strong>üü¢ CONCLUSI√ìN:</strong> Existe un doble margen de seguridad por valoraci√≥n hist√≥rica y crecimiento. <strong>Es un buen momento para entrar esperando que el precio retorne a su media hist√≥rica</strong> y capture el valor futuro.`;
          }
          else if ((perCaro && pbvCaro) || (!hayCrecimiento && (perCaro || pbvCaro))) {
            valColor = 'red';
            valIcon = '‚õî';
            comparativaText = `La acci√≥n cotiza con prima en PER (<strong>${perActual.toFixed(1)}x</strong> vs ${perProm.toFixed(1)}x) y/o P/BV (<strong>${pbvActual.toFixed(1)}x</strong> vs ${pbvProm.toFixed(1)}x). <strong>Esta sobrevaloraci√≥n hist√≥rica implica riesgo de correcci√≥n, desaconsejando la entrada actual.</strong>`;
            conclusionText = `<strong>üî¥ CONCLUSI√ìN:</strong> El precio actual es exigente respecto a su historia. <strong>Se recomienda esperar una correcci√≥n de valoraci√≥n antes de considerar posiciones</strong>.`;
          }
          else {
            valColor = 'amber';
            valIcon = '‚ö†Ô∏è';
            comparativaText = `Se√±ales mixtas. PER actual <strong>${perActual.toFixed(1)}x</strong> (Prom: ${perProm.toFixed(1)}x) y P/BV actual <strong>${pbvActual.toFixed(1)}x</strong> (Prom: ${pbvProm.toFixed(1)}x). <strong>No hay una ventaja estad√≠stica clara para tomar posici√≥n basada solo en historia.</strong>`;
            conclusionText = `<strong>üü° CONCLUSI√ìN:</strong> Los indicadores no muestran una direcci√≥n unificada. <strong>Lo prudente es monitorear hasta que el precio ofrezca un descuento m√°s claro respecto a sus fundamentales</strong>.`;
          }

          return `
                     <div class="px-2 pt-1 pb-1 grid grid-cols-2 gap-2"> 
                        <div class="bg-slate-50 dark:bg-slate-800/30 rounded-lg p-1.5 border border-slate-100 dark:border-slate-700 flex flex-col dashboard-clickable" onclick="scrollToElement('module-section-2')" title="Ver detalle en M√≥dulo 2: M√∫ltiplos Hist√≥ricos">
                            <h3 class="${subTitle} mb-1 text-center justify-center text-[9px] flex items-center gap-1">üìú COMPARATIVA HIST√ìRICA VS ACTUAL <span class="px-2 py-0.5 rounded-full border border-cyan-200 dark:border-cyan-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-cyan-700 dark:text-white shadow-sm cursor-pointer hover:bg-cyan-50 dark:hover:bg-cyan-900/30 transition">‚Üí Detalle</span></h3>
                            <div class="flex flex-col gap-1">
                                <div class="h-[7.65rem] w-full rounded border p-0.5 relative ${perAtractivo ? 'bg-emerald-50/40 dark:bg-emerald-900/30 border-emerald-200 dark:border-emerald-700' : (perCaro ? 'bg-red-50/40 dark:bg-red-900/30 border-red-200 dark:border-red-700' : 'bg-amber-50/40 dark:bg-amber-900/30 border-amber-200 dark:border-amber-700')}"><canvas id="dashboard-per-chart" class="h-full w-full"></canvas></div>
                                <div class="h-[7.65rem] w-full rounded border p-0.5 relative ${pbvAtractivo ? 'bg-emerald-50/40 dark:bg-emerald-900/30 border-emerald-200 dark:border-emerald-700' : (pbvCaro ? 'bg-red-50/40 dark:bg-red-900/30 border-red-200 dark:border-red-700' : 'bg-amber-50/40 dark:bg-amber-900/30 border-amber-200 dark:border-amber-700')}"><canvas id="dashboard-pbv-chart" class="h-full w-full"></canvas></div>
                            </div>
                            <p class="text-[9px] text-slate-600 dark:text-slate-300 leading-tight mt-1 line-clamp-3">${comparativaText}</p>
                        </div>
                        <div class="bg-slate-50 dark:bg-slate-800/30 rounded-lg p-1.5 border border-slate-100 dark:border-slate-700 flex flex-col dashboard-clickable" onclick="scrollToElement('module-section-3')" title="Ver detalle en M√≥dulo 3: Proyecci√≥n de Resultados">
                            <h3 class="${subTitle} mb-1 text-center justify-center text-[9px] flex items-center gap-1">üìà Proyecci√≥n de Valor (CLP) <span class="px-2 py-0.5 rounded-full border border-cyan-200 dark:border-cyan-700 bg-white/50 dark:bg-slate-800 text-[8px] font-bold whitespace-nowrap text-cyan-700 dark:text-white shadow-sm cursor-pointer hover:bg-cyan-50 dark:hover:bg-cyan-900/30 transition">‚Üí Detalle</span></h3>
                            <div class="rounded border border-slate-200 dark:border-slate-700 p-0.5 relative h-[15.5rem]"><canvas id="dashboard-valuation-chart" class="h-full w-full"></canvas></div>
                            <p class="text-[9px] text-slate-600 dark:text-slate-300 leading-tight mt-1 text-justify">${proyeccionText}</p>
                        </div>
                     </div>
              <div class="mt-auto py-2 px-3 border-t border-slate-200 dark:border-slate-700 ${valColor === 'emerald' ? 'bg-emerald-50/80 dark:bg-emerald-900/35' : (valColor === 'red' ? 'bg-red-50/80 dark:bg-red-900/35' : 'bg-amber-50/80 dark:bg-amber-900/35')}">
                  <p class="text-[11px] font-medium text-slate-700 dark:text-slate-200 leading-relaxed">${conclusionText}</p>
              </div>`;
        })()}
                </div>

            </div>
          </div>
        </div>
      `;

      // === RENDERIZAR MINI-GR√ÅFICOS DEL DASHBOARD ===
      setTimeout(() => {
        const isDark = document.documentElement.classList.contains('dark');
        const axColor = isDark ? '#ffffff' : '#64748b';  // White in dark mode for readability
        const titleColor = isDark ? '#e2e8f0' : '#64748b'; // Slightly softer white for titles

        // 1. PER Comparativo
        const perCtx = document.getElementById('dashboard-per-chart');
        if (perCtx) {
          const existingChart = Chart.getChart(perCtx);
          if (existingChart) existingChart.destroy();

          new Chart(perCtx.getContext('2d'), {
            type: 'bar',
            data: {
              labels: ['Prom. Hist.', 'Actual'],
              datasets: [{
                data: [m2.perPromedio || 0, m2.perActual || 0],  // m2 tiene normalizaci√≥n correcta
                backgroundColor: ['#94a3b8', '#6366f1'],
                borderRadius: 4,
                barPercentage: 0.8,
                categoryPercentage: 0.8
              }]
            },
            options: {
              indexAxis: 'y', // HORIZONTAL
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: { right: 20 } },
              plugins: {
                legend: { display: false },
                title: {
                  display: true,
                  text: 'PER',
                  align: 'start',
                  color: titleColor,
                  font: { size: 11, weight: 'bold' },
                  padding: { bottom: 10 }
                },
                datalabels: {
                  anchor: 'end',
                  align: 'start', // INSIDE the bar
                  color: '#ffffff',
                  font: { size: 11, weight: 'bold' },
                  formatter: (v) => v ? v.toFixed(1) + 'x' : ''
                }
              },
              scales: {
                x: { display: false, beginAtZero: true, grid: { display: false } },
                y: {
                  grid: { display: false },
                  ticks: { color: axColor, font: { size: 10, weight: 'bold' } }
                }
              }
            }
          });
        }

        // 2. P/BV Comparativo
        const pbvCtx = document.getElementById('dashboard-pbv-chart');
        if (pbvCtx) {
          const existingChart = Chart.getChart(pbvCtx);
          if (existingChart) existingChart.destroy();

          new Chart(pbvCtx.getContext('2d'), {
            type: 'bar',
            data: {
              labels: ['Prom. Hist.', 'Actual'],
              datasets: [{
                data: [m2.pbvPromedio || 0, m2.pbvActual || 0],  // m2 tiene normalizaci√≥n correcta
                backgroundColor: ['#94a3b8', '#8b5cf6'],
                borderRadius: 4,
                barPercentage: 0.8,
                categoryPercentage: 0.9
              }]
            },
            options: {
              indexAxis: 'y', // BARRA HORIZONTAL
              responsive: true,
              maintainAspectRatio: false,
              layout: { padding: { right: 20 } },
              plugins: {
                legend: { display: false },
                title: {
                  display: true,
                  text: 'P/BV',
                  align: 'start',
                  color: titleColor,
                  font: { size: 11, weight: 'bold' },
                  padding: { bottom: 10 }
                },
                datalabels: {
                  anchor: 'end',
                  align: 'start', // INSIDE the bar
                  color: '#ffffff',
                  font: { size: 11, weight: 'bold' },
                  formatter: (v) => v ? v.toFixed(2) + 'x' : ''
                }
              },
              scales: {
                x: { display: false, beginAtZero: true, grid: { display: false } },
                y: {
                  grid: { display: false },
                  ticks: { color: axColor, font: { size: 10, weight: 'bold' } }
                }
              }
            }
          });
        }

        // 3. Proyecci√≥n de Valor (EPS y BVPS Proyectado) - Matching Module 3 (4)
        const valCtx = document.getElementById('dashboard-valuation-chart');
        if (valCtx) {
          const existingChart = Chart.getChart(valCtx);
          if (existingChart) existingChart.destroy();

          if (m4.tabla && m4.tabla.length > 0) {
            const dataRows = m4.tabla;

            new Chart(valCtx.getContext('2d'), {
              type: 'line',
              data: {
                labels: dataRows.map(r => r.year),
                datasets: [
                  {
                    label: 'EPS Proyectado',
                    data: dataRows.map(r => r.eps),
                    borderColor: '#2563eb', // Blue-600
                    backgroundColor: '#2563eb',
                    tension: 0.3,
                    borderWidth: 2,
                    pointRadius: 3
                  },
                  {
                    label: 'BVPS Proyectado',
                    data: dataRows.map(r => r.bvps),
                    borderColor: '#9333ea', // Purple-600
                    backgroundColor: '#9333ea',
                    tension: 0.3,
                    borderWidth: 2,
                    pointRadius: 3
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                layout: { padding: { top: 20, right: 20, left: 10, bottom: 5 } },
                plugins: {
                  legend: {
                    display: true,
                    labels: { color: titleColor, font: { size: 9 }, boxWidth: 8, usePointStyle: true }
                  },
                  title: {
                    display: false // Ya tiene t√≠tulo en el contenedor HTML
                  },
                  datalabels: {
                    color: axColor,
                    formatter: (value) => Math.round(value).toLocaleString(),
                    align: 'top',
                    anchor: 'end',
                    font: { size: 9, weight: 'bold' },
                    offset: 3
                  }
                },
                scales: {
                  y: {
                    ticks: {
                      color: axColor,
                      callback: (value) => Math.round(value).toLocaleString(),
                      font: { size: 9 }
                    },
                    grid: { color: isDark ? '#1e293b' : '#f1f5f9', display: true }
                  },
                  x: {
                    ticks: { color: axColor, font: { size: 9 } },
                    grid: { display: false }
                  }
                },
                interaction: {
                  mode: 'index',
                  intersect: false,
                }
              }
            });
          }
        }
      }, 100);

      // --- GAUGE CHART RENDERER (Elite Quality) ---
      setTimeout(() => {
        const ctxGauge = document.getElementById('gauge-structure-chart');
        if (ctxGauge) {
          // Check if chart already exists to prevent double-render
          const existingGauge = Chart.getChart(ctxGauge);
          if (existingGauge) existingGauge.destroy();

          const val = score100; // Using variable from scope
          const gCtx = ctxGauge.getContext('2d');

          // Create Gradient (Red -> Yellow -> Green) for the Arc
          const gradient = gCtx.createLinearGradient(0, 0, 150, 0);
          gradient.addColorStop(0, '#ef4444');    // Red (0)
          gradient.addColorStop(0.5, '#eab308');  // Yellow (50)
          gradient.addColorStop(1, '#22c55e');    // Green (100)

          // Custom Plugin for Needle
          const needlePlugin = {
            id: 'gaugeNeedle',
            afterDatasetDraw(chart, args, options) {
              const { ctx, data } = chart;
              const meta = chart.getDatasetMeta(0);
              const xCenter = meta.data[0].x;
              const yCenter = meta.data[0].y;
              const outerRadius = meta.data[0].outerRadius;

              // Angle: PI (180deg start) + value fraction * PI
              // Clamp value 0-100
              const clampedVal = Math.max(0, Math.min(100, val));
              const angle = Math.PI + (Math.PI * (clampedVal / 100));

              ctx.save();
              ctx.translate(xCenter, yCenter);
              ctx.rotate(angle);

              // Draw Needle
              ctx.beginPath();
              ctx.moveTo(0, -3); // Base width top
              ctx.lineTo(outerRadius - 5, 0); // Tip
              ctx.lineTo(0, 3); // Base width bottom
              ctx.fillStyle = '#64748b'; // Slate needle
              ctx.fill();

              // Draw Pivot Circle
              ctx.rotate(-angle); // Reset rotation for circle
              ctx.beginPath();
              ctx.arc(0, 0, 5, 0, Math.PI * 2);
              ctx.fillStyle = '#94a3b8'; // Slate Pivot
              ctx.fill();
              ctx.strokeStyle = '#fff';
              ctx.lineWidth = 2;
              ctx.stroke();

              ctx.restore();
            }
          };

          const chartInstance = new Chart(gCtx, {
            type: 'doughnut',
            data: {
              labels: ['Val', 'Rest'],
              datasets: [{
                data: [100], // Full background arc
                backgroundColor: [gradient],
                borderWidth: 0,
                circumference: 180,
                rotation: 270,
                cutout: '80%' // Thickness of arc
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              events: [],
              plugins: {
                legend: { display: false },
                tooltip: { enabled: false }
              },
              animation: { duration: 1000, easing: 'easeOutQuart' }
            },
            plugins: [needlePlugin]
          });
          ctxGauge.chartInstance = chartInstance;
        } else {
          console.warn('Canvas #gauge-structure-chart not found during render.');
        }
      }, 200);
    }

    // ----------------- DATA BUILDERS -----------------

    function buildIndustryData(rawRatiosSheet) {
      if (!rawRatiosSheet || rawRatiosSheet.length < 2) {
        console.warn('No "RATIOS" sheet found or it is empty. Industry data will be unavailable.');
        return {};
      }

      console.log('=== BUILDIND INDUSTRY DATA ===');
      console.log('rawRatiosSheet tiene', rawRatiosSheet.length, 'filas');
      console.log('Primeras 10 filas (columna A):', rawRatiosSheet.slice(0, 10).map(r => r[0]));

      const raw = { RATIOS: rawRatiosSheet };
      const yearInfo = (() => {
        const row0 = rawRatiosSheet[0] || [];
        const ys = [];
        const idxs = [];
        row0.forEach((val, i) => {
          if (!val) return;
          const y = parseInt(val);
          if (!isNaN(y) && y > 1900 && y < 2100) {
            ys.push(y);
            idxs.push(i);
          }
        });
        return { years: ys, indices: idxs };
      })();

      // Helper for Industry Extraction
      const getIndValue = (keywords) => {
        console.log('  Buscando:', keywords[0], '...');
        // Industry data is usually a single value (Average), not a series.
        // But if it is a series, we take the last valid year?
        // Actually, runModule9Benchmark expects a SINGLE number for comparison (ind.ro e, etc.).
        // So we should probably take the LAST available value or the AVG?
        // Usually Industry data in these sheets is a row of years.

        // Let's grab the series first
        const series = {};
        const years = yearInfo.years;
        const indices = yearInfo.indices;

        let foundRow = null;
        // Buscar EN ORDEN de keywords (los primeros tienen prioridad)
        // Esto evita que "Rentabilidad" haga match antes que "Rentabilidad sobre fondos propiosTTM"

        for (const keyword of keywords) {
          const normalizedKeyword = normalizeKey(keyword);

          // Pasada 1: Buscar coincidencia EXACTA para este keyword
          for (const row of rawRatiosSheet) {
            if (!row || !row[0]) continue;
            const label = normalizeKey(row[0]);
            if (label === normalizedKeyword) {
              foundRow = row;
              console.log('    ‚úì Encontrada fila (exacta con keyword:', keyword + '):', row[0]);
              break;
            }
          }

          if (foundRow) break; // Si encontr√≥ exacta, no seguir buscando

          // Pasada 2: Buscar coincidencia PARCIAL para este keyword
          for (const row of rawRatiosSheet) {
            if (!row || !row[0]) continue;
            const label = normalizeKey(row[0]);
            if (label.includes(normalizedKeyword) || normalizedKeyword.includes(label)) {
              foundRow = row;
              console.log('    ‚úì Encontrada fila (parcial con keyword:', keyword + '):', row[0]);
              break;
            }
          }

          if (foundRow) break; // Si encontr√≥ parcial, no seguir buscando
        }

        if (!foundRow) {
          console.log('    ‚úó NO encontrada');
          return null;
        }

        // Buscar valor en CUALQUIER columna (no solo en a√±os)
        // porque datos de industria suelen estar en una columna √∫nica
        for (let colIdx = 1; colIdx < foundRow.length; colIdx++) {
          const rawVal = foundRow[colIdx];
          if (!rawVal) continue;

          // Detectar si es porcentaje antes de convertir
          const isPercent = String(rawVal).includes('%');
          const val = toNumber(rawVal);

          if (val !== null) {
            // Si era porcentaje, dividir entre 100
            const finalVal = isPercent ? val / 100 : val;
            console.log('    ‚Üí Valor extra√≠do:', finalVal, `de columna ${colIdx}`, isPercent ? '(era %)' : '');
            return finalVal;
          }
        }
        console.log('    ‚úó Sin valor v√°lido en ninguna columna');
        return null;
      };

      return {
        years: yearInfo.years,
        indices: yearInfo.indices,
        // Extract Key Industry Metrics - NOMBRES EXACTOS DEL EXCEL
        roe: getIndValue(['Rentabilidad sobre fondos propiosTTM', 'Rentabilidad', 'ROE Industria', 'Return on Equity Industry', 'ROE Ind', 'Industria ROE', 'RentabilidadSYA']),
        margenOperativo: getIndValue(['Margen operativoTTM', 'Margen operativo5YA', 'Margen Operativo Industria', 'Operating Margin Industry', 'Margen Op Ind']),
        deudaPatrimonio: getIndValue(['Ratio de solvenciaMRQ', 'Deuda/Patrimonio Industria', 'Debt/Equity Industry', 'D/E Ind', 'Ratio de solvencia']),
        per: getIndValue(['Ratio Precio/UtilidadTTM', 'PER Industria', 'P/E Industry', 'PER Ind', 'Ratio Precio/Utilidad']),
        pbv: getIndValue(['Precio/Valor ContableMRQ', 'P/BV Industria', 'P/B Industry', 'P/BV Ind', 'Precio/Valor Contable']),
        cagrVentas: getIndValue(['Crecimiento de las Ventas en 5 A√±os5YA', 'Ventas (TTM) vs TTM 1 A√±o AtrasTTM', 'Ventas (MRQ) vs Trimestre 1 A√±o AtrasMRQ', 'CAGR Ventas Industria', 'Sales CAGR Industry', 'Crecimiento']),
        liquidez: getIndValue(['Test √°cidoMRQ', 'Liquidez Industria', 'Current Ratio Industry'])
      };
    }

    function buildFinancialData(raw, yearInfo, industryData) {
      const years = yearInfo.years;
      const indices = yearInfo.indices;

      // Fix: Pre-calculate datos to avoid ReferenceError
      const datos = buildDatos(raw.DATOS || []);
      console.log("DEBUG: buildFinancialData", { datos, years, indices, rawDatosLen: raw.DATOS ? raw.DATOS.length : 0 });

      const seriesBuilderTotalActivos = () => {
        const result = {};

        years.forEach((year, idx) => {
          const col = indices[idx];

          const row = raw.BALANCE.find((row) => {
            if (!row[0]) return false;

            const label = normalizeKey(row[0]);

            if (label.includes('corriente')) return false;

            const esTotalActivos =
              label === 'activostotales' ||
              label.includes('activostotales') ||
              label === 'totalactivos' ||
              label.includes('totalactivos') ||
              label.includes('totaldelactivo') ||
              label.includes('activototal') ||
              label.includes('totalactivo') ||
              label.includes('totaldeactivos') ||
              label === 'activos'; // Fallback gen√©rico

            return esTotalActivos;
          });

          result[year] = row ? toNumber(row[col]) : null;
        });

        return result;
      };

      const seriesBuilderEBIT = () => {
        const result = {};

        years.forEach((year, idx) => {
          const col = indices[idx];

          const row = raw.EERR.find((row) => {
            if (!row[0]) return false;

            let label = normalizeKey(row[0]);
            const labelSinEspacios = label.replace(/\s+/g, ' ').trim();

            if (labelSinEspacios.includes('margen')) return false;
            if (labelSinEspacios.includes('%')) return false;

            if (
              labelSinEspacios.includes('ebitda') ||
              labelSinEspacios.includes('evitda') ||
              labelSinEspacios.includes('evitad')
            ) {
              return false;
            }

            const esEBITPalabra = /\bebit\b/.test(labelSinEspacios);

            const esResultadoOperacional =
              labelSinEspacios.includes('resultado operacional') ||
              labelSinEspacios.includes('resultado operativo') ||
              labelSinEspacios.includes('resultado de explotacion') ||
              labelSinEspacios.includes('resultado de explotaci√≥n') ||
              labelSinEspacios.includes('utilidad operacional') ||
              labelSinEspacios.includes('utilidad operativa');

            return esEBITPalabra || esResultadoOperacional;
          });

          result[year] = row ? toNumber(row[col]) : null;
        });

        return result;
      };

      const seriesBuilder = (sheet, keywords, options = {}) => {
        const result = {};
        years.forEach((year, idx) => {
          const col = indices[idx];
          const value = getRowValue(raw[sheet], keywords, col, options);
          if (value !== null && value !== undefined) {
            // Usamos el valor tal cual viene del Excel, sin multiplicar por la magnitud
            result[year] = value;
          }
        });
        return result;
      };

      return {
        years,
        industry: industryData, // New Industry Data
        balance: {
          totalActivos: seriesBuilderTotalActivos(),
          totalActivos: seriesBuilderTotalActivos(),
          patrimonio: seriesBuilder('BALANCE', ['Patrimonio neto', 'Total patrimonio', 'Patrimonio']),
          activoCorriente: seriesBuilder('BALANCE', ['Total del activo corriente', 'Activo corriente', 'Activos corrientes', 'Activo circulante']),
          pasivoCorriente: seriesBuilder('BALANCE', ['Total del pasivo corriente', 'Pasivo corriente', 'Pasivos corrientes', 'Pasivo circulante']),
          pasivoNoCorriente: seriesBuilder('BALANCE', ['Pasivo no corriente', 'Deuda a largo plazo', 'Pasivos no corrientes']),
          inventarios: seriesBuilder('BALANCE', ['Inventario', 'Existencias', 'Inventarios']),
          // Deuda: Prioridad a la l√≠nea expl√≠cita detectada
          deudaTotal: seriesBuilder('BALANCE', ['Deuda total', 'Total deuda', 'Deuda financiera', 'Deuda financiera total']),
          deudaCortoPlazo: seriesBuilder('BALANCE', ['Pr√©stamos a corto plazo', 'Parte actual de la deuda']),
          deudaLargoPlazo: seriesBuilder('BALANCE', ['Deuda a largo plazo']),
          efectivo: seriesBuilder('BALANCE', ['Efectivo y equivalentes']),
          efectivoRestringido: seriesBuilder('BALANCE', ['Efectivo restringido']),
          inversionesCP: seriesBuilder('BALANCE', ['Inversiones a corto plazo']),

          // NUEVOS MAPEOS PARA DIAGN√ìSTICO FORENSE
          cuentasPorCobrar: seriesBuilder('BALANCE', ['Total de cuentas por cobrar', 'Deudores comerciales', 'Cuentas por cobrar comerciales', 'Cuentas por cobrar']),
          cuentasPorPagar: seriesBuilder('BALANCE', ['Total de cuentas por pagar', 'Cuentas comerciales por pagar', 'Acreedores comerciales', 'Cuentas por pagar']),
          ppe: seriesBuilder('BALANCE', ['Planta, propiedad y equipo, neto', 'Propiedades, planta y equipo', 'Activos fijos netos']),
        },
        eerr: {
          ventas: seriesBuilder('EERR', ['Ingresos totales', 'Ventas', 'Ingresos de actividades ordinarias']),
          // CR√çTICO: Nombres exactos verificados
          beneficioNeto: seriesBuilder('EERR', ['Beneficio neto', 'Utilidad neta', 'Utilidad (perdida) atribuible a los propietarios de la controladora', 'Resultado del ejercicio', 'Ganancia (perdida)']),
          ebit: seriesBuilderEBIT(),
          gastosIntereses: seriesBuilder('EERR', ['Total de gastos de intereses', 'Gastos financieros', 'Gastos por intereses', 'Costos financieros']),
          cogs: seriesBuilder('EERR', ['Coste de los ingresos', 'Costo de ventas']),
          dividendos: seriesBuilder('EERR', ['Dividendo', 'Dividendos']),

          // NUEVAS LINEAS PARA ANALISIS FORENSE (Detectadas en archivo SQM)
          impuesto: seriesBuilder('EERR', ['Impuesto sobre la renta', 'Gasto por impuestos']),
          gastosAdmin: seriesBuilder('EERR', ['Gastos de venta, generales y administrativos', 'Gastos de administraci√≥n']),
          otrosNoOp: seriesBuilder('EERR', ['Total de otros gastos no operativos', 'Otros ingresos/gastos']),
        },
        fcfe: {
          cajaOperaciones: seriesBuilder('FCFE', ['Caja generada por las operaciones', 'Flujo operativo', 'Flujo de efectivo de actividades de operacion', 'Flujo de caja operativo']),
          // CR√çTICO: Para el Reality Check de Inversi√≥n
          capex: seriesBuilder('FCFE', ['Gastos de capital', 'Compras de propiedades, plantas y equipos', 'Adquisicion de propiedades, plantas y equipo', 'Pagos por adquisicion de propiedades planta y equipo']),
          // CR√çTICO: Para el Reality Check de Deuda
          deudaEmitida: seriesBuilder('FCFE', ['Deuda total emitida', 'Importes procedentes de prestamos']),
          deudaReembolsada: seriesBuilder('FCFE', ['Total de deuda reembolsada', 'Pagos de prestamos']),
          dividendos: seriesBuilder('FCFE', ['Dividendos pagados de acciones ordinarias y preferentes']),
        },
        datos,
        yield: buildYieldData(raw), // New YIELD sheet data
      };
    }

    // Parse YIELD sheet for market benchmark rates
    function buildYieldData(raw) {
      const yieldSheet = raw['YIELD'];

      // Default values
      const defaults = {
        dap: 0.05,           // 5%
        moneyMarket: 0.05,   // 5%
        bono: 0.0485,        // 4.85%
        ipsa: 0.12,          // 12%
      };

      if (!yieldSheet || !Array.isArray(yieldSheet)) {
        console.warn('[YIELD] Sheet not found, using defaults');
        return defaults;
      }

      const parseYieldValue = (value) => {
        if (value === null || value === undefined) return null;

        // If it's already a number
        if (typeof value === 'number') {
          // If it's > 1, assume it's a percentage (e.g., 5 means 5%)
          return value > 1 ? value / 100 : value;
        }

        // If it's a string, try to parse
        if (typeof value === 'string') {
          // Remove % sign and commas
          const cleaned = value.replace(/%/g, '').replace(/,/g, '.').trim();
          const num = parseFloat(cleaned);
          if (!isNaN(num)) {
            // If > 1, assume percentage
            return num > 1 ? num / 100 : num;
          }
        }

        return null;
      };

      const result = { ...defaults };

      // Parse each row
      yieldSheet.forEach(row => {
        if (!row || row.length < 2) return;

        const label = normalizeKey(row[0]);
        if (!label) return;

        const value = parseYieldValue(row[1]);
        if (value === null) return;

        // Match labels to keys
        if (label.includes('dap') || label.includes('deposito') || label.includes('plazo')) {
          result.dap = value;
        } else if (label.includes('money') || label.includes('mutuo')) {
          result.moneyMarket = value;
        } else if (label.includes('bono') || label.includes('gobierno')) {
          result.bono = value;
        } else if (label.includes('ipsa') || label.includes('acciones') || label.includes('chilenas')) {
          result.ipsa = value;
        }
      });

      console.log('[YIELD] Parsed data:', result);
      return result;
    }

    function buildDatos(sheet) {
      const rawMap = {};
      sheet.forEach((row) => {
        if (!row || row.length < 2) return;
        const key = normalizeKey(row[0]);
        if (!key) return;
        for (let i = 1; i < row.length; i++) {
          const numeric = toNumber(row[i]);
          if (numeric !== null) {
            rawMap[key] = numeric;
            return;
          }
          if (row[i] && typeof row[i] === 'string' && row[i].trim() !== '') {
            rawMap[key] = row[i];
            return;
          }
        }
      });

      const dato = (keys, fallback = null) => {
        const storedKeys = Object.keys(rawMap);
        for (const key of keys) {
          const normalized = normalizeKey(key);
          if (Object.prototype.hasOwnProperty.call(rawMap, normalized)) {
            return rawMap[normalized];
          }
          const approx = storedKeys.find(
            (storedKey) => storedKey.includes(normalized) || normalized.includes(storedKey)
          );
          if (approx) {
            return rawMap[approx];
          }
        }
        return fallback;
      };

      const normalizeStringValue = (value, fallback = '') => {
        if (value === null || value === undefined) return fallback;
        return value.toString().trim() || fallback;
      };

      const normalizeCurrencyValue = (value) => {
        const text = normalizeStringValue(value, 'CLP').toUpperCase();
        if (text.includes('USD') || text.includes('DOLAR') || text.includes('D√ìLAR') || text.includes('DOLLAR')) return 'USD';
        if (text.includes('EUR') || text.includes('EURO')) return 'EUR';
        if (text.includes('CLP') || text.includes('PESO')) return 'CLP';
        return text || 'CLP';
      };

      const parsePct = (value, defaultValue) => {
        if (value === null || value === undefined || value === '') return defaultValue;
        const num = typeof value === 'number' ? value : toNumber(value);
        if (num === null || Number.isNaN(num)) return defaultValue;
        return num > 1 ? num / 100 : num;
      };

      const parseNumber = (value, defaultValue = null) => {
        if (value === null || value === undefined || value === '') return defaultValue;
        if (typeof value === 'number') return value;
        const num = toNumber(value);
        return num === null || Number.isNaN(num) ? defaultValue : num;
      };

      const parseMagnitude = (value) => {
        if (value === null || value === undefined || value === '') return 1;
        if (typeof value === 'number') return value || 1;
        const numeric = toNumber(value);
        if (numeric && numeric > 0) return numeric;
        const normalized = normalizeKey(value);
        if (!normalized) return 1;
        if (normalized.includes('unidad')) return 1;
        if (normalized.includes('millon')) return 1000000;
        if (normalized.includes('mil')) return 1000;
        return 1;
      };

      const lookup = (keys, fallback = null) => {
        const direct = dato(keys, null);
        if (direct !== null && direct !== undefined && direct !== '') return direct;
        const sheetValue = findValueInSheet(sheet, keys);
        return sheetValue !== null && sheetValue !== undefined && sheetValue !== '' ? sheetValue : fallback;
      };

      // EMPRESA: asegurar que sea siempre un TEXTO (nombre) y no un n√∫mero como 0
      const empresaCandidate = lookup(
        ['empresa', 'compa√±ia', 'compania', 'nombre empresa', 'nombre compa√±ia', 'nombre compania'],
        null
      );

      // Solo aceptamos el resultado del lookup si es un string no vac√≠o
      let empresaRaw =
        (typeof empresaCandidate === 'string' && empresaCandidate.trim() !== '')
          ? empresaCandidate
          : null;

      // Si no encontramos nada con lookup, buscamos directamente en la hoja DATOS
      if (!empresaRaw) {
        for (const row of sheet) {
          if (!row || row.length < 2) continue;

          const label = normalizeKey(row[0]);
          if (!label || !label.includes('empresa')) continue;

          // En la fila que contiene "EMPRESA" buscamos la primera celda NO vac√≠a que sea STRING
          for (let i = 1; i < row.length; i++) {
            const cell = row[i];
            if (typeof cell === 'string' && cell.trim() !== '') {
              empresaRaw = cell.trim();
              break;
            }
          }

          if (empresaRaw) break;
        }
      }

      // Fallback final si no se encontr√≥ nada
      if (!empresaRaw) {
        empresaRaw = 'Empresa';
      }

      const empresa = normalizeStringValue(empresaRaw, 'Empresa');
      const ticker = normalizeStringValue(lookup(['ticker', 'simbolo', 'symbol']), 'TICKER');
      const beta = parseNumber(lookup(['coeficiente beta', 'beta']));
      const gExplicita = parsePct(lookup(['tasa de crecimiento explicita', 'g explicita', 'g', 'tasa g', 'crecimiento g']), null);
      const rf = parsePct(lookup(['tasa de referencia bono soberano chile 10 anos tasa libre de riesgo rf', 'tasa libre de riesgo', 'rf']), 0.05);
      const rm = parsePct(lookup(['premio por riesgo de mercado actual rm erp ee y eu riesgo pais chile', 'erp', 'rm']), 0.08);
      const gPerpetua = parsePct(lookup(['tasa de crecimiento a perpetuidad gperpetuidad', 'gperpetuidad', 'g perpetua']), 0.025);
      const tax = parsePct(lookup(['tax', 'tasa']), 0.27);
      const tipoCambio = parseNumber(lookup(['tc', 'tipo de cambio']), 1);
      const numeroAcciones = parseNumber(lookup(['n¬∫ de acciones', 'numero de acciones', 'no de acciones']), null);
      const peg = parseNumber(lookup(['peg', 'ratio peg', 'peg ratio'], null));
      // --- MONEDA BASE ---
      let monedaBaseRaw = null;
      for (const row of sheet) {
        if (!row || row.length < 2) continue;
        const label = normalizeKey(row[0]);
        if (!label) continue;
        if (label.includes('moneda') || label.includes('currency')) {
          for (let i = 1; i < row.length; i++) {
            const cell = row[i];
            if (cell !== null && cell !== undefined && String(cell).trim() !== '') {
              monedaBaseRaw = String(cell).trim();
              break;
            }
          }
          if (monedaBaseRaw) break;
        }
      }
      if (!monedaBaseRaw) {
        monedaBaseRaw = 'CLP';
      }
      const monedaBase = normalizeCurrencyValue(monedaBaseRaw);

      // --- MAGNITUD ---
      let magnitudRaw = null;
      for (const row of sheet) {
        if (!row || row.length < 2) continue;
        const label = normalizeKey(row[0]);
        if (!label) continue;
        if (label.includes('magnitud') || label.includes('escala')) {
          for (let i = 1; i < row.length; i++) {
            const cell = row[i];
            if (cell !== null && cell !== undefined && String(cell).trim() !== '') {
              magnitudRaw = String(cell).trim();
              break;
            }
          }
          if (magnitudRaw) break;
        }
      }
      if (!magnitudRaw) {
        magnitudRaw = 1;
      }
      const magnitud = parseMagnitude(magnitudRaw);
      const precioActualRaw = parseNumber(lookup(['precio x accion actual', 'precio por accion actual', 'precio actual por accion', 'precio actual accion']), null);
      const precioAnalistasRaw = parseNumber(
        lookup(['precio x accion de los analistas', 'precio por accion de los analistas', 'precio analistas', 'precio objetivo analistas']),
        null
      );
      const precioActualCLP = precioActualRaw !== null ? precioActualRaw : null;
      const precioAnalistasCLP = precioAnalistasRaw !== null ? precioAnalistasRaw : null;

      // Lectura de A√±os de Proyecci√≥n (Nuevo Requerimiento)
      const yearsProjRaw = parseNumber(lookup(['a√±os proyecci√≥n', 'anos proyeccion', 'years projection', 'a√±os de proyecci√≥n']), 5);
      const yearsProj = yearsProjRaw !== null ? yearsProjRaw : 5;

      return {
        empresa,
        nombreEmpresa: empresa,
        ticker,
        beta,
        gExplicita,
        rf,
        rm,
        gPerpetuidad: gPerpetua,
        tax,
        tipoCambio,
        numeroAcciones,
        peg,
        precioActualCLP,
        precioAnalistasCLP,
        monedaBase,
        monedaBaseLabel: typeof monedaBaseRaw === 'string' ? monedaBaseRaw.trim() : monedaBase,
        magnitud,
        magnitudLabel: typeof magnitudRaw === 'string' ? magnitudRaw : null,
        rawMap,
        yearsProj, // <--- Nueva propiedad
      };
    }

    function computeGExplicitaPro(fd) {
      try {
        console.log("--- INICIO C√ÅLCULO G (FILTRO OUTLIERS INTELIGENTE) ---");

        if (!fd || !Array.isArray(fd.years) || !fd.years.length) return null;
        const years = [...fd.years].sort((a, b) => a - b);

        let roeValidos = [];
        const payoutValidos = [];

        // Helper para dividendos absolutos
        const getDividendos = (year) => {
          const fcfeDiv = fd.fcfe?.dividendos?.[year];
          if (fcfeDiv !== null && fcfeDiv !== undefined) return Math.abs(fcfeDiv);
          const eerrDiv = fd.eerr?.dividendos?.[year];
          if (eerrDiv !== null && eerrDiv !== undefined) return Math.abs(eerrDiv);
          return 0;
        };

        // 1. C√ÅLCULO DE G1 (Tasa Sostenible = ROE * Retenci√≥n)
        years.forEach((year) => {
          const beneficio = fd.eerr?.beneficioNeto?.[year];
          const patrimonio = fd.balance?.patrimonio?.[year];
          const dividendos = getDividendos(year);

          if (Number.isFinite(beneficio) && beneficio > 0 && Number.isFinite(patrimonio) && patrimonio > 0) {
            const roe = beneficio / patrimonio;
            let payout = 0;
            if (dividendos > 0) payout = Math.min(1, dividendos / beneficio);

            // ROE Sanity Check: ignorar ROEs absurdos > 100% que ensucian el promedio
            if (roe < 1.0) {
              roeValidos.push(roe);
              payoutValidos.push(payout);
            }
          }
        });

        const roePromedio = roeValidos.length ? average(roeValidos) : 0;
        const payoutPromedio = payoutValidos.length ? average(payoutValidos) : 0;
        const retencionPromedio = 1 - payoutPromedio;
        const g1 = (roePromedio != null) ? roePromedio * retencionPromedio : null;

        // 2. C√ÅLCULO DE CAGRs (Hist√≥ricos)
        const computeCAGRInfo = (getter) => {
          const validPoints = years.map(y => ({ y, val: getter(y) }))
            .filter(p => Number.isFinite(p.val) && p.val > 0);
          if (validPoints.length < 2) return null;

          const start = validPoints[0];
          const end = validPoints[validPoints.length - 1];
          const periods = end.y - start.y;
          if (periods <= 0) return null;

          return Math.pow(end.val / start.val, 1 / periods) - 1;
        };

        const gPat = computeCAGRInfo((year) => fd.balance?.patrimonio?.[year]);
        const gBn = computeCAGRInfo((year) => fd.eerr?.beneficioNeto?.[year]);

        // 3. MEZCLA INTELIGENTE (FILTRO DE OUTLIERS)
        const componentes = [];

        // REGLA DE ORO: Si un componente crece m√°s del 40% anual sostenido, 
        // asumimos que es recuperaci√≥n post-crisis y no crecimiento perpetuo. 
        // Lo descartamos para no inflar la valoraci√≥n.
        const OUTLIER_CAP = 0.40;

        if (g1 !== null && g1 > -0.10 && g1 < OUTLIER_CAP) {
          componentes.push(g1);
          console.log(`[G-CALC] g1 aceptado: ${(g1 * 100).toFixed(2)}%`);
        }

        if (gPat !== null && gPat > -0.10 && gPat < OUTLIER_CAP) {
          componentes.push(gPat);
          console.log(`[G-CALC] CAGR Patrimonio aceptado: ${(gPat * 100).toFixed(2)}%`);
        }

        if (gBn !== null && gBn > -0.10 && gBn < OUTLIER_CAP) {
          componentes.push(gBn);
          console.log(`[G-CALC] CAGR Beneficio aceptado: ${(gBn * 100).toFixed(2)}%`);
        } else {
          console.log(`[G-CALC] CAGR Beneficio descartado (Outlier/Null): ${gBn ? (gBn * 100).toFixed(2) : 'null'}%`);
        }

        // Si todos fueron descartados por altos, usamos el m√≠nimo de los altos o el ROE capado
        let gRaw = 0;
        if (componentes.length === 0) {
          gRaw = Math.min(roePromedio || 0.15, 0.15);
        } else {
          gRaw = average(componentes);
        }

        // 4. TOPES FINALES
        const minGlobal = 0.02;
        const maxGlobal = 0.20; // <--- CAMBIO AQU√ç: Tope m√°ximo bajado al 20%

        const finalCap = roePromedio > 0 ? Math.min(maxGlobal, roePromedio) : maxGlobal;

        let gFinal = Math.max(minGlobal, gRaw);
        gFinal = Math.min(gFinal, finalCap);

        console.log(`[G-CALC] gFinal (Max 20%): ${gFinal}`);

        return {
          value: gFinal,
          debug: { g1, gPat, gBn, roePromedio, sources: componentes }
        };

      } catch (e) {
        console.error("Critical error in computeGExplicitaPro:", e);
        return null;
      }
    }

    function getRowValue(sheetData, keywords, colIndex, options = {}) {
      const normalizedKeywords = (keywords || []).map((keyword) => normalizeKey(keyword)).filter(Boolean);
      if (!normalizedKeywords.length) return null;
      const exclusions = (options.exclude || []).map((word) => normalizeKey(word)).filter(Boolean);
      const allowList = (options.allow || []).map((word) => normalizeKey(word)).filter(Boolean);

      const findRow = (comparator) =>
        sheetData.find((row) => {
          if (!row || !row[0]) return false;
          const label = normalizeKey(row[0]);
          if (!label) return false;

          const isAllowed = !allowList.length || allowList.some((allow) => label === allow || label.includes(allow) || allow.includes(label));
          if (!isAllowed) return false;
          if (exclusions.some((word) => label.includes(word))) return false;

          return normalizedKeywords.some((keyword) => comparator(label, keyword));
        });

      let row = findRow((label, keyword) => label === keyword);
      if (!row) {
        row = findRow((label, keyword) => label.includes(keyword) || keyword.includes(label));
      }

      if (!row) return null;
      return toNumber(row[colIndex]);
    }

    function findValueInSheet(sheet, keywords) {
      for (const row of sheet) {
        if (!row || row.length < 2 || typeof row[0] !== 'string') continue;
        const label = normalizeKey(row[0]);
        if (!label) continue;
        const match = keywords.some((keyword) => {
          const normalizedKey = normalizeKey(keyword);
          return label.includes(normalizedKey) || normalizedKey.includes(label);
        });
        if (!match) continue;
        for (let i = 1; i < row.length; i++) {
          const cell = row[i];
          if (cell === null || cell === undefined || cell === '') continue;
          return cell;
        }
      }
      return null;
    }

    function normalizeKey(str) {
      if (!str) return '';
      return String(str)
        .trim()
        .toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, ''); // Eliminar TODOS los espacios para b√∫squeda m√°s tolerante
    }

    function toNumber(value) {
      if (value === undefined || value === null || value === '') return null;
      if (typeof value === 'number') return Number.isFinite(value) ? value : null;
      const str = String(value).trim();
      if (!str) return null;
      let sanitized = str.replace(/[^0-9.,-]/g, '');
      const commaCount = (sanitized.match(/,/g) || []).length;
      const dotCount = (sanitized.match(/\./g) || []).length;
      if (commaCount === 1 && dotCount === 0) sanitized = sanitized.replace(',', '.');
      else if (commaCount > 1 && dotCount === 0) sanitized = sanitized.replace(/,/g, '');
      else if (dotCount > 1 && commaCount === 0) sanitized = sanitized.replace(/\./g, '');
      else if (commaCount === 1 && dotCount === 1) {
        if (sanitized.indexOf(',') > sanitized.indexOf('.')) sanitized = sanitized.replace(/\./g, '').replace(',', '.');
        else sanitized = sanitized.replace(/,/g, '');
      }
      const num = Number(sanitized);
      return Number.isFinite(num) ? num : null;
    }

    function findYearsAndIndices(sheetData) {
      for (let i = 0; i < Math.min(sheetData.length, 20); i++) {
        const row = sheetData[i];
        const years = [];
        const indices = [];
        row.forEach((cell, idx) => {
          const year = parseYear(cell);
          if (year) {
            years.push(year);
            indices.push(idx);
          }
        });
        if (years.length >= 2) return { years, indices };
      }
      return null;
    }

    function parseYear(value) {
      const num = Number(String(value).replace(/[^0-9]/g, ''));
      if (!Number.isNaN(num) && num >= 1900 && num <= 2100) {
        return num;
      }
      return null;
    }

    // CONTEXT_METHOD_START
    // ==================== MOTOR DE NORMALIZACI√ìN Y CONTEXTO ====================

    // Helpers para c√°lculos seguros
    function num(x) {
      if (x === null || x === undefined) return null;
      if (typeof x === 'number') return Number.isFinite(x) ? x : null;
      const parsed = parseFloat(String(x).replace(/[,\s]/g, ''));
      return Number.isFinite(parsed) ? parsed : null;
    }

    function safeDiv(a, b) {
      const na = num(a);
      const nb = num(b);
      if (na === null || nb === null || nb === 0) return null;
      return na / nb;
    }

    function mean(arr) {
      const valid = arr.filter(x => num(x) !== null).map(num);
      if (valid.length === 0) return null;
      return valid.reduce((sum, val) => sum + val, 0) / valid.length;
    }

    function median(arr) {
      const valid = arr.filter(x => num(x) !== null).map(num).sort((a, b) => a - b);
      if (valid.length === 0) return null;
      const mid = Math.floor(valid.length / 2);
      return valid.length % 2 === 0 ? (valid[mid - 1] + valid[mid]) / 2 : valid[mid];
    }

    function normalize(values, yearsArray) {
      const validPairs = values.map((v, i) => ({ value: num(v), year: yearsArray[i] }))
        .filter(p => p.value !== null);

      if (validPairs.length === 0) return { value: null, yearsUsed: [] };

      const vals = validPairs.map(p => p.value);
      const years = validPairs.map(p => p.year);

      const normalized = vals.length >= 5 ? trimmedMean(vals) : median(vals);

      return { value: normalized, yearsUsed: years };
    }

    // Construir contexto de datos desde M√≥dulo 1
    function buildDataContext(fd, module1Result, diagnosis, anomalies) {
      if (!fd || !module1Result) {
        return null;
      }

      const years = fd.years || [];
      const lastYear = years[years.length - 1];
      const shares = num(fd.datos?.numeroAcciones) || null;

      // Extraer series hist√≥ricas
      const revenues = years.map(y => num(fd.eerr?.ventas?.[y]));
      const netIncomes = years.map(y => num(fd.eerr?.beneficioNeto?.[y]));
      const ebits = years.map(y => num(fd.eerr?.ebit?.[y]));
      const equities = years.map(y => num(fd.balance?.patrimonio?.[y]));
      const taxExpenses = years.map(y => num(fd.eerr?.impuesto?.[y]));

      // FCFE: intentar desde FCFE directo o reconstruir
      const fcfes = years.map(y => {
        const fcfeDirect = num(calcFCFEReal(fd, y));
        return fcfeDirect;
      });

      // Detectar m√©todo autom√°ticamente
      const hasNegativeNI = anomalies?.some(a => a.code === 'NI_NEG') || false;
      const hasEbitPosNiNeg = anomalies?.some(a => a.code === 'EBIT_POS_NI_NEG') || false;
      const isDistorted = diagnosis?.state?.toLowerCase().includes('distorsi√≥n') ||
        diagnosis?.state?.toLowerCase().includes('ciclo bajo') ||
        diagnosis?.state?.toLowerCase().includes('evento') || false;

      let mode = 'MIXTO';
      let penalty = 'NONE';
      let reason = 'Estado operativo normal';

      if (hasEbitPosNiNeg || (hasNegativeNI && isDistorted)) {
        mode = 'NORMALIZADO';
        reason = 'Evento no operativo o distorsi√≥n detectada';
        penalty = 'MODERATE';
      } else if (isDistorted) {
        mode = 'NORMALIZADO';
        reason = 'Distorsi√≥n o ciclo bajo detectado';
        penalty = 'MODERATE';
      }

      // ========== NORMALIZACI√ìN REAL ==========

      // Filtrar a√±os con NI positivo para ratios sensibles
      const positiveNIYears = years.filter((y, i) => num(netIncomes[i]) > 0);
      const positiveNIValues = positiveNIYears.map(y => num(fd.eerr?.beneficioNeto?.[y]));
      const positiveNIRevenues = positiveNIYears.map(y => num(fd.eerr?.ventas?.[y]));
      const positiveNIEbits = positiveNIYears.map(y => num(fd.eerr?.ebit?.[y]));
      const positiveNIEquities = positiveNIYears.map(y => num(fd.balance?.patrimonio?.[y]));

      // Normalizar NI, EBIT, Revenue, Equity
      const niNorm = normalize(positiveNIValues, positiveNIYears);
      const ebitNorm = normalize(positiveNIEbits.filter((_, i) => num(positiveNIEbits[i]) > 0),
        positiveNIYears.filter((_, i) => num(positiveNIEbits[i]) > 0));
      const revenueNorm = normalize(positiveNIRevenues.filter(r => num(r) > 0),
        positiveNIYears.filter((_, i) => num(positiveNIRevenues[i]) > 0));
      const equityNorm = normalize(positiveNIEquities.filter(e => num(e) > 0),
        positiveNIYears.filter((_, i) => num(positiveNIEquities[i]) > 0));

      // Normalizar FCFE
      const fcfeNorm = normalize(fcfes.filter(f => num(f) !== null),
        years.filter((_, i) => num(fcfes[i]) !== null));

      // Normalizar TaxRate
      const taxRates = years.map((y, i) => {
        const tax = num(taxExpenses[i]);
        const ni = num(netIncomes[i]);
        if (tax === null || ni === null || ni === 0) return null;
        const preTax = ni + tax;
        return safeDiv(tax, preTax);
      });
      const taxRateNorm = normalize(taxRates.filter(t => t !== null && t > 0 && t < 1),
        years.filter((_, i) => taxRates[i] !== null && taxRates[i] > 0 && taxRates[i] < 1));

      // Calcular ratios normalizados
      const roeNormalized = safeDiv(niNorm.value, equityNorm.value);
      const netMarginNormalized = safeDiv(niNorm.value, revenueNorm.value);
      const opMarginNormalized = safeDiv(ebitNorm.value, revenueNorm.value);
      const epsNormalized = safeDiv(niNorm.value, shares);

      // Calcular ROA normalizado
      const totalAssets = years.map(y => num(fd.balance?.totalActivos?.[y]));
      const assetsNorm = normalize(totalAssets.filter(a => num(a) > 0),
        years.filter((_, i) => num(totalAssets[i]) > 0));
      const roaNormalized = safeDiv(niNorm.value, assetsNorm.value);

      // ========== VALORES √öLTIMO A√ëO ==========
      const lastYearNI = num(fd.eerr?.beneficioNeto?.[lastYear]);
      const lastYearEquity = num(fd.balance?.patrimonio?.[lastYear]);
      const lastYearRevenue = num(fd.eerr?.ventas?.[lastYear]);
      const lastYearEbit = num(fd.eerr?.ebit?.[lastYear]);
      const lastYearAssets = num(fd.balance?.totalActivos?.[lastYear]);

      const epsLastYear = safeDiv(lastYearNI, shares);
      const bvpsLastYear = safeDiv(lastYearEquity, shares);
      const roeLastYear = safeDiv(lastYearNI, lastYearEquity);
      const roaLastYear = safeDiv(lastYearNI, lastYearAssets);
      const netMarginLastYear = safeDiv(lastYearNI, lastYearRevenue);
      const opMarginLastYear = safeDiv(lastYearEbit, lastYearRevenue);

      // Deuda neta (siempre √∫ltimo a√±o)
      let deudaTotal = num(fd.balance.deudaTotal?.[lastYear]);
      if (!Number.isFinite(deudaTotal)) {
        const deudaCorto = num(fd.balance.deudaCortoPlazo?.[lastYear]) || 0;
        const deudaLargo = num(fd.balance.deudaLargoPlazo?.[lastYear]) || 0;
        deudaTotal = deudaCorto + deudaLargo;
      }
      const caja = (num(fd.balance.efectivo?.[lastYear]) || 0) + (num(fd.balance.efectivoRestringido?.[lastYear]) || 0);
      const debtNet = deudaTotal - caja;

      // Crecimiento (usar gExplicita del sistema)
      const growthG = num(fd.datos?.gExplicita) || 0.1;

      // ========== CONSTRUIR CONTEXTO FINAL ==========

      // ========== L√ìGICA DE SELECCI√ìN DESACOPLADA (USER REQUEST) ==========

      // 1. BVPS (Patrimonio) - ARBOL DE DECISI√ìN
      // Regla: Patrimonio es Stock. Usar siempre REAL (√öltimo A√±o) salvo quiebra t√©cnica.
      let finalBvps = bvpsLastYear;
      let finalEquity = lastYearEquity;
      let sourceBvps = 'LAST_YEAR';

      if (lastYearEquity !== null && lastYearEquity <= 0) {
        // Kill Switch: Quiebra t√©cnica, usar normalizado te√≥rico
        finalBvps = safeDiv(equityNorm.value, shares);
        finalEquity = equityNorm.value;
        sourceBvps = 'NORMALIZED_BANKRUPTCY';
      }

      // 2. EPS (Utilidad) - ARBOL DE DECISI√ìN
      // Regla: Utilidad es Flujo. Usar REAL si es estable, NORMALIZADO si es vol√°til o negativo.
      let finalEps = epsLastYear;
      let sourceEps = 'LAST_YEAR';
      const epsRef = epsNormalized; // Referencia normalizada (positivos previos)

      if (lastYearNI === null || lastYearNI < 0) {
        // CASO A: NEGATIVO (P√©rdida)
        finalEps = epsRef;
        sourceEps = 'NORMALIZED_LOSS';
      } else {
        // CASO B: POSITIVO -> Test de Dispersi√≥n
        // Desviaci√≥n respecto a la historia normalizada
        const deviation = (epsRef && epsRef > 0)
          ? Math.abs(epsLastYear - epsRef) / epsRef
          : 0; // Si no hay historia, asumimos 0

        if (deviation > 0.30) {
          // Sub-caso B2: Vol√°til (>30% dispersi√≥n)
          finalEps = epsRef;
          sourceEps = 'NORMALIZED_VOLATILITY';
        } else {
          // Sub-caso B1: Estable
          finalEps = epsLastYear;
          sourceEps = 'LAST_YEAR_STABLE';
        }
      }

      // ========== CONSTRUIR CONTEXTO FINAL ==========
      const final = {};
      const source = {};
      const yearsUsed = {};

      // Ratios Estructurales (Flows): Preferimos siempre historia normalizada para evitar ruido de un a√±o
      final.roe = roeNormalized;
      final.roa = roaNormalized;
      final.netMargin = netMarginNormalized;
      final.opMargin = opMarginNormalized;
      final.taxRate = taxRateNorm.value;
      final.fcfeBase = fcfeNorm.value;
      final.growthG = growthG;

      // Valores Decididos (Stocks & Earnings)
      final.eps = finalEps;
      final.equity = finalEquity;
      final.bvps = finalBvps;

      // Deuda siempre actual
      final.debtNet = debtNet;
      final.shares = shares;

      // Metadatos de Fuente
      source.roe = 'NORMALIZED';
      source.roa = 'NORMALIZED';
      source.netMargin = 'NORMALIZED';
      source.opMargin = 'NORMALIZED';
      source.taxRate = 'NORMALIZED';
      source.fcfeBase = 'NORMALIZED';
      source.growthG = 'DATOS';
      source.debtNet = 'LAST_YEAR';
      source.shares = 'DATOS';

      source.eps = sourceEps;
      source.bvps = sourceBvps;
      source.equity = sourceBvps; // Tied to BVPS logic

      // Log de decisi√≥n para auditor√≠a
      console.log(`[Context Build] EPS Decision: ${sourceEps} (Value: ${finalEps})`);
      console.log(`[Context Build] BVPS Decision: ${sourceBvps} (Value: ${finalBvps})`);

      yearsUsed.roe = niNorm.yearsUsed;
      yearsUsed.eps = niNorm.yearsUsed; // Aprox
      yearsUsed.netMargin = niNorm.yearsUsed;
      yearsUsed.opMargin = ebitNorm.yearsUsed;
      yearsUsed.taxRate = taxRateNorm.yearsUsed;
      yearsUsed.fcfeBase = fcfeNorm.yearsUsed;
      yearsUsed.fcfeBase = fcfeNorm.yearsUsed;
      source.shares = 'DATOS';

      yearsUsed.roe = niNorm.yearsUsed;
      yearsUsed.eps = final.eps === epsLastYear ? [lastYear] : niNorm.yearsUsed;
      yearsUsed.netMargin = niNorm.yearsUsed;
      yearsUsed.opMargin = ebitNorm.yearsUsed;
      yearsUsed.taxRate = taxRateNorm.yearsUsed;
      yearsUsed.fcfeBase = fcfeNorm.yearsUsed;


      return {
        method: {
          mode: mode,
          penalty: penalty,
          reason: reason
        },
        diagnosis: diagnosis, // <--- AGREGAR ESTA L√çNEA CR√çTICA
        final: final,
        source: source,
        yearsUsed: yearsUsed
      };
    }
    // CONTEXT_METHOD_END

    // ----------------- MODULE LOGIC -----------------
    function runModule0DCF(fd, opciones) {
      // CONTEXT_METHOD_START
      // Consumir FCFE base desde contexto (no recalcular)
      let baseFCFE = 0;
      if (state.context && state.context.final && state.context.final.fcfeBase !== null) {
        baseFCFE = state.context.final.fcfeBase;
        console.log('[DCF] Usando FCFE base desde contexto:', baseFCFE, 'Fuente:', state.context.source.fcfeBase);
      } else {
        // Fallback: calcular promedio si no hay contexto (no deber√≠a ocurrir en flujo normal)
        const years = fd.years;
        const fcfeRealSeries = years.map((year) => ({ year, value: calcFCFEReal(fd, year) }));
        let filtered = fcfeRealSeries;
        // Filtro de rango eliminado - siempre usa todo el hist√≥rico

        const fcfeValues = filtered.map((row) => row.value).filter((value) => value !== null && value !== 0);
        baseFCFE = fcfeValues.length ? fcfeValues.reduce((sum, value) => sum + value, 0) / fcfeValues.length : 0;
        console.warn('[DCF] Contexto no disponible, usando fallback para FCFE');
      }
      // CONTEXT_METHOD_END

      const years = fd.years;
      const beta = fd.datos.beta || 1;
      const ke = (opciones.rf ?? fd.datos.rf ?? 0.05) + beta * (opciones.rm ?? fd.datos.rm ?? 0.08);
      const gExp = fd.datos.gExplicita ?? 0.1;
      const gPerp = opciones.gPerp ?? fd.datos.gPerpetuidad ?? 0.02;
      const yearsProj = [];
      const fcfeProjCLP = [];
      const lastYear = years[years.length - 1];
      let currentFCFE = baseFCFE;
      for (let i = 1; i <= opciones.yearsProj; i++) {
        currentFCFE *= 1 + gExp;
        yearsProj.push(lastYear + i);
        fcfeProjCLP.push(currentFCFE);
      }
      const terminalFCFE = fcfeProjCLP[fcfeProjCLP.length - 1];
      const valorTerminal = ke > gPerp ? (terminalFCFE * (1 + gPerp)) / (ke - gPerp) : 0;
      let vna = 0;
      fcfeProjCLP.forEach((fcfe, idx) => {
        const period = idx + 1;
        const flow = idx === fcfeProjCLP.length - 1 ? fcfe + valorTerminal : fcfe;
        vna += flow / Math.pow(1 + ke, period);
      });
      const tc = fd.datos.tipoCambio || 1;
      const baseCurrency = (fd.datos.monedaBase || opciones.currency || 'CLP').toUpperCase();
      const shouldApplyTC = baseCurrency === 'USD' && tc && tc !== 1;
      const conversionRate = shouldApplyTC ? tc : 1;
      const vnaCLP = vna * conversionRate;
      const pDCF = fd.datos.numeroAcciones ? vnaCLP / fd.datos.numeroAcciones : 0;

      // ===== AN√ÅLISIS DCF AVANZADO =====
      const shares = fd.datos.numeroAcciones || 0;
      const precioMercado = fd.datos.precioActualCLP || null;

      // Par√°metros base para an√°lisis
      const baseParams = {
        ke,
        gPerp,
        baseFCFE,
        shares
      };


      // Reverse DCF (g impl√≠cito)
      const reverseDCF = precioMercado && shares > 0 ? calculateReverseDCF(precioMercado, baseParams) : null;
      const gImplicito = reverseDCF?.gImplicit || null;

      // 3. Conclusi√≥n de Valoraci√≥n (necesita CAGR ventas del m√≥dulo 1)
      // Lo calcularemos en el renderizador cuando tengamos acceso a module1

      // Determinar tasa de crecimiento para Time to Value
      // Prioridad: g impl√≠cito > g expl√≠cita
      const growthRateForTTV = gImplicito !== null ? gImplicito : gExp;

      // Calcular Time to Value (reemplaza Sensitivity Matrix)
      const timeToValue = precioMercado && pDCF > 0 && growthRateForTTV > 0
        ? calculateTimeToValue(pDCF, precioMercado, growthRateForTTV)
        : null;

      return {
        pDCF,
        vnaCLP,
        conversionRate,
        baseCurrency,
        ke,
        gExplicita: gExp,
        gPerpetuidad: gPerp,
        fcfeBase: baseFCFE,
        fcfeProyectados: fcfeProjCLP,
        valorTerminal,
        yearsProj,
        // Nuevos an√°lisis
        timeToValue,  // Reemplaza sensitivity
        reverseDCF,
        gImplicito,
        precioMercado,
      };
    }

    // ===== FUNCIONES DE AN√ÅLISIS DCF AVANZADO =====

    function calculateTimeToValue(precioDCF, precioMercado, growthRate) {
      // Calcula cu√°ntos a√±os tarda el valor intr√≠nseco en alcanzar el precio de mercado
      // O muestra el margen de seguridad si ya est√° subvaluada

      // Validar inputs cr√≠ticos para evitar loops infinitos o NaN
      if (
        !Number.isFinite(precioDCF) || precioDCF <= 0 ||
        !Number.isFinite(precioMercado) || precioMercado <= 0 ||
        !Number.isFinite(growthRate)
      ) {
        console.warn('[TimeToValue] Inputs inv√°lidos:', { precioDCF, precioMercado, growthRate });
        return { error: "Datos insuficientes para c√°lculo de convergencia." };
      }

      // EVALUACI√ìN INICIAL: ¬øSobrevalorada o Subvaluada?
      const isUndervalued = precioDCF >= precioMercado;

      let years = [0]; // A√±o 0 = hoy
      let values = [precioDCF]; // Valor inicial
      let yearsToCatchUp = null;
      let conclusion = '';
      let conclusionType = 'neutral';

      if (isUndervalued) {
        // ========== ESCENARIO B: SUBVALUADA (Margin of Safety) ==========
        // Proyectar 5 a√±os fijos para mostrar c√≥mo la brecha se ampl√≠a
        const projectionYears = 5;

        for (let year = 1; year <= projectionYears; year++) {
          const currentValue = precioDCF * Math.pow(1 + growthRate, year);
          years.push(year);
          values.push(currentValue);
        }

        // Calcular margen de seguridad inicial
        const marginOfSafety = ((precioDCF - precioMercado) / precioMercado) * 100;

        // Conclusi√≥n espec√≠fica para subvaluaci√≥n
        conclusion = `‚úÖ <strong>Oportunidad de Valor Inmediata:</strong> El valor fundamental (<strong>${fmtCurrency(precioDCF)}</strong>) ya supera al precio de mercado (<strong>${fmtCurrency(precioMercado)}</strong>) hoy mismo. No necesitas esperar crecimiento futuro para justificar la inversi√≥n; cuentas con un <strong>Margen de Seguridad del ${marginOfSafety.toFixed(1)}%</strong> desde el primer d√≠a.`;
        conclusionType = 'excellent';
        yearsToCatchUp = 0; // Ya converge hoy

      } else {
        // ========== ESCENARIO A: SOBREVALORADA (Time to Value) ==========
        // Buscar convergencia hasta m√°ximo 15 a√±os
        const maxYears = 15;
        let currentValue = precioDCF;

        for (let year = 1; year <= maxYears; year++) {
          currentValue = precioDCF * Math.pow(1 + growthRate, year);
          years.push(year);
          values.push(currentValue);

          // Verificar si alcanz√≥ o super√≥ el precio de mercado
          if (yearsToCatchUp === null && currentValue >= precioMercado) {
            yearsToCatchUp = year;
          }
        }

        // Generar conclusi√≥n seg√∫n a√±os de convergencia
        if (yearsToCatchUp === null) {
          // Caso: Nunca alcanza en 15 a√±os
          const finalValue = values[values.length - 1];
          const gap = ((precioMercado - finalValue) / precioMercado) * 100;
          conclusion = `‚õî <strong>Precio No Justificado:</strong> Ni siquiera en ${maxYears} a√±os de crecimiento al ${fmtPercent(growthRate)} el valor fundamental (${fmtCurrency(finalValue)}) alcanza el precio actual (${fmtCurrency(precioMercado)}). Brecha residual: ${gap.toFixed(0)}%.`;
          conclusionType = 'bad';
        } else if (yearsToCatchUp <= 3) {
          // Caso: Convergencia en corto plazo
          conclusion = `‚úÖ <strong>Oportunidad de Corto Plazo:</strong> El crecimiento proyectado (${fmtPercent(growthRate)}) justifica el precio actual en aproximadamente <strong>${yearsToCatchUp} ${yearsToCatchUp === 1 ? 'a√±o' : 'a√±os'}</strong>. El mercado est√° anticipando correctamente el crecimiento cercano.`;
          conclusionType = 'good';
        } else if (yearsToCatchUp <= 7) {
          // Caso: Convergencia en mediano plazo
          conclusion = `‚ö†Ô∏è <strong>Apuesta de Mediano Plazo:</strong> Al ritmo de crecimiento actual (${fmtPercent(growthRate)}), el valor real de la empresa tardar√° <strong>${yearsToCatchUp} a√±os</strong> en alcanzar el precio que pagas hoy (${fmtCurrency(precioMercado)}). Est√°s pagando por adelantado ${yearsToCatchUp} a√±os de crecimiento.`;
          conclusionType = 'warning';
        } else {
          // Caso: Convergencia en largo plazo (> 7 a√±os)
          conclusion = `‚ö†Ô∏è <strong>Alerta de Sobrevaloraci√≥n Extrema:</strong> Al ritmo de crecimiento actual (${fmtPercent(growthRate)}), el valor real de la empresa tardar√° <strong>${yearsToCatchUp} a√±os</strong> en alcanzar el precio que pagas hoy (${fmtCurrency(precioMercado)}). Est√°s pagando por adelantado una d√©cada de √©xito. Alto riesgo si el crecimiento no se materializa.`;
          conclusionType = 'bad';
        }
      }

      return {
        years,
        values,
        yearsToCatchUp,
        precioMercado,
        precioDCF,
        growthRate,
        conclusion,
        conclusionType
      };
    }

    function calculateReverseDCF(currentPrice, baseParams) {
      // Calcula qu√© g est√° impl√≠cito en el precio de mercado
      // Resolviendo: currentPrice = FCFE * (1+g) / (wacc - g) / shares
      // => g = (wacc * currentPrice * shares - FCFE) / (currentPrice * shares + FCFE)

      const { ke, baseFCFE, shares } = baseParams;

      if (!currentPrice || currentPrice <= 0 || !shares || shares <= 0 || !baseFCFE || baseFCFE <= 0) {
        return null;
      }

      // Resolver para g
      const numerator = (ke * currentPrice * shares) - baseFCFE;
      const denominator = (currentPrice * shares) + baseFCFE;

      if (denominator === 0) return null;

      const gImplicit = numerator / denominator;

      // Validar que g < wacc (condici√≥n de convergencia)
      if (gImplicit >= ke) {
        return { gImplicit: null, error: 'g >= WACC (no converge)' };
      }

      return { gImplicit, error: null };
    }

    function generateValuationConclusion(precioDCF, precioMercado, gImplicito, gHistorico, cagrVentas) {
      // Genera conclusi√≥n estrat√©gica en 3 p√°rrafos

      if (!precioMercado || precioMercado <= 0) {
        return {
          message: `<p class="text-slate-500 italic">No se puede generar conclusi√≥n sin precio de mercado actual.</p>`,
          type: 'neutral'
        };
      }

      // Calcular upside/downside
      const diff = precioDCF - precioMercado;
      const diffPercent = (diff / precioMercado);
      const isUndervalued = diffPercent > 0;
      const absUpside = Math.abs(diffPercent);

      // P√ÅRRAFO 1: La Foto de Hoy (Valoraci√≥n)
      const valoracionTexto = isUndervalued ? 'Subvaluaci√≥n' : 'Sobrevaloraci√≥n';
      const upsideTexto = isUndervalued ? 'potencial alcista' : 'riesgo bajista';

      const parrafo1 = `<strong>La Foto de Hoy (Valoraci√≥n):</strong> A d√≠a de hoy, la acci√≥n cotiza a ${fmtCurrency(precioMercado)}, lo que implica una <strong>${valoracionTexto}</strong> del ${fmtPercent(absUpside)} respecto a su valor fundamental calculado (${fmtCurrency(precioDCF)}). Esto representa un ${upsideTexto} de ${fmtPercent(absUpside)}.`;

      // P√ÅRRAFO 2: La Din√°mica (Corto Plazo)
      const presion = isUndervalued ? 'Alcista' : 'Bajista';
      const respaldo = isUndervalued ? 'est√° holgadamente respaldado' : 'no est√° respaldado';

      const parrafo2 = `<strong>La Din√°mica (Corto Plazo):</strong> Dada esta discrepancia, el modelo sugiere una presi√≥n <strong>${presion}</strong> de correcci√≥n. El mercado est√° pagando hoy un precio que ${respaldo} por la capacidad actual de generaci√≥n de caja de la empresa.`;

      // P√ÅRRAFO 3: El Futuro (Largo Plazo / Reverse DCF)
      let parrafo3 = '';

      if (gImplicito !== null && Number.isFinite(gImplicito)) {
        const escenario = gImplicito > (cagrVentas || 0.05) ? 'Exigente' : 'Conservador';
        const comparacion = gHistorico ? ` en comparaci√≥n con su crecimiento hist√≥rico de ventas (${fmtPercent(cagrVentas || 0)})` : '';

        parrafo3 = `<strong>El Futuro (Largo Plazo):</strong> Mirando hacia adelante, para justificar el precio actual de mercado a largo plazo, la empresa estar√≠a obligada a crecer perpetuamente al ${fmtPercent(gImplicito)}. Esto plantea un escenario <strong>${escenario}</strong>${comparacion} o el crecimiento esperado de la econom√≠a.`;
      } else {
        parrafo3 = `<strong>El Futuro (Largo Plazo):</strong> No se pudo calcular el crecimiento impl√≠cito del mercado (posible inconsistencia en par√°metros o g >= WACC).`;
      }

      // Determinar tipo de conclusi√≥n
      let type = 'neutral';
      if (absUpside > 0.20) {
        type = isUndervalued ? 'excellent' : 'bad';
      } else if (absUpside > 0.10) {
        type = isUndervalued ? 'good' : 'warning';
      }

      const message = `<p class="mb-2">${parrafo1}</p>
                   <p class="mb-2">${parrafo2}</p>
                   <p>${parrafo3}</p>`;

      return { message, type };
    }

    function runModule1Ratios(fd) {
      const years = fd.years || [];
      if (!years.length) return null;
      const lastYear = years[years.length - 1];
      const shares = fd.datos.numeroAcciones || null;
      const tc = fd.datos.tipoCambio || 1;
      const baseCurrency = (fd.datos.monedaBase || 'CLP').toUpperCase();
      const precioActualCLP = fd.datos.precioActualCLP || null;

      const toCLP = (value) => {
        if (value === null || value === undefined) return null;
        return baseCurrency === 'USD' ? value * tc : value;
      };
      const toUSD = (value) => {
        if (value === null || value === undefined) return null;
        if (!tc || tc === 0) return value;
        return baseCurrency === 'CLP' ? safeDivide(value, tc) : value;
      };

      const dividendsSeries = mergeSeries(fd.fcfe.dividendos, fd.eerr.dividendos);
      const netIncome = fd.eerr.beneficioNeto[lastYear] ?? null;
      const patrimonio = fd.balance.patrimonio[lastYear] ?? null;
      const activos = fd.balance.totalActivos[lastYear] ?? null;
      const ventas = fd.eerr.ventas[lastYear] ?? null;
      const ebit = fd.eerr.ebit[lastYear] ?? null;

      const roePorAnio = {};
      const margenNetoPorAnio = {};
      const margenOperacionalPorAnio = {};
      const payoutPorAnio = {};
      let roeValidos = [];
      const roaValidos = [];
      const margenNetoValidos = [];
      const margenOperacionalValidos = [];
      const payoutValidos = [];

      years.forEach((year) => {
        const ni = fd.eerr.beneficioNeto[year];
        const eq = fd.balance.patrimonio[year];
        const act = fd.balance.totalActivos[year];
        const sales = fd.eerr.ventas[year];
        const ebitYear = fd.eerr.ebit[year];
        const dividends = toNumber(dividendsSeries[year]);

        // KILL SWITCH: Patrimonio Negativo
        // Si el patrimonio es negativo o cero, el ROE no tiene sentido matem√°tico
        // Evita que una p√©rdida sobre patrimonio negativo genere un ROE positivo falso
        const roeValue =
          ni !== null && ni !== undefined && eq !== null && eq !== undefined && eq > 0
            ? safeDivide(ni, eq)
            : null;
        roePorAnio[year] = roeValue;
        if (Number.isFinite(roeValue) && ni > 0 && eq > 0) {
          // Promedios sensibles: excluimos a√±os con utilidades o patrimonio negativos/cero.
          roeValidos.push(roeValue);
        }

        const roaValue =
          ni !== null && ni !== undefined && act !== null && act !== undefined && act !== 0
            ? safeDivide(ni, act)
            : null;
        if (Number.isFinite(roaValue) && ni > 0 && act > 0) {
          roaValidos.push(roaValue);
        }

        const margenNetoValue =
          ni !== null && ni !== undefined && sales !== null && sales !== undefined && sales !== 0
            ? safeDivide(ni, sales)
            : null;
        margenNetoPorAnio[year] = margenNetoValue;
        if (Number.isFinite(margenNetoValue) && ni > 0 && sales > 0) {
          margenNetoValidos.push(margenNetoValue);
        }

        const margenOperacionalValue =
          ebitYear !== null && ebitYear !== undefined && sales !== null && sales !== undefined && sales !== 0
            ? safeDivide(ebitYear, sales)
            : null;
        margenOperacionalPorAnio[year] = margenOperacionalValue;
        if (Number.isFinite(margenOperacionalValue) && ebitYear > 0 && sales > 0) {
          margenOperacionalValidos.push(margenOperacionalValue);
        }

        let payoutValue = null;
        if (Number.isFinite(ni) && ni > 0 && dividends !== null && dividends !== undefined) {
          const payoutRaw = Math.abs(dividends) / ni;
          if (Number.isFinite(payoutRaw)) {
            payoutValue = Math.min(Math.max(payoutRaw, 0), 1);
            payoutValidos.push(payoutValue);
          }
        }
        payoutPorAnio[year] = payoutValue;
      });

      // --- DEBUG START: Log arrays before averaging ---
      console.group('DEBUG: Medici√≥n de la calidad del negocio');
      console.log('1. Margen Operacional Promedio');
      console.table({
        'Valores Validos (usados en promedio)': margenOperacionalValidos,
        'Todos los a√±os': margenOperacionalPorAnio
      });
      console.log('NOTA: Se excluyen a√±os con EBIT <= 0 o Ventas <= 0.');

      console.log('2. Payout Promedio');
      console.table({
        'Valores Validos (usados en promedio)': payoutValidos,
        'Todos los a√±os': payoutPorAnio
      });
      console.log('NOTA: Se calculan como dividendos/utilidad. Se restringe a rango [0, 1]. Se excluyen a√±os con utilidad <= 0.');

      console.log('3. Volatilidad ROE');
      console.table({
        'Valores Validos (usados en StdDev)': roeValidos,
        'Todos los a√±os': roePorAnio
      });
      console.log('NOTA: Volatilidad calculada como Desviaci√≥n Est√°ndar Poblacional sobre estos valores.');
      console.groupEnd();
      // --- DEBUG END ---

      const roePromedioNormalizado = trimmedMean(roeValidos);
      const roaPromedioNormalizado = trimmedMean(roaValidos);
      const margenNetoPromedioNormalizado = trimmedMean(margenNetoValidos);
      const margenOperacionalPromedioNormalizado = trimmedMean(margenOperacionalValidos);
      const payoutPromedioNormalizado = trimmedMean(payoutValidos);

      const epsUSD = shares ? safeDivide(netIncome, shares) : null;
      const bvpsUSD = shares ? safeDivide(patrimonio, shares) : null;
      const epsCLP = toCLP(epsUSD);
      const bvpsCLP = toCLP(bvpsUSD);

      const perReal =
        precioActualCLP !== null && epsCLP !== null && epsCLP > 0 ? safeDivide(precioActualCLP, epsCLP) : null;
      const pbvReal =
        precioActualCLP !== null && bvpsCLP !== null && bvpsCLP > 0 ? safeDivide(precioActualCLP, bvpsCLP) : null;

      const roaUltimo =
        netIncome !== null && netIncome !== undefined && activos !== null && activos !== undefined && activos !== 0
          ? safeDivide(netIncome, activos)
          : null;
      const margenNetoUltimo =
        netIncome !== null && netIncome !== undefined && ventas !== null && ventas !== undefined && ventas !== 0
          ? safeDivide(netIncome, ventas)
          : null;
      const margenOperacionalUltimo =
        ebit !== null && ebit !== undefined && ventas !== null && ventas !== undefined && ventas !== 0
          ? safeDivide(ebit, ventas)
          : null;

      const payoutUltimo = payoutPorAnio[lastYear] ?? null;
      const retencionUltimo = payoutUltimo !== null ? 1 - payoutUltimo : null;

      let deudaTotal = fd.balance.deudaTotal?.[lastYear];
      if (!Number.isFinite(deudaTotal)) {
        const deudaCorto = fd.balance.deudaCortoPlazo?.[lastYear];
        const deudaLargo = fd.balance.deudaLargoPlazo?.[lastYear];
        if (Number.isFinite(deudaCorto) || Number.isFinite(deudaLargo)) {
          deudaTotal = (deudaCorto || 0) + (deudaLargo || 0);
        } else {
          deudaTotal = null;
        }
      }
      const caja =
        (fd.balance.efectivo?.[lastYear] || 0) + (fd.balance.efectivoRestringido?.[lastYear] || 0);
      const deudaNetaBase = deudaTotal !== null ? deudaTotal - caja : null;
      const deudaNetaUSD = deudaNetaBase !== null ? toUSD(deudaNetaBase) : null;
      const deudaNetaSobrePatrimonio =
        patrimonio && patrimonio !== 0 && deudaNetaBase !== null
          ? safeDivide(deudaNetaBase, patrimonio)
          : null;

      const activoCorriente = fd.balance.activoCorriente?.[lastYear] ?? null;
      const pasivoCorriente = fd.balance.pasivoCorriente?.[lastYear] ?? null;
      const liquidezCorriente =
        activoCorriente !== null && pasivoCorriente ? safeDivide(activoCorriente, pasivoCorriente) : null;

      const gastosIntereses = fd.eerr.gastosIntereses?.[lastYear];
      let coberturaIntereses = null;
      if (Number.isFinite(ebit) && Number.isFinite(gastosIntereses) && gastosIntereses !== 0 && ebit > 0) {
        coberturaIntereses = ebit / (gastosIntereses < 0 ? gastosIntereses * -1 : gastosIntereses);
      }


      // Calcular Volatilidad ROE para m√©tricas estructurales
      const roeUltimo = roePorAnio[lastYear] ?? null;
      roeValidos = Object.values(roePorAnio).filter((v) => Number.isFinite(v));
      // Filtramos outliers extremos (opcional, pero buena pr√°ctica si hay errores de datos)
      roeValidos = roeValidos.filter(v => v > -1.0 && v < 2.0);

      // Calcular Desviaci√≥n Est√°ndar Muestral (N-1)
      const volatilidadROE = standardDeviation(roeValidos);

      const ventasSeries = buildSeries(fd.eerr.ventas, years);
      const beneficioSeries = buildSeries(fd.eerr.beneficioNeto, years);
      const patrimonioSeries = buildSeries(fd.balance.patrimonio, years);

      // CAGR EST√ÅNDAR (5 a√±os) - M√©todo √∫nico y est√°ndar de mercado
      const calcGrowth = (series) => {
        const last5 = trimLastN(series, 5);
        return computeCAGR(last5); // CAGR puro, retorna null si no es calculable
      };

      const cagrVentas5y = calcGrowth(ventasSeries);
      const cagrBeneficio5y = calcGrowth(beneficioSeries);
      const cagrPatrimonio5y = calcGrowth(patrimonioSeries);

      // Objeto CAGR simplificado (sin m√©todo ni volatilidad)
      const cagr = {
        ventas: cagrVentas5y,
        beneficio: cagrBeneficio5y,
        patrimonio: cagrPatrimonio5y
      };

      const actual = {
        epsCLP,
        bvpsCLP,
        perReal,
        pbvReal,
        roeUltimo,
        roaUltimo,
        margenNetoUltimo,
        margenOperacionalUltimo,
        payoutUltimo,
        retencionUltimo,
        deudaNetaBase,
        deudaNetaUSD,
        deudaNetaSobrePatrimonio,
        liquidezCorriente,
        coberturaIntereses,
      };
      actual.conclusiones = buildModule1ActualConclusions(actual, lastYear);

      // Volatility already calculated

      const estructural = {
        roePromedioNormalizado,
        roaPromedioNormalizado,
        margenNetoPromedioNormalizado,
        margenOperacionalPromedioNormalizado,
        payoutPromedioNormalizado,
        retencionPromedioNormalizado: payoutPromedioNormalizado !== null ? 1 - payoutPromedioNormalizado : null,
        volatilidadROE,
        consistenciaROE: classifyRoeConsistency(volatilidadROE),
        notaPromedios: 'Promedios excluyen a√±os con resultados negativos por tratarse de m√©tricas sensibles.',
      };
      estructural.conclusiones = buildModule1StructuralConclusions(estructural, cagr);

      const series = {
        ventas: ventasSeries,
        beneficio: beneficioSeries,
        patrimonio: patrimonioSeries,
        roe: roePorAnio,
        margenNeto: margenNetoPorAnio,
        margenOperacional: margenOperacionalPorAnio,
        payout: payoutPorAnio,
      };

      const debug = {
        ratios: {
          netIncome,
          activos,
          ventas,
          ebit,
        },
        roeValidos,
        roaValidos,
        margenNetoValidos,
        margenOperacionalValidos,
        payoutValidos,
        mensajePromedios: 'Promedios sensibles se calculan solo con a√±os positivos.',
      };


      // CONTEXT_METHOD_START
      // Publicar contexto de datos para consumo de m√≥dulos posteriores
      let conclusionFinal = null;
      try {
        const dataset = buildMod1Dataset(fd);
        const anomalies = detectAnomaliesMod1V2(dataset.lastYear);
        const recurrence = analyzeRecurrence(dataset.history);
        const diagnosis = diagnoseBusinessState(dataset.lastYear, anomalies, recurrence);
        const snapshotStatus = getSnapshotStatus(anomalies);
        const investigations = suggestInvestigationsMod1V2(anomalies, dataset.lastYear);
        const decision = methodologyDecision(diagnosis, anomalies, recurrence);

        // Generar conclusi√≥n final
        conclusionFinal = buildMod1Conclusion(snapshotStatus, diagnosis, decision, recurrence, dataset.lastYear, investigations);

        const module1Result = {
          yearBase: lastYear,
          actual,
          estructural,
          series,
          cagr,
          debug,
          conclusionFinal, // Agregar la conclusi√≥n al resultado
        };

        state.context = buildDataContext(fd, module1Result, diagnosis, anomalies);

        console.log('[CONTEXT] M√©todo decidido:', state.context?.method);
        console.log('[CONTEXT] Fuentes de datos:', state.context?.source);
      } catch (err) {
        console.warn('[CONTEXT] Error construyendo contexto:', err);
        state.context = null;
      }
      // CONTEXT_METHOD_END

      return {
        yearBase: lastYear,
        actual,
        estructural,
        series,
        cagr,
        debug,
        conclusionFinal, // Agregar la conclusi√≥n al return
      };
    }

    function classifyRoeConsistency(volatilidad) {
      if (!Number.isFinite(volatilidad)) return 'No concluyente';
      if (volatilidad < 0.05) return 'Alta';
      if (volatilidad < 0.1) return 'Media';
      return 'Baja';
    }

    // MOD1V2 JS START
    // Helper functions
    function num(x) {
      if (x === null || x === undefined) return null;
      if (typeof x === 'number') return Number.isFinite(x) ? x : null;
      if (typeof x === 'string') {
        const cleaned = x.replace(/[,\s]/g, '');
        const parsed = parseFloat(cleaned);
        return Number.isFinite(parsed) ? parsed : null;
      }
      return null;
    }

    function isFiniteNumber(x) {
      return x !== null && x !== undefined && Number.isFinite(x);
    }

    function fmt(x) {
      if (x === null || x === undefined || !Number.isFinite(x)) return 'N/A';
      if (Math.abs(x) >= 1e9) return fmtNumber(x / 1e9, 2) + 'B';
      if (Math.abs(x) >= 1e6) return fmtNumber(x / 1e6, 2) + 'M';
      if (Math.abs(x) >= 1e3) return fmtNumber(x / 1e3, 2) + 'K';
      return fmtNumber(x, 2);
    }

    // Construcci√≥n de dataset √∫ltimo a√±o + serie hist√≥rica
    function buildMod1Dataset(parsedData) {
      if (!parsedData || !parsedData.years || parsedData.years.length === 0) {
        return { lastYear: {}, history: [], availability: {} };
      }

      const years = parsedData.years || [];
      const lastYear = years[years.length - 1];
      const fd = parsedData;

      let fcfeValue = null;
      try {
        if (typeof calcFCFEReal === 'function' && fd.fcfe) {
          fcfeValue = calcFCFEReal(fd, lastYear);
        }
      } catch (e) {
        // Silenciosamente ignorar
      }

      const lastYearData = {
        year: lastYear,
        revenue: num(fd.eerr?.ventas?.[lastYear]),
        ebit: num(fd.eerr?.ebit?.[lastYear]),
        netIncome: num(fd.eerr?.beneficioNeto?.[lastYear]),
        taxExpense: num(fd.eerr?.impuesto?.[lastYear]),
        interestExpense: num(fd.eerr?.gastosIntereses?.[lastYear]),
        equity: num(fd.balance?.patrimonio?.[lastYear]),
        fcfe: fcfeValue,
        capex: num(fd.fcfe?.capex?.[lastYear]),
        debtNet: num(fd.balance?.deudaTotal?.[lastYear]) !== null
          ? num(fd.balance.deudaTotal[lastYear]) - (num(fd.balance?.efectivo?.[lastYear]) || 0) - (num(fd.balance?.efectivoRestringido?.[lastYear]) || 0)
          : null,
        currentAssets: num(fd.balance?.activoCorriente?.[lastYear]),
        currentLiabilities: num(fd.balance?.pasivoCorriente?.[lastYear]),
        cash: (num(fd.balance?.efectivo?.[lastYear]) || 0) + (num(fd.balance?.efectivoRestringido?.[lastYear]) || 0),
      };

      const history = [];
      for (const year of years) {
        let yearFcfe = null;
        try {
          if (typeof calcFCFEReal === 'function' && fd.fcfe) {
            yearFcfe = calcFCFEReal(fd, year);
          }
        } catch (e) {
          // Ignorar
        }

        history.push({
          year,
          revenue: num(fd.eerr?.ventas?.[year]),
          ebit: num(fd.eerr?.ebit?.[year]),
          netIncome: num(fd.eerr?.beneficioNeto?.[year]),
          equity: num(fd.balance?.patrimonio?.[year]),
          fcfe: yearFcfe,
        });
      }

      const availability = {
        hasRevenue: lastYearData.revenue !== null,
        hasEbit: lastYearData.ebit !== null,
        hasNetIncome: lastYearData.netIncome !== null,
        hasEquity: lastYearData.equity !== null,
        hasFcfe: lastYearData.fcfe !== null,
        hasHistory: history.length >= 2,
        hasTaxExpense: lastYearData.taxExpense !== null,
        hasInterestExpense: lastYearData.interestExpense !== null,
        hasCurrentRatio: lastYearData.currentAssets !== null && lastYearData.currentLiabilities !== null,
      };

      return { lastYear: lastYearData, history, availability };
    }

    // Detecci√≥n de anomal√≠as
    function detectAnomaliesMod1V2(lastYear) {
      const anomalies = [];
      const ni = num(lastYear.netIncome);
      const ebit = num(lastYear.ebit);
      const fcfe = num(lastYear.fcfe);
      const revenue = num(lastYear.revenue);
      const equity = num(lastYear.equity);
      const interestExpense = num(lastYear.interestExpense);

      if (ni !== null && ni < 0) {
        anomalies.push({
          code: 'NI_NEG',
          severity: 'high',
          label: 'Utilidad neta negativa',
          evidence: `Utilidad neta: ${fmtNumber(ni, 0)}`,
        });
      }

      if (ebit !== null && ni !== null && ebit > 0 && ni < 0) {
        anomalies.push({
          code: 'EBIT_POS_NI_NEG',
          severity: 'high',
          label: 'EBIT positivo pero utilidad neta negativa',
          evidence: `EBIT: ${fmtNumber(ebit, 0)}, Utilidad neta: ${fmtNumber(ni, 0)}`,
        });
      }

      if (fcfe !== null && fcfe < 0) {
        anomalies.push({
          code: 'FCFE_NEG',
          severity: 'medium',
          label: 'FCFE negativo',
          evidence: `FCFE: ${fmtNumber(fcfe, 0)}`,
        });
      }

      if (equity !== null && equity <= 0) {
        anomalies.push({
          code: 'EQUITY_NONPOS',
          severity: 'high',
          label: 'Patrimonio negativo o cero',
          evidence: `Patrimonio: ${fmtNumber(equity, 0)}`,
        });
      }

      if (ni !== null && revenue !== null && revenue !== 0) {
        const margin = ni / revenue;
        if (margin < -0.02) {
          anomalies.push({
            code: 'NET_MARGIN_VERY_LOW',
            severity: 'medium',
            label: 'Margen neto colapsado',
            evidence: `Margen neto: ${fmtPercent(margin)}`,
          });
        }
      }

      if (interestExpense !== null && ebit !== null && interestExpense > 0) {
        if (ebit <= interestExpense) {
          anomalies.push({
            code: 'INTEREST_STRESS',
            severity: 'high',
            label: 'Estr√©s por intereses',
            evidence: `EBIT: ${fmtNumber(ebit, 0)}, Intereses: ${fmtNumber(interestExpense, 0)}`,
          });
        }
      }

      return anomalies;
    }

    function getSnapshotStatus(anomalies) {
      if (!anomalies || anomalies.length === 0) {
        return { code: 'NORMAL', label: 'Normal', emoji: 'üü¢', severity: 'green' };
      }

      const hasHigh = anomalies.some((a) => a.severity === 'high');
      const hasMedium = anomalies.some((a) => a.severity === 'medium');

      if (hasHigh) {
        return { code: 'CRITICAL', label: 'Cr√≠tica', emoji: 'üî¥', severity: 'red' };
      }
      if (hasMedium) {
        return { code: 'ANOMALOUS', label: 'An√≥mala', emoji: 'üü°', severity: 'yellow' };
      }

      return { code: 'NORMAL', label: 'Normal', emoji: 'üü¢', severity: 'green' };
    }

    // Cat√°logo de reglas de investigaci√≥n
    const DIAG_RULES_MOD1V2 = [
      {
        when: (anomalies, lastYear) => anomalies.some((a) => a.code === 'EBIT_POS_NI_NEG'),
        hypothesis: 'Evento no operativo/contable (p.ej., impuestos retroactivos, multas, ajustes)',
        where: 'EERR',
        linesToCheck: [
          'Impuesto a las ganancias (corriente y diferido) (EERR)',
          'Otros ingresos/gastos no operacionales (EERR)',
          'Resultado antes de impuestos vs impuesto (EERR)',
        ],
        confirms: [
          'Tasa efectiva de impuesto anormalmente alta',
          'Cargos extraordinarios concentrados en el √∫ltimo a√±o',
        ],
        priority: 1,
      },
      {
        when: (anomalies, lastYear) => {
          const ni = num(lastYear.netIncome);
          const ebit = num(lastYear.ebit);
          return anomalies.some((a) => a.code === 'NI_NEG') && (ebit === null || ebit <= 0);
        },
        hypothesis: 'Deterioro operativo (m√°rgenes/volumen/costos)',
        where: 'EERR',
        linesToCheck: [
          'Margen bruto (Ventas ‚Äì Costo de ventas) (EERR)',
          'Gastos de administraci√≥n y ventas (EERR)',
          'Otros gastos operacionales (EERR)',
        ],
        confirms: [
          'Ca√≠da fuerte del margen bruto',
          'Costos creciendo m√°s r√°pido que ventas',
        ],
        priority: 2,
      },
      {
        when: (anomalies, lastYear) => {
          const ni = num(lastYear.netIncome);
          const fcfe = num(lastYear.fcfe);
          return anomalies.some((a) => a.code === 'FCFE_NEG') && ni !== null && ni >= 0;
        },
        hypothesis: 'Absorci√≥n de caja por CAPEX o capital de trabajo',
        where: 'FCFE',
        linesToCheck: [
          'CAPEX / compras de PPE (FCFE)',
          'Variaci√≥n capital de trabajo (FCFE)',
          'Flujo de operaci√≥n vs inversi√≥n (FCFE)',
        ],
        confirms: [
          'CAPEX excepcionalmente alto',
          'Aumento de capital de trabajo',
        ],
        priority: 3,
      },
      {
        when: (anomalies, lastYear) => {
          const ni = num(lastYear.netIncome);
          const fcfe = num(lastYear.fcfe);
          return anomalies.some((a) => a.code === 'FCFE_NEG') && ni !== null && ni < 0;
        },
        hypothesis: 'Estr√©s financiero/operativo (caja insuficiente)',
        where: 'FCFE',
        linesToCheck: [
          'Flujo operativo (FCFE)',
          'Financiamiento neto (deuda emitida - reembolsada) (FCFE)',
          'Deuda financiera y caja (Balance)',
        ],
        confirms: [
          'Necesidad de deuda para financiar operaciones',
          'Ca√≠da persistente de caja',
        ],
        priority: 1,
      },
      {
        when: (anomalies, lastYear) => anomalies.some((a) => a.code === 'EQUITY_NONPOS'),
        hypothesis: 'Erosi√≥n patrimonial (posible deterioro estructural / riesgo de quiebra)',
        where: 'BALANCE',
        linesToCheck: [
          'Patrimonio total (Balance)',
          'Resultados acumulados (Balance)',
          'Pasivos corrientes vs activos corrientes (Balance)',
        ],
        confirms: [
          'Patrimonio negativo o muy bajo',
          'Liquidez comprometida',
        ],
        priority: 1,
      },
      {
        when: (anomalies, lastYear) => anomalies.some((a) => a.code === 'INTEREST_STRESS'),
        hypothesis: 'Carga financiera excesiva (riesgo de incumplimiento)',
        where: 'EERR',
        linesToCheck: [
          'Gastos financieros vs EBIT (EERR)',
          'Cobertura de intereses (EERR)',
          'Deuda total y estructura de vencimientos (Balance)',
        ],
        confirms: [
          'EBIT insuficiente para cubrir intereses',
          'Deuda creciente o refinanciaci√≥n urgente',
        ],
        priority: 1,
      },
    ];

    function suggestInvestigationsMod1V2(anomalies, lastYear) {
      if (!anomalies || anomalies.length === 0) return [];

      const investigations = [];
      const seen = new Set();

      for (const rule of DIAG_RULES_MOD1V2) {
        if (rule.when(anomalies, lastYear)) {
          const key = `${rule.where}-${rule.hypothesis}`;
          if (!seen.has(key)) {
            seen.add(key);
            investigations.push({
              hypothesis: rule.hypothesis,
              where: rule.where,
              linesToCheck: rule.linesToCheck,
              confirms: rule.confirms,
              priority: rule.priority,
            });
          }
        }
      }

      const severityOrder = { high: 3, medium: 2, low: 1 };
      investigations.sort((a, b) => {
        const aAnomaly = anomalies.find((an) => {
          const rule = DIAG_RULES_MOD1V2.find((r) => r.hypothesis === a.hypothesis);
          return rule && rule.when(anomalies, lastYear);
        });
        const bAnomaly = anomalies.find((an) => {
          const rule = DIAG_RULES_MOD1V2.find((r) => r.hypothesis === b.hypothesis);
          return rule && rule.when(anomalies, lastYear);
        });
        const aSev = aAnomaly ? severityOrder[aAnomaly.severity] || 0 : 0;
        const bSev = bAnomaly ? severityOrder[bAnomaly.severity] || 0 : 0;
        if (bSev !== aSev) return bSev - aSev;
        return a.priority - b.priority;
      });

      return investigations;
    }

    function analyzeRecurrence(history) {
      if (!history || history.length < 2) {
        return {
          insufficient: true,
          yearsAnalyzed: history?.length || 0,
          lossYearsCount: 0,
          fcfeNegYearsCount: 0,
          consecutiveLossMaxStreak: 0,
          lastNYearsLossFlag: false,
          notes: ['Datos hist√≥ricos insuficientes para an√°lisis de recurrencia'],
        };
      }

      const lossYears = [];
      const fcfeNegYears = [];
      let currentStreak = 0;
      let maxStreak = 0;

      for (const yearData of history) {
        const ni = num(yearData.netIncome);
        const fcfe = num(yearData.fcfe);

        if (ni !== null && ni < 0) {
          lossYears.push(yearData.year);
          currentStreak++;
          maxStreak = Math.max(maxStreak, currentStreak);
        } else {
          currentStreak = 0;
        }

        if (fcfe !== null && fcfe < 0) {
          fcfeNegYears.push(yearData.year);
        }
      }

      const last3Years = history.slice(-3);
      const last3LossCount = last3Years.filter((y) => num(y.netIncome) !== null && num(y.netIncome) < 0).length;
      const lastNYearsLossFlag = last3LossCount >= 2;

      const notes = [];
      if (lossYears.length > 0) {
        notes.push(`${lossYears.length} a√±o(s) con p√©rdida de un total de ${history.length} analizados`);
      }
      if (fcfeNegYears.length > 0) {
        notes.push(`${fcfeNegYears.length} a√±o(s) con FCFE negativo`);
      }
      if (maxStreak >= 2) {
        notes.push(`Racha m√°xima de p√©rdidas consecutivas: ${maxStreak} a√±o(s)`);
      }
      if (lastNYearsLossFlag) {
        notes.push('P√©rdidas en 2 o m√°s de los √∫ltimos 3 a√±os');
      }

      return {
        insufficient: false,
        yearsAnalyzed: history.length,
        lossYearsCount: lossYears.length,
        fcfeNegYearsCount: fcfeNegYears.length,
        consecutiveLossMaxStreak: maxStreak,
        lastNYearsLossFlag,
        notes: notes.length > 0 ? notes : ['Sin anomal√≠as hist√≥ricas relevantes'],
      };
    }

    function generateQualityConclusion(roeEstructural, cagrVentas, margenEstructural, diagnosticoActual, roaEstructural, margenNetoEstructural, payoutEstructural, retencionEstructural, volatilidadROE, consistenciaROE, cagrPatrimonio) {
      // 1. Matriz Estricta de Calidad (ROE) y Crecimiento (Ventas)

      // Definir Estado ROE
      let roeStatus = "baja";
      if (roeEstructural > 0.15) roeStatus = "excelente";
      else if (roeEstructural >= 0.10) roeStatus = "buena";
      else if (roeEstructural >= 0.06) roeStatus = "promedio";
      else if (roeEstructural >= 0) roeStatus = "insuficiente";
      else roeStatus = "negativa"; // < 0

      // Definir Estado Crecimiento
      let growthStatus = "contraccion";
      if (cagrVentas > 0.10) growthStatus = "alto";
      else if (cagrVentas >= 0.02) growthStatus = "moderado";
      else if (cagrVentas >= 0) growthStatus = "estancamiento";
      else growthStatus = "contraccion"; // < 0

      // 2. Definir Arquetipo Estructural (El "ADN" del negocio)
      let archetype = {};

      // Arquetipos Extremos
      if (roeStatus === "negativa" || growthStatus === "contraccion" || roeEstructural < 0.06 && cagrVentas < -0.02) {
        archetype = { title: "üî• CAPITAL INTENSIVE / DESTROYER (DIF√çCIL)", type: "bad", desc: `Negocio con graves dificultades estructurales` };
      } else if (roeStatus === "excelente" && growthStatus === "alto") {
        archetype = { title: "üëë THE COMPOUNDER (M√ÅQUINA DE VALOR)", type: "excellent", desc: `Negocio de √©lite` };
      }
      // Arquetipos Intermedios
      else if (roeStatus === "excelente" || roeStatus === "buena") {
        if (growthStatus === "estancamiento" || growthStatus === "contraccion") {
          archetype = { title: "üêÆ Quality Cash Cow (Vaca Lechera)", type: "good", desc: `Negocio maduro y eficiente` };
        } else {
          archetype = { title: "üåü Quality Growth (Crecimiento de Calidad)", type: "good", desc: `Negocio s√≥lido en expansi√≥n` };
        }
      }
      else if (roeStatus === "promedio") {
        archetype = { title: "üé¢ The Average / Cyclical (Negocio Est√°ndar)", type: "neutral", desc: `Empresa promedio` };
      }
      else {
        // Default fallback for insufficient cases not caught by destroyer
        archetype = { title: "‚ö†Ô∏è Low Quality (Baja Calidad)", type: "warning", desc: `Negocio sub-est√°ndar` };
      }

      // 2. P√ÅRRAFO 1: Calidad y Perfil de Retorno (Risk/Reward)
      // Agrupa: Rentabilidad (ROE, ROA, Margen) + Crecimiento (Ventas, Patrimonio) + Riesgo (Volatilidad/Consistencia)
      const consistenciaTexto = consistenciaROE || 'No concluyente';
      // Mapeo texto
      const mapRoeText = {
        "excelente": "Excelente (>15%)", "buena": "Buena (10-15%)", "promedio": "Promedio (6-10%)", "insuficiente": "Insuficiente (<6%)", "negativa": "Negativa (Destruye Valor)"
      };

      // L√ìGICA DIN√ÅMICA DE SUSTANTIVOS Y ADJETIVOS
      // 1. Definir Adjetivo y Sustantivo por separado
      let sustantivoVentas = "";
      let adjetivoVentas = "";
      // Usar cagrVentas || 0 para evitar undefined
      const cagrVal = cagrVentas || 0;

      if (cagrVal >= 0.10) { sustantivoVentas = "Crecimiento"; adjetivoVentas = "Acelerado"; }
      else if (cagrVal >= 0.02) { sustantivoVentas = "Crecimiento"; adjetivoVentas = "Moderado"; }
      else if (cagrVal >= 0) { sustantivoVentas = "Din√°mica"; adjetivoVentas = "Estancada (Plana)"; }
      else if (cagrVal >= -0.05) { sustantivoVentas = "Contracci√≥n"; adjetivoVentas = "Leve"; }
      else { // Para ca√≠das fuertes (menores a -5%)
        sustantivoVentas = "Contracci√≥n"; adjetivoVentas = "Severa";
      }

      // 2. Construir la frase gramaticalmente correcta
      let fraseVentas = "";
      if (cagrVal >= 0) {
        fraseVentas = `y un ${sustantivoVentas} ${adjetivoVentas} (Ventas ${fmtPercent(cagrVal)})`;
      } else {
        // Frase para negativos
        fraseVentas = `y sufre una ${sustantivoVentas} ${adjetivoVentas} en ventas (${fmtPercent(cagrVal)})`;
      }

      // Juicio de Ratios Secundarios
      let margenAdj = "estable";
      if (margenNetoEstructural < 0.05) margenAdj = "estrecho";
      else if (margenNetoEstructural > 0.15) margenAdj = "robusto";

      let roaAdj = "adecuada";
      if (roaEstructural < 0.05) roaAdj = "baja"; // Ineficiente
      else if (roaEstructural > 0.10) roaAdj = "alta";

      let driverText = "";
      if (margenNetoEstructural < 0.05 || roaEstructural < 0.05) {
        driverText = `Su desempe√±o est√° limitado por un Margen Neto ${margenAdj} (${fmtPercent(margenNetoEstructural || 0)}) y una eficiencia de activos ${roaAdj} (ROA ${fmtPercent(roaEstructural || 0)}).`;
      } else {
        driverText = `Se apoya en un Margen Neto ${margenAdj} (${fmtPercent(margenNetoEstructural || 0)}) y una eficiencia de activos ${roaAdj} (ROA ${fmtPercent(roaEstructural || 0)}).`;
      }

      const parrafo1 = `<strong>An√°lisis Estructural (5A):</strong> ${archetype.desc}. Muestra una Rentabilidad Estructural <strong>${mapRoeText[roeStatus]}</strong> (ROE ${fmtPercent(roeEstructural)}) <strong>${fraseVentas}</strong>. ${driverText} Su Consistencia es ${consistenciaTexto} (Volatilidad ${fmtPercent(volatilidadROE || 0)}).`;

      // 3. P√ÅRRAFO 2: Estructura de Financiamiento
      // Agrupa: Pol√≠tica de capital (Payout/Retenci√≥n)
      let parrafo2 = "";

      const isPayoutNull = (payoutEstructural || 0) < 0.01 && (retencionEstructural || 0) < 0.01;
      const isEquityDestroyed = (cagrPatrimonio || 0) < 0;

      // L√≥gica de Redacci√≥n Inteligente
      if (isPayoutNull && isEquityDestroyed) {
        // CASO COMBINADO (El peor escenario)
        parrafo2 = `La pol√≠tica de asignaci√≥n de capital es no concluyente debido a la intermitencia de resultados. Esta din√°mica, sumada a las p√©rdidas, ha derivado en una destrucci√≥n de valor patrimonial del ${fmtPercent(cagrPatrimonio)} anual.`;
      } else {
        // Construcci√≥n modular
        let part1 = "";
        if (isPayoutNull) {
          part1 = "La pol√≠tica de asignaci√≥n de capital es no concluyente (probablemente debido a la falta de utilidades consistentes para distribuir o retener)";
        } else {
          part1 = `Su modelo de crecimiento se financia mediante una retenci√≥n del ${fmtPercent(retencionEstructural || 0)} (Payout ${fmtPercent(payoutEstructural || 0)})`;
        }

        let part2 = "";
        if (isEquityDestroyed) {
          // Si hubo payout normal pero destrucci√≥n de valor (ej: recompra masiva o p√©rdidas no cubiertas)
          part2 = `, pero esta din√°mica ha derivado en una destrucci√≥n de valor patrimonial del ${fmtPercent(cagrPatrimonio)} anual.`;
        } else {
          // Crecimiento normal
          part2 = `, lo que ha permitido un crecimiento patrimonial del ${fmtPercent(cagrPatrimonio || 0)} anual.`;
        }

        parrafo2 = part1 + part2;
      }

      // 4. P√ÅRRAFO 3: Diagn√≥stico Situacional (din√°mico seg√∫n stateCode)
      // Integra el an√°lisis del M√≥dulo 1 sobre el estado actual
      let parrafo3 = "";
      const state = diagnosticoActual?.stateCode || "NORMAL";

      if (state === 'HEALTHY_DISTORTION') {
        parrafo3 = `ACTUALIDAD: Vive una <strong>Distorsi√≥n Temporal</strong>. Sus resultados est√°n artificialmente bajos por eventos puntuales. Si la tesis estructural se mantiene (Margen Op. ${fmtPercent(margenEstructural)}), esta desconexi√≥n suele ser oportunidad.`;
      } else if (state === 'CYCLICAL_DOWNTURN') {
        parrafo3 = `ACTUALIDAD: Atraviesa un <strong>Ciclo Bajo</strong>. El retorno actual cae frente a su hist√≥rico consolidado. Es normal si la empresa es c√≠clica y tiene caja para aguantar.`;
      } else if (state === 'STRUCTURAL_DECLINE') {
        parrafo3 = `‚ö†Ô∏è <strong>Alerta de Deterioro:</strong> El problema es que los √∫ltimos a√±os muestran una degradaci√≥n progresiva. Cuidado: lo que antes era un buen negocio podr√≠a estar perdiendo su ventaja competitiva.`;
      } else if (state === 'DISTRESS_BANKRUPTCY_RISK') {
        parrafo3 = `‚õî <strong>SITUACI√ìN CR√çTICA:</strong> Independiente de su historia, hoy enfrenta riesgo financiero severo (Quiebra/Insolvencia). La supervivencia es la prioridad sobre la calidad hist√≥rica.`;
      } else {
        parrafo3 = `El desempe√±o actual es consistente con su historia, sin sorpresas mayores.`;
      }

      // 5. Ensamblar Mensaje (3 p√°rrafos con estructura clara)
      const message = `<strong class="block mb-2 text-sm font-bold uppercase opacity-80">${archetype.title}</strong>
                   <p class="mb-2">${parrafo1}</p>
                   <p class="mb-2">${parrafo2}</p>
                   <p>${parrafo3}</p>`;

      return { message, type: archetype.type };
    }

    function diagnoseBusinessState(lastYear, anomalies, recurrence) {
      const ni = num(lastYear.netIncome);
      const ebit = num(lastYear.ebit);
      const equity = num(lastYear.equity);
      const hasInterestStress = anomalies.some((a) => a.code === 'INTEREST_STRESS');
      const hasEquityNonPos = anomalies.some((a) => a.code === 'EQUITY_NONPOS');
      const currentAssets = num(lastYear.currentAssets);
      const currentLiabilities = num(lastYear.currentLiabilities);
      const currentRatio = currentAssets !== null && currentLiabilities !== null && currentLiabilities > 0
        ? currentAssets / currentLiabilities
        : null;

      // FORENSIC ANALYSIS: Identificar culpable de anomal√≠as
      let forensicNote = "";
      let culprit = null;
      let impact = null;
      const revenue = num(lastYear.revenue);

      // Si hay anomal√≠a de Utilidad Negativa (NI_NEG) o Margen Colapsado
      const hasNiNeg = anomalies.some((a) => a.code === 'NI_NEG');
      const hasEbitPosNiNeg = anomalies.some((a) => a.code === 'EBIT_POS_NI_NEG');

      if (hasNiNeg || hasEbitPosNiNeg) {
        const tax = Math.abs(num(lastYear.taxExpense) || 0);
        const cogs = num(lastYear.cogs) || 0;

        // 1. ¬øFue el Impuesto?
        if (ebit > 0 && ni < 0 && tax > ebit * 0.5) {
          culprit = "Impuestos";
          impact = "Transitorio";
          forensicNote = `Impuestos. La empresa es operativa (EBIT positivo), pero una carga tributaria inusual (${fmtNumber(tax)} MM) se comi√≥ toda la ganancia. Revisar si es un pago retroactivo o cambio de ley.`;
        }
        // 2. ¬øFueron los Costos de Venta? (Margen Bruto)
        else if (revenue && revenue > 0 && cogs > 0 && (revenue - cogs) < 0) {
          culprit = "Costos de Venta";
          impact = "Estructural";
          forensicNote = `Costos de Venta. La empresa pierde dinero desde la f√°brica (Margen Bruto negativo). Los precios de venta no cubren los costos directos. Problema comercial grave.`;
        }
        // 3. ¬øFue Ineficiencia Operativa?
        else if (ebit < 0 && revenue) {
          culprit = "Negocio Operativo";
          impact = "Estructural";
          forensicNote = `Negocio Operativo. El problema es estructural. Las ventas no cubren los costos operativos b√°sicos.`;
        }
        // 4. Gastos financieros o no operativos
        else if (ebit > 0 && ni < 0) {
          culprit = "Gastos No Op.";
          impact = "Transitorio";
          forensicNote = `Gastos No Operativos. La operaci√≥n es rentable (EBIT positivo), pero gastos financieros u otros items no operativos generan la p√©rdida neta.`;
        }
      }

      if (hasEquityNonPos || hasInterestStress || (currentRatio !== null && currentRatio < 0.5)) {
        const evidence = [];
        if (hasEquityNonPos) evidence.push('Patrimonio negativo o cero');
        if (hasInterestStress) evidence.push('EBIT insuficiente para cubrir intereses');
        if (currentRatio !== null && currentRatio < 0.5) evidence.push('Liquidez corriente muy baja (<0.5x)');
        if (recurrence && !recurrence.insufficient && recurrence.lossYearsCount >= 2) {
          evidence.push('P√©rdidas persistentes en a√±os recientes');
        }

        return {
          stateCode: 'DISTRESS_BANKRUPTCY_RISK',
          label: 'Riesgo de quiebra / estr√©s severo',
          severity: 'critical', // Changed from red to match new system
          emoji: 'üî¥',
          evidence: evidence.length > 0 ? evidence : ['Indicadores de estr√©s financiero severo'],
          forensicNote,
          reason: culprit,
          impact: impact || "Estructural"
        };
      }

      if (hasNiNeg && recurrence && !recurrence.insufficient) {
        if (recurrence.consecutiveLossMaxStreak >= 2 || recurrence.lastNYearsLossFlag) {
          const evidence = [];
          evidence.push('P√©rdidas repetidas en a√±os consecutivos');
          if (recurrence.fcfeNegYearsCount >= 2) {
            evidence.push('FCFE negativo en m√∫ltiples a√±os');
          }
          if (ebit !== null && ebit < 0) {
            evidence.push('EBIT negativo indica deterioro operativo');
          }

          return {
            stateCode: 'STRUCTURAL_DECLINE',
            label: 'Deterioro estructural',
            severity: 'critical',
            emoji: 'üî¥',
            evidence,
            forensicNote,
            reason: culprit,
            impact: impact || "Estructural"
          };
        }
      }

      if (hasNiNeg && recurrence && !recurrence.insufficient) {
        if (recurrence.lossYearsCount > 0 && recurrence.lossYearsCount < recurrence.yearsAnalyzed * 0.5) {
          const evidence = [];
          evidence.push('P√©rdidas aparecen de forma intermitente, no persistente');
          if (recurrence.consecutiveLossMaxStreak === 1) {
            evidence.push('P√©rdidas aisladas, posible ciclo econ√≥mico');
          }

          return {
            stateCode: 'CYCLICAL_DOWNTURN',
            label: 'C√≠clica en fase baja',
            severity: 'revisar',
            emoji: 'üü°',
            evidence,
            forensicNote,
            reason: culprit,
            impact: impact || "Revisar"
          };
        }
      }

      if ((hasEbitPosNiNeg || hasNiNeg) && equity !== null && equity > 0) {
        if (!recurrence || recurrence.insufficient || recurrence.lossYearsCount <= 1) {
          const evidence = [];
          if (hasEbitPosNiNeg) {
            evidence.push('EBIT positivo sugiere operaci√≥n sana');
          }
          evidence.push('Patrimonio positivo');
          if (recurrence && !recurrence.insufficient && recurrence.lossYearsCount === 0) {
            evidence.push('Sin p√©rdidas hist√≥ricas previas');
          } else {
            evidence.push('P√©rdida aislada o puntual');
          }

          return {
            stateCode: 'HEALTHY_DISTORTION',
            label: 'Sana con distorsi√≥n puntual',
            severity: 'ok',
            emoji: 'üü¢',
            evidence,
            forensicNote,
            reason: culprit,
            impact: impact || "Transitorio"
          };
        }
      }

      if (anomalies.length === 0) {
        return {
          stateCode: 'HEALTHY_DISTORTION',
          label: 'Sana con distorsi√≥n puntual',
          severity: 'green',
          emoji: 'üü¢',
          evidence: ['Sin anomal√≠as detectadas en el √∫ltimo a√±o'],
          forensicNote: '',
        };
      }

      return {
        stateCode: 'CYCLICAL_DOWNTURN',
        label: 'C√≠clica en fase baja',
        severity: 'yellow',
        emoji: 'üü°',
        evidence: ['Diagn√≥stico con baja confianza: datos hist√≥ricos limitados'],
        forensicNote,
      };
    }

    function methodologyDecision(diagnosis, anomalies, recurrence) {
      const decision = {
        useLastYearRatios: false,
        useNormalizedRatios: false,
        useMultiYearAverages: false,
        penalizeValuation: false,
        notes: [],
      };

      const stateCode = diagnosis.stateCode;

      if (stateCode === 'HEALTHY_DISTORTION') {
        decision.useLastYearRatios = false;
        decision.useNormalizedRatios = true;
        decision.useMultiYearAverages = true;
        decision.penalizeValuation = false;
        decision.notes.push('Ratios del √∫ltimo a√±o pueden estar distorsionados por eventos puntuales');
        decision.notes.push('Usar ratios normalizados y promedios multianuales para mejor representaci√≥n');
      } else if (stateCode === 'CYCLICAL_DOWNTURN') {
        decision.useLastYearRatios = false;
        decision.useNormalizedRatios = true;
        decision.useMultiYearAverages = true;
        decision.penalizeValuation = anomalies.some((a) => a.severity === 'high');
        decision.notes.push('Fase c√≠clica baja: normalizar ratios y usar promedios');
        if (decision.penalizeValuation) {
          decision.notes.push('Considerar penalizaci√≥n moderada en valoraci√≥n por estr√©s temporal');
        }
      } else if (stateCode === 'STRUCTURAL_DECLINE') {
        decision.useLastYearRatios = true;
        decision.useNormalizedRatios = false;
        decision.useMultiYearAverages = false;
        decision.penalizeValuation = true;
        decision.notes.push('Deterioro estructural: usar ratios del √∫ltimo a√±o (reflejan realidad actual)');
        decision.notes.push('Penalizar valoraci√≥n significativamente');
        decision.notes.push('Elevar tasa de descuento para reflejar mayor riesgo');
      } else if (stateCode === 'DISTRESS_BANKRUPTCY_RISK') {
        decision.useLastYearRatios = true;
        decision.useNormalizedRatios = false;
        decision.useMultiYearAverages = false;
        decision.penalizeValuation = true;
        decision.notes.push('Estr√©s severo: ratios actuales reflejan situaci√≥n cr√≠tica');
        decision.notes.push('Penalizaci√≥n fuerte en valoraci√≥n');
        decision.notes.push('Tasa de descuento elevada o considerar escenario de quiebra');
      }

      return decision;
    }

    function buildMod1Conclusion(snapshotStatus, diagnosis, decision, recurrence, lastYearData, investigations) {
      const parts = [];

      // 1. Extracci√≥n de Datos Clave
      const ebit = num(lastYearData?.ebit);
      const interest = num(lastYearData?.interestExpense);

      // 2. Clasificaci√≥n de Causales (Group A vs Group B)
      // Basado en las investigaciones sugeridas y datos duros

      const groupA_Causes = []; // Estructurales / Operativas
      const groupB_Causes = []; // Financieras / Puntuales / No Operativas

      if (investigations && investigations.length > 0) {
        investigations.forEach(inv => {
          const h = inv.hypothesis;
          // Mapeo de hip√≥tesis a grupos
          if (h.includes('Deterioro operativo') || h.includes('Erosi√≥n patrimonial') || h.includes('volumen') || h.includes('costos')) {
            groupA_Causes.push(h);
          } else if (h.includes('Evento no operativo') || h.includes('Carga financiera') || h.includes('Impuesto')) {
            groupB_Causes.push(h);
          }
        });
      }

      // Check EBIT directo para Grupo A
      if (ebit !== null && ebit < 0) {
        groupA_Causes.unshift('Resultado Operativo (EBIT) negativo');
      }

      // 3. Variables de Decisi√≥n
      const hasBadHistory = recurrence && (recurrence.lossYearsCount > 0 || recurrence.lastNYearsLossFlag);
      const isEbitPositive = ebit !== null && ebit > 0;
      const interestCoverage = (ebit !== null && interest !== null && interest > 0) ? (ebit / interest) : 999;

      const hasGroupA = groupA_Causes.length > 0;
      const hasGroupB = groupB_Causes.length > 0;

      // 4. EL JUEZ: L√≥gica de Sentencia

      // CASO 1: Deterioro Estructural (Prioridad Alta)
      // Condici√≥n: EBIT < 0 (ya incluido en hasGroupA) O (Cualquier Grupo A detectado + Historia Mala)
      if (hasGroupA && (!isEbitPositive || hasBadHistory)) {
        const causasStr = [...new Set(groupA_Causes)].join(', ').toLowerCase();
        parts.push(`Se detecta un problema ESTRUCTURAL. Aunque puedan existir factores financieros, el an√°lisis revela debilidades en la operaci√≥n central del negocio (${causasStr}), lo cual compromete la capacidad de la empresa para generar valor por s√≠ misma.`);

        // CASO 3: Riesgo de Solvencia (Mixto/Alerta)
        // Condici√≥n: EBIT > 0 pero Intereses consumen casi todo (Cobertura < 1)
      } else if (isEbitPositive && interestCoverage < 1) {
        parts.push('La empresa presenta un RIESGO DE SOLVENCIA. Aunque es operativa, su estructura de deuda y gastos financieros est√° asfixiando la rentabilidad operativa. No es necesariamente un problema de ventas, sino de apalancamiento excesivo.');

        // CASO 2: Situaci√≥n Puntual / Financiera
        // Condici√≥n: EBIT > 0 Y Causales son EXCLUSIVAMENTE Grupo B (Operationalmente sano)
      } else if (isEbitPositive && hasGroupB && !hasGroupA) {
        const causasStr = [...new Set(groupB_Causes)].join(', ').toLowerCase();
        parts.push(`Se detecta una situaci√≥n PUNTUAL o ESPEC√çFICA. La empresa mantiene un resultado operativo (EBIT) positivo, lo que descarta una falla estructural del negocio. El deterioro actual se explica principalmente por factores no operativos: ${causasStr}. Esto sugiere que el modelo de negocio es sano, pero requiere ajustes en su estructura de capital o gesti√≥n tributaria.`);

        // CASO 4: Default / Positivo
      } else {
        parts.push(`La compa√±√≠a mantiene una posici√≥n saludable (${snapshotStatus.label.toLowerCase()}). El diagn√≥stico actual es positivo y la empresa demuestra capacidad para generar valor operativo.`);
      }

      return parts.join(' ');
    }

    function renderMod1V2(rootEl, dataset, computed) {
      if (!rootEl) return;

      const { snapshotStatus, anomalies, investigations, recurrence, diagnosis, decision, conclusion } = computed;

      // 1. Fusi√≥n 1: Llenar el contenedor unificado (Snapshot + Anomalies + Recurrence)
      const mergedInitialEl = rootEl.querySelector('#mod1v2-merged-initial');
      if (mergedInitialEl) {
        // --- 1.1A Logic (Snapshot) ---
        const statusBadgeClass =
          snapshotStatus.severity === 'red'
            ? 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300'
            : snapshotStatus.severity === 'yellow'
              ? 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300'
              : 'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300';

        const snapshotHtml = `
          <div class="space-y-3 mb-4 border-b border-slate-200 dark:border-slate-700 pb-4">
            <h5 class="text-xs uppercase text-slate-400 font-bold">Foto √öltimo A√±o</h5>
            <div class="flex items-center gap-2">
              <span class="px-3 py-1 rounded-full text-xs font-medium ${statusBadgeClass}">${snapshotStatus.emoji} ${snapshotStatus.label}</span>
            </div>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-3 text-sm">
              <div><span class="text-slate-500">Ventas:</span> <span class="font-semibold">${fmt(dataset.lastYear.revenue)}</span></div>
              <div><span class="text-slate-500">EBIT:</span> <span class="font-semibold">${fmt(dataset.lastYear.ebit)}</span></div>
              <div><span class="text-slate-500">Utilidad neta:</span> <span class="font-semibold">${fmt(dataset.lastYear.netIncome)}</span></div>
              <div><span class="text-slate-500">Margen neto:</span> <span class="font-semibold">${dataset.lastYear.revenue && dataset.lastYear.netIncome !== null ? fmtPercent(safeDivide(dataset.lastYear.netIncome, dataset.lastYear.revenue)) : 'N/A'}</span></div>
              <div><span class="text-slate-500">ROE:</span> <span class="font-semibold">${dataset.lastYear.equity && dataset.lastYear.netIncome !== null ? fmtPercent(safeDivide(dataset.lastYear.netIncome, dataset.lastYear.equity)) : 'N/A'}</span></div>
              <div><span class="text-slate-500">FCFE:</span> <span class="font-semibold">${fmt(dataset.lastYear.fcfe)}</span></div>
              <div><span class="text-slate-500">Deuda neta:</span> <span class="font-semibold">${fmt(dataset.lastYear.debtNet)}</span></div>
            </div>
          </div>
        `;

        // --- 1.2A Logic (Anomalies) ---
        const anomaliesHtml =
          anomalies.length === 0
            ? '<p class="text-sm text-slate-500 mb-4 pb-4 border-b border-slate-200 dark:border-slate-700"><span class="text-xs uppercase text-slate-400 font-bold block mb-2">Anomal√≠as</span>No se detectan anomal√≠as relevantes.</p>'
            : `<div class="mb-4 pb-4 border-b border-slate-200 dark:border-slate-700">
                <h5 class="text-xs uppercase text-slate-400 font-bold mb-2">Anomal√≠as Detectadas</h5>
                <div class="flex flex-wrap gap-2">${anomalies
              .map((a) => {
                const severityClass =
                  a.severity === 'high'
                    ? 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300'
                    : 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300';
                return `<span class="px-3 py-1 rounded-full text-xs font-medium ${severityClass}">${a.label}</span>`;
              })
              .join('')}</div>
               </div>`;

        // --- 1.4A Logic (Recurrence) & 1.5A Logic (Diagnosis) Unified Grid ---

        // Prepare Recurrence HTML
        let recurrenceHtml = '';
        if (recurrence.insufficient) {
          recurrenceHtml = '<p class="text-sm text-slate-500">Datos insuficientes para an√°lisis de recurrencia.</p>';
        } else {
          recurrenceHtml = `
            <div class="space-y-2 text-sm">
              <div><span class="text-slate-500">A√±os analizados:</span> <span class="font-semibold">${recurrence.yearsAnalyzed}</span></div>
              <div><span class="text-slate-500">A√±os con p√©rdida:</span> <span class="font-semibold">${recurrence.lossYearsCount}</span></div>
              <div><span class="text-slate-500">A√±os con FCFE negativo:</span> <span class="font-semibold">${recurrence.fcfeNegYearsCount}</span></div>
              <div><span class="text-slate-500">Racha m√°xima de p√©rdidas:</span> <span class="font-semibold">${recurrence.consecutiveLossMaxStreak} a√±o(s)</span></div>
              ${recurrence.lastNYearsLossFlag ? '<div class="text-yellow-600 dark:text-yellow-400 font-semibold">‚ö†Ô∏è P√©rdidas en 2+ de los √∫ltimos 3 a√±os</div>' : ''}
              <div class="mt-3">
                <p class="text-xs font-semibold text-slate-600 dark:text-slate-400 mb-1">Notas:</p>
                <ul class="text-xs text-slate-600 dark:text-slate-400 list-disc list-inside space-y-1">
                  ${recurrence.notes.map((note) => `<li>${note}</li>`).join('')}
                </ul>
              </div>
            </div>
          `;
        }

        // Prepare Diagnosis HTML
        const diagSeverityClass =
          diagnosis.severity === 'red'
            ? 'bg-red-100 dark:bg-red-900/30 text-red-800 dark:text-red-300'
            : diagnosis.severity === 'yellow'
              ? 'bg-yellow-100 dark:bg-yellow-900/30 text-yellow-800 dark:text-yellow-300'
              : 'bg-green-100 dark:bg-green-900/30 text-green-800 dark:text-green-300';

        const diagnosisHtml = `
          <div class="h-full flex flex-col justify-center items-center text-center bg-slate-50 dark:bg-slate-900/40 rounded-lg p-4 border border-slate-200 dark:border-slate-700 shadow-sm">
            <div class="mb-2">
              <span class="px-3 py-1 rounded-full text-xs font-medium ${diagSeverityClass}">${diagnosis.emoji} ${diagnosis.label}</span>
            </div>
            <div class="w-full">
              <p class="text-xs font-semibold text-slate-600 dark:text-slate-400 mb-1 text-center">Evidencia:</p>
              <ul class="text-xs text-slate-600 dark:text-slate-400 list-none space-y-1 text-center">
                ${diagnosis.evidence.map((e) => `<li>${e}</li>`).join('')}
              </ul>
            </div>
            ${diagnosis.forensicNote ? `<div class="text-xs text-slate-700 dark:text-slate-300 mt-2 p-2 bg-amber-50 dark:bg-amber-900/20 rounded border border-amber-200 dark:border-amber-800 italic w-full text-center">${diagnosis.forensicNote}</div>` : ''}
          </div>
        `;

        // Render merged grid
        const combinedGrid = `
          <div class="grid grid-cols-1 gap-6 items-stretch">
            <div class="flex flex-col">
              <h5 class="text-xs uppercase text-slate-400 font-bold mb-3">Recurrencia Hist√≥rica</h5>
              <div class="flex-1">
                ${recurrenceHtml}
              </div>
            </div>
            <div class="flex flex-col h-full">
              <h5 class="text-xs uppercase text-slate-400 font-bold mb-3">Diagn√≥stico del Estado</h5>
              <div class="flex-1">
                ${diagnosisHtml}
              </div>
            </div>
          </div>
        `;

        mergedInitialEl.innerHTML = snapshotHtml + anomaliesHtml + combinedGrid;
      }

      // Removed: anomaliesEl, guidanceEl, recurrenceEl, diagnosisEl (all merged or deleted)

      // Removed: decisionEl (merged into conclusion)

      const conclusionEl = rootEl.querySelector('#mod1v2-conclusion');
      if (conclusionEl) {
        // UPDATE: Call buildMod1Conclusion with recurrence AND detailed data for multicausal logic
        const finalConclusionText = buildMod1Conclusion(snapshotStatus, diagnosis, decision, recurrence, dataset.lastYear, investigations);

        // Fusi√≥n 2: Mostrar Decisi√≥n Metodol√≥gica + Conclusi√≥n textual
        const decisionHtml = `
          <div class="space-y-3 mb-4 pb-4 border-b border-slate-200 dark:border-slate-700">
            <h5 class="text-xs uppercase text-slate-400 font-bold mb-2">Decisi√≥n Metodol√≥gica</h5>
            <div class="grid grid-cols-2 gap-3 text-sm">
              <div class="flex items-center justify-between">
                <span class="text-slate-500">Usar ratios √∫ltimo a√±o:</span>
                <span class="font-semibold">${decision.useLastYearRatios ? 'S√≠' : 'No'}</span>
              </div>
              <div class="flex items-center justify-between">
                <span class="text-slate-500">Usar ratios normalizados:</span>
                <span class="font-semibold">${decision.useNormalizedRatios ? 'S√≠' : 'No'}</span>
              </div>
              <div class="flex items-center justify-between">
                <span class="text-slate-500">Usar promedios multianuales:</span>
                <span class="font-semibold">${decision.useMultiYearAverages ? 'S√≠' : 'No'}</span>
              </div>
              <div class="flex items-center justify-between">
                <span class="text-slate-500">Penalizar valoraci√≥n:</span>
                <span class="font-semibold">${decision.penalizeValuation ? 'S√≠' : 'No'}</span>
              </div>
            </div>
            <div class="mt-3">
                <p class="text-xs font-semibold text-slate-600 dark:text-slate-400 mb-1">Impacto:</p>
                <ul class="text-xs text-slate-600 dark:text-slate-400 list-disc list-inside space-y-1">
                  ${decision.notes.map((note) => `<li>${note}</li>`).join('')}
                </ul>
            </div>
          </div>
        `;

        conclusionEl.innerHTML = decisionHtml + `
          <div class="mt-4">
            <h5 class="text-sm font-bold uppercase text-amber-600 dark:text-amber-400 mb-2 tracking-wide">Conclusi√≥n Final</h5>
            <p class="text-base text-slate-800 dark:text-slate-200 leading-relaxed font-medium">${finalConclusionText}</p>
          </div>
        `;
      }
    }
    // MOD1V2 JS END

    // Conclusiones autom√°ticas para el bloque 1A, citando ratios y umbrales.
    function buildModule1ActualConclusions(actual, lastYear) {
      if (!actual) return [];
      const conclusions = [];
      const yearLabel = lastYear || 'el √∫ltimo a√±o';
      const addConclusion = (text, refs) => {
        conclusions.push({ text, refs, severity: 'info' });
      };

      const roe = actual.roeUltimo;
      if (!Number.isFinite(roe)) {
        addConclusion(`Rentabilidad actual no evaluable: sin utilidad/patrimonio positivos en ${yearLabel} para calcular ROE.`, ['A5']);
      } else if (roe < 0) {
        addConclusion(`Rentabilidad actual negativa: ROE ${yearLabel} ${fmtPercent(roe)} (<0).`, ['A5']);
      } else if (roe < 0.15) {
        addConclusion(`Rentabilidad actual moderada: ROE ${yearLabel} ${fmtPercent(roe)} (entre 0% y 15%).`, ['A5']);
      } else {
        addConclusion(`Rentabilidad actual fuerte: ROE ${yearLabel} ${fmtPercent(roe)} (‚â•15%).`, ['A5']);
      }

      const margenOp = actual.margenOperacionalUltimo;
      if (!Number.isFinite(margenOp)) {
        addConclusion('Eficiencia operativa no concluyente: falta EBIT o ventas positivos para medir margen operacional.', ['A8']);
      } else if (margenOp < 0.05) {
        addConclusion(`Eficiencia operativa d√©bil: margen operacional ${fmtPercent(margenOp)} (<5%) respecto a la banda 5%-15%.`, ['A8']);
      } else if (margenOp < 0.15) {
        addConclusion(`Eficiencia operativa razonable: margen operacional ${fmtPercent(margenOp)} (5%-15%).`, ['A8']);
      } else {
        addConclusion(`Eficiencia operativa s√≥lida: margen operacional ${fmtPercent(margenOp)} (‚â•15%).`, ['A8']);
      }

      const per = actual.perReal;
      const eps = actual.epsCLP;
      if (!Number.isFinite(eps) || eps <= 0 || !Number.isFinite(per)) {
        const epsText = Number.isFinite(eps) ? fmtNumber(eps, 0) : 'N/A';
        addConclusion(`Valuaci√≥n no interpretable: EPS ${epsText} ‚â§ 0 impide calcular un PER confiable.`, ['A3', 'A1']);
      } else {
        let perBand = '';
        if (per <= 10) perBand = '(‚â§10, comprimido)';
        else if (per <= 20) perBand = '(10-20, habitual)';
        else perBand = '(>20, exigente)';
        const pbv = actual.pbvReal;
        let pbvFragment = 'sin datos de P/BV.';
        if (Number.isFinite(pbv)) {
          if (pbv <= 1) pbvFragment = `P/BV ${fmtNumber(pbv, 2)} (‚â§1x, descuento).`;
          else if (pbv <= 2) pbvFragment = `P/BV ${fmtNumber(pbv, 2)} (1-2x, rango habitual).`;
          else pbvFragment = `P/BV ${fmtNumber(pbv, 2)} (>2x, prima).`;
        }
        addConclusion(`Valuaci√≥n de mercado: PER ${fmtNumber(per, 1)} ${perBand} y ${pbvFragment}`, Number.isFinite(pbv) ? ['A3', 'A4'] : ['A3']);
      }

      const liquidity = actual.liquidezCorriente;
      const debtEq = actual.deudaNetaSobrePatrimonio;
      const coverage = actual.coberturaIntereses;
      const riskSnippets = [];
      riskSnippets.push(
        Number.isFinite(liquidity)
          ? `Liquidez ${fmtNumber(liquidity, 2)} ${liquidity > 2 ? '(>2x, holgada)' : liquidity >= 1 ? '(1-2x, adecuada)' : '(<1x, tensi√≥n)'}`
          : 'Liquidez sin datos'
      );
      riskSnippets.push(
        Number.isFinite(debtEq)
          ? `Deuda/patrimonio ${fmtNumber(debtEq, 2)} ${debtEq < 0.5 ? '(<0.5x, baja)' : debtEq <= 1 ? '(0.5-1x, moderada)' : '(>1x, alta)'}`
          : 'Apalancamiento sin datos'
      );
      riskSnippets.push(
        Number.isFinite(coverage)
          ? `Cobertura de intereses ${fmtNumber(coverage, 2)} ${coverage > 4 ? '(>4x, c√≥moda)' : coverage >= 2 ? '(2-4x, moderada)' : '(<2x, riesgosa)'}`
          : 'Cobertura sin datos'
      );
      addConclusion(`Perfil de riesgo financiero: ${riskSnippets.join('; ')}.`, ['A11', 'A12', 'A13']);

      const payout = actual.payoutUltimo;
      const ret = actual.retencionUltimo;
      if (!Number.isFinite(payout) || !Number.isFinite(ret)) {
        addConclusion('Pol√≠tica de dividendos no concluyente: payout/retenci√≥n no disponibles por utilidad negativa.', ['A9', 'A10']);
      } else if (payout >= 0.7) {
        addConclusion(`Distribuci√≥n elevada: payout ${fmtPercent(payout)} (‚â•70%) implica retenci√≥n limitada ${fmtPercent(ret)}.`, ['A9', 'A10']);
      } else if (payout >= 0.3) {
        addConclusion(`Distribuci√≥n equilibrada: payout ${fmtPercent(payout)} (30%-70%) y retenci√≥n ${fmtPercent(ret)}.`, ['A9', 'A10']);
      } else {
        addConclusion(`Alta retenci√≥n: payout ${fmtPercent(payout)} (<30%) permite reinversi√≥n de ${fmtPercent(ret)}.`, ['A9', 'A10']);
      }

      return conclusions.slice(0, 6);
    }

    // Evaluaci√≥n estructural 1B basada en promedios normalizados y CAGRs.
    function buildModule1StructuralConclusions(estructural, cagr = {}) {
      if (!estructural) return [];
      const conclusions = [];
      const addConclusion = (text, refs) => {
        conclusions.push({ text, refs, severity: 'info' });
      };

      const roe = estructural.roePromedioNormalizado;
      if (!Number.isFinite(roe)) {
        addConclusion('Calidad estructural no evaluable: ROE promedio limpio inexistente.', ['B1']);
      } else if (roe >= 0.2) {
        addConclusion(`Negocio de alta calidad: ROE estructural ${fmtPercent(roe)} (‚â•20%).`, ['B1']);
      } else if (roe >= 0.1) {
        addConclusion(`Negocio de calidad media: ROE estructural ${fmtPercent(roe)} (10%-20%).`, ['B1']);
      } else {
        addConclusion(`Calidad estructural d√©bil: ROE estructural ${fmtPercent(roe)} (<10%).`, ['B1']);
      }

      const std = estructural.volatilidadROE;
      const consist = estructural.consistenciaROE || 'No concluyente';
      if (Number.isFinite(std)) {
        addConclusion(`Estabilidad de rentabilidad: consistencia ${consist} con volatilidad ROE ${fmtPercent(std)} (umbrales 10% y 20%).`, ['B7', 'B8']);
      } else {
        addConclusion('No hay datos consistentes para medir la volatilidad/consistencia del ROE.', ['B7', 'B8']);
      }

      const margenOpProm = estructural.margenOperacionalPromedioNormalizado;
      if (!Number.isFinite(margenOpProm)) {
        addConclusion('M√°rgenes estructurales no concluyentes por a√±os negativos.', ['B4']);
      } else if (margenOpProm >= 0.15) {
        addConclusion(`Eficiencia operativa estructural s√≥lida: margen operacional promedio ${fmtPercent(margenOpProm)} (‚â•15%).`, ['B4']);
      } else if (margenOpProm >= 0.05) {
        addConclusion(`Eficiencia operativa aceptable: margen operacional promedio ${fmtPercent(margenOpProm)} (5%-15%).`, ['B4']);
      } else {
        addConclusion(`Eficiencia estructural baja: margen operacional promedio ${fmtPercent(margenOpProm)} (<5%).`, ['B4']);
      }

      const payoutProm = estructural.payoutPromedioNormalizado;
      const retProm = estructural.retencionPromedioNormalizado;
      if (!Number.isFinite(payoutProm) || !Number.isFinite(retProm)) {
        addConclusion('Reinversi√≥n hist√≥rica no evaluable: payout promedio sin datos positivos.', ['B5', 'B6']);
      } else if (retProm >= 0.6) {
        addConclusion(`Alta reinversi√≥n estructural: retenci√≥n ${fmtPercent(retProm)} (‚â•60%) con payout ${fmtPercent(payoutProm)}.`, ['B6', 'B5']);
      } else if (retProm >= 0.3) {
        addConclusion(`Reinversi√≥n equilibrada: retenci√≥n ${fmtPercent(retProm)} (30%-60%) y payout ${fmtPercent(payoutProm)}.`, ['B6', 'B5']);
      } else {
        addConclusion(`Baja reinversi√≥n: retenci√≥n ${fmtPercent(retProm)} (<30%) implica dependencia de factores externos.`, ['B6', 'B5']);
      }

      const cagrVentas = cagr.ventas;
      const cagrBenef = cagr.beneficio;
      const cagrPat = cagr.patrimonio;
      const growthParts = [];
      growthParts.push(
        Number.isFinite(cagrVentas) ? `ventas ${fmtPercent(cagrVentas)}` : 'ventas N/A'
      );
      growthParts.push(
        Number.isFinite(cagrBenef) ? `beneficio neto ${fmtPercent(cagrBenef)}` : 'beneficio N/A'
      );
      growthParts.push(
        Number.isFinite(cagrPat) ? `patrimonio ${fmtPercent(cagrPat)}` : 'patrimonio N/A'
      );
      const positives = [cagrVentas, cagrBenef, cagrPat].filter((val) => Number.isFinite(val) && val > 0).length;
      let growthDescriptor = 'Crecimiento hist√≥rico no concluyente.';
      if (positives >= 2) {
        growthDescriptor = 'Crecimiento hist√≥rico saludable.';
      } else if (positives === 1) {
        growthDescriptor = 'Crecimiento hist√≥rico mixto o irregular.';
      }
      addConclusion(`${growthDescriptor} Trayectoria: ${growthParts.join(', ')} (umbrales >0% y >10%).`, ['B9', 'B10', 'B11']);

      return conclusions.slice(0, 6);
    }

    function runModule2Multiples(fd, module1) {
      const years = trimArray(fd.years, 5);
      const shares = fd.datos.numeroAcciones || null;
      const tc = fd.datos.tipoCambio || 1;
      const baseCurrency = (fd.datos.monedaBase || 'CLP').toUpperCase();
      const priceCurrentCLP = fd.datos.precioActualCLP || null;

      const toUSD = (value) => {
        if (value === null || value === undefined) return null;
        return baseCurrency === 'CLP' ? safeDivide(value, tc) : value;
      };

      const perPorAnio = {};
      const pbvPorAnio = {};
      const debugRows = []; // NUEVO: Array para auditor√≠a

      // CONTEXT_METHOD_START
      // Usar EPS y BVPS desde contexto para el √∫ltimo a√±o
      const lastYear = fd.years[fd.years.length - 1];
      const ctx = state.context?.final;

      years.forEach((year) => {
        let epsBase, bvpsBase;

        if (year === lastYear && ctx) {
          // √öltimo a√±o: usar desde contexto
          epsBase = ctx.eps;
          bvpsBase = ctx.bvps;
          console.log(`[Multiples] A√±o ${year}: usando EPS/BVPS desde contexto (${state.context.source.eps}/${state.context.source.bvps})`);
        } else {
          // A√±os anteriores: calcular normalmente
          epsBase = shares ? safeDivide(fd.eerr.beneficioNeto[year], shares) : null;
          bvpsBase = shares ? safeDivide(fd.balance.patrimonio[year], shares) : null;
        }
        // CONTEXT_METHOD_END

        const epsCLP = epsBase === null ? null : (baseCurrency === 'USD' ? epsBase * tc : epsBase);
        const bvpsCLP = bvpsBase === null ? null : (baseCurrency === 'USD' ? bvpsBase * tc : bvpsBase);

        const perCalc = priceCurrentCLP && epsCLP ? safeDivide(priceCurrentCLP, epsCLP) : null;
        perPorAnio[year] = perCalc; // Guardamos el valor calculado
        pbvPorAnio[year] = priceCurrentCLP && bvpsCLP ? safeDivide(priceCurrentCLP, bvpsCLP) : null;

        // NUEVO: Guardar fila de debug
        debugRows.push({
          year,
          price: priceCurrentCLP,
          epsRaw: epsBase,
          epsCurrency: baseCurrency,
          tcUsed: tc,
          epsFinalCLP: epsCLP,
          perCalc: perCalc,
          isExcluded: false, // Se calcular√° despu√©s
          exclusionReason: ''
        });
      });

      const perValues = years.map((y) => perPorAnio[y]).filter((v) => v !== null);
      const pbvValues = years.map((y) => pbvPorAnio[y]).filter((v) => v !== null);

      // Calcular serie hist√≥rica de EV/FCFE para graficar
      const evFcfePorAnio = {};
      years.forEach((year) => {
        const marketCapYear = priceCurrentCLP && shares && tc ? safeDivide(priceCurrentCLP * shares, tc) : null;

        const deudaTotalYear = (fd.balance.deudaTotal?.[year] ??
          ((fd.balance.deudaCortoPlazo[year] || 0) + (fd.balance.deudaLargoPlazo[year] || 0))) || 0;
        const cajaYear = (fd.balance.efectivo[year] || 0) + (fd.balance.efectivoRestringido?.[year] || 0);
        const deudaNetaYear = deudaTotalYear - cajaYear;
        const deudaNetaYearUSD = toUSD(deudaNetaYear);

        const evYear = marketCapYear !== null && deudaNetaYearUSD !== null ? marketCapYear + deudaNetaYearUSD : null;
        const fcfeYear = calcFCFEReal(fd, year);
        const fcfeYearUSD = toUSD(fcfeYear);

        evFcfePorAnio[year] = evYear !== null && fcfeYearUSD && fcfeYearUSD > 0 ? safeDivide(evYear, fcfeYearUSD) : null;
      });

      // 1. CAMBIO: Usar Trimmed Mean para limpiar el "Per Pandemia" (ej. 106x)
      const perPromedio = trimmedMean(perValues);
      const pbvPromedio = trimmedMean(pbvValues);

      // NUEVO: L√≥gica de marcado de Trimmed Mean para Debug
      // Replicamos la l√≥gica de trimmedMean visualmente
      const validDebugRows = debugRows.filter(r => r.perCalc !== null && Number.isFinite(r.perCalc));

      if (validDebugRows.length >= 3) {
        // Identificar min y max para marcarlos como excluidos
        // Nota: trimmedMean ordena y quita el primero y el √∫ltimo
        const sortedRows = [...validDebugRows].sort((a, b) => a.perCalc - b.perCalc);
        const minRow = sortedRows[0];
        const maxRow = sortedRows[sortedRows.length - 1];

        // Marcar en el array original
        debugRows.forEach(row => {
          if (row.year === minRow.year) {
            row.isExcluded = true;
            row.exclusionReason = 'M√≠nimo (Outlier)';
          } else if (row.year === maxRow.year) {
            row.isExcluded = true;
            row.exclusionReason = 'M√°ximo (Outlier)';
          } else {
            row.isExcluded = false;
            row.exclusionReason = 'Incluido';
          }
        });
      } else {
        // Menos de 3 datos, todos incluidos (promedio simple)
        debugRows.forEach(row => {
          if (row.perCalc !== null) {
            row.isExcluded = false;
            row.exclusionReason = 'Incluido (Pocos datos)';
          } else {
            row.isExcluded = true;
            row.exclusionReason = 'Sin Datos';
          }
        });
      }

      const marketCapUSD =
        priceCurrentCLP && shares && tc
          ? safeDivide(priceCurrentCLP * shares, tc)
          : null;

      const deudaTotalBase =
        (fd.balance.deudaTotal?.[lastYear] ??
          ((fd.balance.deudaCortoPlazo[lastYear] || 0) +
            (fd.balance.deudaLargoPlazo[lastYear] || 0))) || 0;
      const cajaBase =
        (fd.balance.efectivo[lastYear] || 0) +
        (fd.balance.efectivoRestringido?.[lastYear] || 0);
      const deudaNetaBase = deudaTotalBase - cajaBase;

      const deudaNetaUSD = toUSD(deudaNetaBase);

      const evUSD =
        marketCapUSD !== null && deudaNetaUSD !== null
          ? marketCapUSD + deudaNetaUSD
          : null;

      const fcfeUltimoBase = calcFCFEReal(fd, lastYear);
      const fcfeUltimoUSD = toUSD(fcfeUltimoBase);

      const fcfeYield =
        fcfeUltimoUSD !== null && marketCapUSD
          ? safeDivide(fcfeUltimoUSD, marketCapUSD)
          : null;

      const evSobreFCFE =
        evUSD !== null && fcfeUltimoUSD
          ? safeDivide(evUSD, fcfeUltimoUSD)
          : null;

      // 2. NUEVO: An√°lisis Forense del Destino del Flujo (Para la conclusi√≥n)
      // Usamos Math.abs para asegurar magnitudes positivas al comparar
      const netIncomeLast = Math.abs(fd.eerr.beneficioNeto[lastYear] || 0);
      const capexLast = Math.abs(fd.fcfe.capex[lastYear] || 0);

      const debtRepaid = Math.abs(fd.fcfe.deudaReembolsada[lastYear] || 0);
      const debtIssued = Math.abs(fd.fcfe.deudaEmitida[lastYear] || 0);
      const netDebtPaydown = debtRepaid - debtIssued;

      let capexRatio = 0;
      let debtPaydownRatio = 0;
      if (netIncomeLast > 0) {
        capexRatio = capexLast / netIncomeLast;
        debtPaydownRatio = netDebtPaydown / netIncomeLast;
      }

      // ========== L√ìGICA DE PER NORMALIZADO ==========
      let perActualFinal = module1?.actual?.perReal ?? null;
      let perType = 'real';
      let perLabel = 'PER (Actual)';
      let epsNormalizado = null;

      try {
        // Obtener EPS del √∫ltimo a√±o
        const epsUltimoAnio = ctx?.eps ?? (shares ? safeDivide(fd.eerr.beneficioNeto[lastYear], shares) : null);

        console.log('[PER Normalizado] EPS √∫ltimo a√±o:', epsUltimoAnio);
        console.log('[PER Normalizado] PER actual (module1):', module1?.actual?.perReal);

        // Calcular normalizado si: EPS es negativo/cero O el PER actual es null
        const necesitaNormalizacion = (epsUltimoAnio !== null && epsUltimoAnio <= 0) || perActualFinal === null;

        if (necesitaNormalizacion && years.length >= 3) {
          console.log('[PER Normalizado] Detectadas p√©rdidas o PER null, calculando PER normalizado...');

          // Calcular serie hist√≥rica de EPS (solo positivos)
          const epsSeries = [];
          for (const year of years) {
            let eps = null;
            if (year === lastYear && ctx) {
              eps = ctx.eps;
            } else if (shares) {
              const beneficio = fd.eerr.beneficioNeto[year];
              if (beneficio !== null && beneficio !== undefined) {
                eps = safeDivide(beneficio, shares);
              }
            }

            if (eps !== null && eps > 0) {
              const epsCLP = baseCurrency === 'USD' ? eps * tc : eps;
              epsSeries.push(epsCLP);
              console.log(`[PER Normalizado] A√±o ${year}: EPS = ${eps.toFixed(2)} (CLP: ${epsCLP.toFixed(2)})`);
            }
          }

          console.log('[PER Normalizado] Serie EPS positivos:', epsSeries.length, 'valores');

          // Calcular EPS normalizado si hay suficientes datos
          if (epsSeries.length >= 3) {
            epsNormalizado = trimmedMean(epsSeries);
            console.log('[PER Normalizado] EPS normalizado calculado:', epsNormalizado.toFixed(2));

            if (epsNormalizado > 0 && priceCurrentCLP) {
              perActualFinal = safeDivide(priceCurrentCLP, epsNormalizado);
              if (perActualFinal !== null) {
                perType = 'normalizado';
                perLabel = 'PER (NORMALIZADO ULTIMO A√ëO)';
                console.log(`[PER Normalizado] ‚úÖ PER normalizado: ${perActualFinal.toFixed(1)}x (Precio: ${priceCurrentCLP}, EPS norm: ${epsNormalizado.toFixed(2)})`);
              }
            }
          } else {
            console.log('[PER Normalizado] ‚ö†Ô∏è Insuficientes datos hist√≥ricos positivos');
          }
        } else {
          console.log('[PER Normalizado] No se requiere normalizaci√≥n (EPS positivo y PER v√°lido)');
        }
      } catch (error) {
        console.error('[PER Normalizado] ‚ùå Error:', error);
        // Mantener valores por defecto en caso de error
      }

      // 3. ACTUALIZACI√ìN: Pasar m√©tricas forenses y ROE a la funci√≥n de conclusi√≥n
      // 5. Generar Conclusi√≥n
      const ebitLastYear = fd.eerr.ebit[lastYear] || -999; // Fallback to avoid undefined

      const conclusion = generatePERvsPBVConclusion(
        perActualFinal, // perVigenteUsado
        module1?.actual?.pbvReal ?? null, // pbvVigenteUsado
        perPromedio,
        pbvPromedio,
        fcfeYield,
        evSobreFCFE,
        capexRatio,
        debtPaydownRatio,
        module1?.actual?.roeReal, // roe opcional
        ebitLastYear,
        netIncomeLast // Reusing the already calculated netIncomeLast variable
      );

      return {
        years,
        perPorAnio,
        pbvPorAnio,
        evFcfePorAnio,
        perPromedio,
        pbvPromedio,
        perActual: perActualFinal,
        perType,
        perLabel,
        epsNormalizado,
        pbvActual: module1?.actual?.pbvReal ?? null,
        senales: {
          per: evaluateSignal(perActualFinal, perPromedio),
          pbv: evaluateSignal(module1?.actual?.pbvReal ?? null, pbvPromedio),
        },
        marketCapUSD,
        deudaNetaUSD,
        evUSD,
        fcfeUltimoUSD,
        fcfeYield,
        evSobreFCFE,
        recomendacionTexto: conclusion, // Guardamos el objeto conclusi√≥n completo
        debugEV: {
          deudaTotalBase,
          cajaBase,
          deudaNetaBase,
          deudaNetaUSD,
          marketCapUSD,
          evUSD,
          fcfeUltimoBase,
          fcfeUltimoUSD,
          evSobreFCFE,
          capexRatio,
          debtPaydownRatio,
          netIncomeLast,
          capexLast,
          debtRepaid,
          debtIssued,
          netDebtPaydown,
          netDebtPaydown,
        },
        debugRows, // NUEVO: Retornar datos crudos
      };
    }

    function runModule3MultiplesObj(fd, module1, module2, ke) {
      console.log("=== RUNNING UPDATED MODULE 3 (STRICT RULES) ===");
      // --- Helper Functions ---
      const median = (arr) => {
        if (!arr || arr.length === 0) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const middle = Math.floor(sorted.length / 2);
        if (sorted.length % 2 === 0) {
          return (sorted[middle - 1] + sorted[middle]) / 2;
        }
        return sorted[middle];
      };

      const convert = (val) => {
        if (val === null || val === undefined) return null;
        const tc = fd.datos.tipoCambio || 1;
        const baseCurrency = (fd.datos.monedaBase || 'CLP').toUpperCase();
        return baseCurrency === 'USD' ? val * tc : val;
      };

      // --- Data Extraction ---
      const shares = fd.datos.numeroAcciones;
      const lastYear = fd.years[fd.years.length - 1]; // e.g. 2024

      // Series Calculation (Raw Values in original currency)
      const netIncomeSeries = fd.years.map(y => fd.eerr.beneficioNeto[y] || 0);
      const equitySeries = fd.years.map(y => fd.balance.patrimonio[y] || 0);

      const currentNetIncome = fd.eerr.beneficioNeto[lastYear] || 0;
      const currentEquity = fd.balance.patrimonio[lastYear] || 0;

      // --- 1. EPS LOGIC (Independent) ---
      let epsBaseRaw = 0;
      const negativeYearsCount = netIncomeSeries.filter(n => n < 0).length;
      const isUnstable = currentNetIncome < 0 || negativeYearsCount > 1;

      if (isUnstable) {
        // "Inestable": Use MEDIAN of POSITIVE years
        const positiveIncomes = netIncomeSeries.filter(n => n > 0);
        if (positiveIncomes.length > 0) {
          epsBaseRaw = median(positiveIncomes) / shares;
          console.log("[Module3] EPS Logic: Unstable/Normalized (Median of Positives)");
        } else {
          epsBaseRaw = 0; // All negative: fallback to 0
        }
      } else {
        // "Estable": Use Last Year
        epsBaseRaw = currentNetIncome / shares;
        console.log("[Module3] EPS Logic: Stable (Last Year)");
      }

      // --- 2. BVPS LOGIC (Independent) ---
      let bvpsBaseRaw = 0;
      if (currentEquity > 0) {
        // Standard: Stock value is accumulated, so Last Year is the truth.
        bvpsBaseRaw = currentEquity / shares;
        console.log("[Module3] BVPS Logic: Standard (Last Year)");
      } else {
        // Bankruptcy Risk: Fallback
        bvpsBaseRaw = median(equitySeries) / shares;
        console.log("[Module3] BVPS Logic: Bankruptcy Fallback (Median)");
      }

      // --- Final Conversions ---
      const epsBase = convert(epsBaseRaw);
      const bvpsBase = convert(bvpsBaseRaw);

      // Auxiliary values for compatibility (fill with same base)
      const epsUltimoCLP = convert(currentNetIncome / shares);
      const epsAverageCLP = convert(median(netIncomeSeries) / shares); // Just as reference
      const bvpsUltimoCLP = convert(currentEquity / shares);

      // --- 3. Target Calculations (Existing Logic) ---
      const cagrEPS = module1?.cagr?.beneficio ?? null;
      const cagrVentas = module1?.cagr?.ventas ?? null;
      const pegDato = fd.datos.peg ?? null;
      const perHist = module2.perPromedio;

      let perGrow = null;
      if (pegDato !== null && cagrVentas !== null) {
        const growthPct = cagrVentas * 100;
        perGrow = pegDato * growthPct;
      } else if (cagrEPS !== null) {
        perGrow = Math.max(5, 10 + cagrEPS * 100);
      } else if (perHist) {
        perGrow = perHist;
      }

      const perObj = perHist && perGrow ? (perHist + perGrow) / 2 : perHist || perGrow;
      const gPerp = fd.datos.gPerpetuidad || 0.02;

      // Use Structural Return on Equity if available, otherwise implied
      const roePromedio = module1?.estructural?.roePromedioNormalizado || (bvpsBase ? epsBase / bvpsBase : 0.10);

      const pbvObj = roePromedio !== null && ke && ke !== gPerp ? (roePromedio - gPerp) / (ke - gPerp) : null;

      let precioPerObj = null;
      if (perObj && epsBase !== null && epsBase > 0) {
        precioPerObj = epsBase * perObj;
      }

      const precioPbvObj = bvpsBase && pbvObj ? bvpsBase * pbvObj : null;

      return {
        cagrEPS,
        cagrVentas,
        perHist,
        perGrow,
        perObj,
        pbvObj,
        epsBase,
        bvpsBase,
        epsUltimoCLP,
        epsAverageCLP,
        bvpsUltimoCLP,
        precioPerObj,
        precioPbvObj,
        ke,
        gPerp,
        roeUsado: roePromedio,
        pegDato,
      };
    }

    function runModule4Proyecciones(fd, opciones) {
      const shares = fd.datos.numeroAcciones || null;
      const lastYear = fd.years[fd.years.length - 1];
      const tc = fd.datos.tipoCambio || 1;
      const baseCurrency = (fd.datos.monedaBase || 'CLP').toUpperCase();

      const convertCLP = (value) => {
        if (value === null || value === undefined) return null;
        return baseCurrency === 'USD' ? value * tc : value;
      };

      // --- 1. DEFINICI√ìN DEL MOTOR DE CRECIMIENTO (CONSISTENCIA DCF) ---
      // Usamos la misma 'g' que alimenta al DCF para coherencia total
      const gExp = opciones.gExplicita ?? fd.datos.gExplicita ?? 0.1;

      // --- 2. SELECCI√ìN INTELIGENTE DEL A√ëO BASE ---
      // Objetivo: No proyectar desde p√©rdidas. Si el a√±o actual es malo, usamos la capacidad normalizada.

      const ctx = state.context?.final; // Contexto calculado en M√≥dulo 1
      const actualNetIncome = fd.eerr.beneficioNeto[lastYear] || 0;
      const actualEquity = fd.balance.patrimonio[lastYear] || 0;

      let baseUtilidad, basePatrimonio;
      let usingNormalizedBase = false;

      // Si el √∫ltimo a√±o es negativo o el contexto sugiere normalizar (por anomal√≠a detectada en Mod 1)
      if (actualNetIncome <= 0 || (state.context?.method?.mode === 'NORMALIZADO')) {
        // PLAN B: BASE NORMALIZADA
        if (ctx && ctx.eps && shares) {
          baseUtilidad = ctx.eps * shares; // Reconstruir utilidad desde EPS estructural del M√≥dulo 1
          basePatrimonio = ctx.equity || actualEquity;
          usingNormalizedBase = true;
        } else {
          // Fallback de emergencia: Promedio simple de a√±os positivos
          const utilidadesPositivas = fd.years.map(y => fd.eerr.beneficioNeto[y]).filter(v => v > 0);
          baseUtilidad = utilidadesPositivas.length ? utilidadesPositivas.reduce((a, b) => a + b, 0) / utilidadesPositivas.length : 0;
          basePatrimonio = actualEquity;
        }
      } else {
        // PLAN A: BASE REAL (√öltimo a√±o sano)
        baseUtilidad = actualNetIncome;
        basePatrimonio = actualEquity;
      }

      // --- 3. C√ÅLCULO DE PAYOUT/RETENCI√ìN ESTRUCTURAL ---
      // Objetivo: Evitar Payout 0% / Retenci√≥n 100% por un mal a√±o.

      let payoutBase, retencion;

      // Calculamos el Payout Hist√≥rico Promedio (Trimmed) para tener una referencia sana
      const historicalPayouts = fd.years.map(y => {
        const ni = fd.eerr.beneficioNeto[y];
        const div = Math.abs(fd.fcfe.dividendos[y] || fd.eerr.dividendos[y] || 0); // Absoluto por seguridad
        if (ni > 0) return div / ni;
        return null;
      }).filter(x => x !== null && x <= 1.5); // Filtramos payouts absurdos > 150%

      let historicalPayoutAvg = 0.4; // Default industria conservador
      if (historicalPayouts.length > 0) {
        // Trimmed mean local simple
        const sorted = [...historicalPayouts].sort((a, b) => a - b);
        const trimmed = sorted.length > 2 ? sorted.slice(1, -1) : sorted;
        historicalPayoutAvg = trimmed.reduce((a, b) => a + b, 0) / trimmed.length;
      }

      // DECISI√ìN: ¬øQu√© Payout usar?
      if (usingNormalizedBase || actualNetIncome <= 0) {
        // Si estamos normalizando, usamos obligatoriamente el payout hist√≥rico
        payoutBase = historicalPayoutAvg;
      } else {
        // Si usamos a√±o real, intentamos usar el payout real, pero con "barandas"
        const divLast = Math.abs(fd.fcfe.dividendos[lastYear] || fd.eerr.dividendos[lastYear] || 0);
        const payoutActual = divLast / actualNetIncome;

        // Si el payout actual es extremo (<5% o >100%), asumimos que es at√≠pico y volvemos al hist√≥rico
        if (payoutActual < 0.05 || payoutActual > 1.0) {
          payoutBase = historicalPayoutAvg;
        } else {
          payoutBase = payoutActual;
        }
      }

      retencion = 1 - payoutBase;

      // --- 4. PROYECCI√ìN (Tabla) ---
      const tabla = [];
      let utilidad = baseUtilidad;
      let patrimonio = basePatrimonio;

      // Fila Base (A√±o 0) para referencia visual
      tabla.push({
        year: "Base",
        utilidad: baseUtilidad,
        patrimonio: basePatrimonio,
        eps: convertCLP(shares ? baseUtilidad / shares : 0),
        bvps: convertCLP(shares ? basePatrimonio / shares : 0),
        isProjection: false
      });

      for (let i = 1; i <= 5; i++) {
        utilidad = utilidad * (1 + gExp);
        const utilidadRetenida = utilidad * retencion;
        patrimonio = patrimonio + utilidadRetenida;

        const eps = shares ? safeDivide(utilidad, shares) : null;
        const bvps = shares ? safeDivide(patrimonio, shares) : null;

        tabla.push({ year: lastYear + i, utilidad, patrimonio, eps: convertCLP(eps), bvps: convertCLP(bvps), isProjection: true });
      }

      // --- 5. L√ìGICA INTELIGENTE DE CONCLUSIONES ---

      // 1. Obtener diagn√≥stico del M√≥dulo 1 (si existe)
      const diagCode = state.context?.diagnosis?.stateCode || 'UNKNOWN';
      const esTransitorio = diagCode === 'HEALTHY_DISTORTION' || diagCode === 'CYCLICAL_DOWNTURN';
      const esGrave = diagCode === 'STRUCTURAL_DECLINE' || diagCode === 'DISTRESS_BANKRUPTCY_RISK';

      // 2. Definir Nota Visual del Gr√°fico
      let graphNote = "";
      if (usingNormalizedBase) {
        if (esTransitorio) {
          graphNote = `<br><br><strong>üìà Interpretaci√≥n del Gr√°fico:</strong> El salto inicial es t√©cnico. El modelo ignora la ca√≠da puntual de este a√±o y proyecta desde la capacidad "normal" de la empresa.`;
        } else {
          graphNote = `<br><br><strong>üìà Interpretaci√≥n del Gr√°fico:</strong> El rebote inicial es una hip√≥tesis de recuperaci√≥n. Asume que la empresa deja de perder dinero inmediatamente.`;
        }
      } else {
        graphNote = `<br><br><strong>üìà Interpretaci√≥n del Gr√°fico:</strong> La curva sigue la inercia natural del negocio basada en su pol√≠tica de reinversi√≥n actual.`;
      }

      // 3. Matriz de Decisi√≥n
      let conclusion = {};

      if (usingNormalizedBase) {
        // CASO: SE US√ì BASE NORMALIZADA (El a√±o real fue malo o an√≥malo)

        if (esTransitorio) {
          // SUB-CASO A: EL DIAGN√ìSTICO DICE QUE ES TRANSITORIO (Empresa Buena, A√±o Malo)
          conclusion = {
            title: "üìâ NORMALIZACI√ìN T√âCNICA (EVENTO TRANSITORIO)",
            message: `El modelo ha detectado que la ca√≠da en el √∫ltimo ejercicio (${fmtCurrency(actualNetIncome)}) responde a un <strong>evento puntual o ciclo bajo</strong>, no a un fallo estructural del negocio (ver Diagn√≥stico M1).<br><br>Por tanto, la proyecci√≥n descarta este a√±o at√≠pico y normaliza la rentabilidad para reflejar la verdadera capacidad de generaci√≥n de valor. Se asume que el bache es recuperable.` + graphNote,
            type: "info", // AZUL
            icon: "üìâ"
          };
        } else {
          // SUB-CASO B: ES ESTRUCTURAL, GRAVE O DESCONOCIDO (Empresa Mala)
          conclusion = {
            title: "‚õî NORMALIZACI√ìN DE EMERGENCIA (TURNAROUND)",
            message: `El gr√°fico muestra un rebote te√≥rico. <strong>Esto NO es el estado actual.</strong><br><br>Responde a que la empresa report√≥ p√©rdidas o deterioro severo en el √∫ltimo ejercicio. El modelo ha forzado una recuperaci√≥n te√≥rica porque proyectar p√©rdidas crecientes har√≠a incalculable el valor.<br><br><strong>Advertencia:</strong> Si no se resuelven los problemas estructurales detectados, esta proyecci√≥n es optimista.` + graphNote,
            type: "bad", // ROJO
            icon: "üõë"
          };
        }

      } else {
        // CASO: PROYECCI√ìN EST√ÅNDAR (A√±o base normal)
        const roeHistorico = ctx?.roe || 0.15;
        const roeNecesario = retencion > 0.05 ? gExp / retencion : 0;

        if (roeNecesario > roeHistorico * 1.3) {
          conclusion = {
            title: "üöÄ Proyecci√≥n Exigente (Alerta)",
            message: `El crecimiento proyectado del ${fmtPercent(gExp)} exige un ROE futuro del <strong>${fmtPercent(roeNecesario)}</strong>, muy superior a su historia (${fmtPercent(roeHistorico)}). Revisar si es realista.` + graphNote,
            type: "warning", icon: "üî•"
          };
        } else {
          conclusion = {
            title: "‚öñÔ∏è Trayectoria Coherente",
            message: `Proyecci√≥n s√≥lida. El crecimiento esperado est√° alineado con la rentabilidad hist√≥rica y la pol√≠tica de reinversi√≥n de la empresa.` + graphNote,
            type: "good", icon: "‚úÖ"
          };
        }
      }

      // 4. L√ìGICA DE NARRATIVA: "INTERPRETACI√ìN DE LA TRAYECTORIA"
      // Centralizamos este texto para uso en Dashboard Ejecutivo
      let trajectoryText = "";
      const isSurvival = (diagCode === 'STRUCTURAL_DECLINE' || diagCode === 'DISTRESS_BANKRUPTCY_RISK') || (retencion > 0.95 && gExp < 0.06);

      const fmtPctLocal = (n) => (n * 100).toFixed(1) + "%";

      if (isSurvival) {
        trajectoryText = `La empresa retiene el <strong>${fmtPctLocal(retencion)}</strong> de sus utilidades pero en contexto de baja rentabilidad (Supervivencia). La proyecci√≥n del <strong>${fmtPctLocal(gExp)}</strong> es te√≥rica y depende de revertir el deterioro.`;
      } else {
        trajectoryText = `El gr√°fico visualiza la tesis de crecimiento sustentada en una pol√≠tica de reinversi√≥n del <strong>${fmtPctLocal(retencion)}</strong> de sus utilidades, motor matem√°tico del crecimiento compuesto del <strong>${fmtPctLocal(gExp)}</strong>.`;
      }

      return {
        payoutBase,
        retencion,
        gExp,
        tabla,
        conclusion,
        usingNormalizedBase,
        trajectoryText
      };
    }

    function generateDebtConclusion(debtEquity, currentRatio, interestCoverage, netDebt, patrimonio, ebit) {
      // 1. Validaciones
      if (debtEquity === null && currentRatio === null) return { title: "Sin Datos", message: "Faltan datos de balance.", type: "neutral", icon: "‚ö™" };

      // 2. Definici√≥n de Estados
      let title = "";
      let message = "";
      let type = "neutral";
      let icon = "‚öñÔ∏è";

      // --- CASOS BORDE CR√çTICOS (KILL SWITCHES) ---

      // CASO X: Quiebra T√©cnica (Patrimonio Negativo)
      if (patrimonio !== null && patrimonio <= 0) {
        title = "‚õî INSOLVENCIA PATRIMONIAL (QUIEBRA T√âCNICA)";
        message = "Situaci√≥n terminal. El Patrimonio es negativo, lo que significa que la empresa no pertenece a sus accionistas, sino enteramente a sus acreedores. Est√° t√©cnicamente quebrada.";
        type = "bad";
        icon = "‚ò†Ô∏è";
        return { title, message, type, icon };
      }

      // CASO Y: D√©ficit Operativo (P√©rdida a nivel EBIT)
      if (ebit !== null && ebit <= 0) {
        title = "üî• D√âFICIT OPERATIVO (SIN COBERTURA)";
        message = "No se puede calcular cobertura de intereses porque la empresa pierde dinero a nivel operativo (EBIT negativo). Es una situaci√≥n de ALTO RIESGO: si no tiene una caja neta gigantesca, la empresa est√° quemando valor y dependiendo de deuda externa para sobrevivir.";
        type = "bad";
        icon = "üî•";
        return { title, message, type, icon };
      }


      // --- CASOS NORMALES ---

      // CASO A: CAJA NETA POSITIVA (Fortaleza total)
      if (netDebt !== null && netDebt < 0) {
        title = "üõ°Ô∏è Fortaleza Financiera (Cash King)";
        const liquidezText = currentRatio !== null ? `Su liquidez de <strong>${fmtNumber(currentRatio, 2)}x</strong>` : "Su posici√≥n de liquidez";
        message = `La empresa tiene una posici√≥n de <strong>Caja Neta Positiva</strong> (tiene m√°s efectivo que deuda financiera). ${liquidezText} blinda la operaci√≥n ante crisis y le otorga flexibilidad total para financiar crecimiento o dividendos sin riesgo de cr√©dito.`;
        type = "excellent";
        icon = "üíé";
      }
      // CASO B: ESTR√âS FINANCIERO (Peligro)
      else if ((interestCoverage !== null && interestCoverage < 1.5) || (currentRatio !== null && currentRatio < 0.8)) {
        title = "üî• Alerta de Estr√©s Financiero";
        message = "La situaci√≥n es delicada. ";

        if (currentRatio !== null && currentRatio < 1) {
          message += `Existe un d√©ficit de liquidez inmediato (Ratio Corriente <strong>${fmtNumber(currentRatio, 2)}x</strong>), dificultando el pago de obligaciones a corto plazo. `;
        }

        if (interestCoverage !== null && interestCoverage < 1.5) {
          message += `La generaci√≥n operativa es insuficiente, cubriendo apenas <strong>${fmtNumber(interestCoverage, 2)} veces</strong> los intereses, lo que eleva el riesgo de impago.`;
        }

        type = "bad";
        icon = "üî•";
      }
      // CASO C: ALTO APALANCAMIENTO (Riesgo Medio)
      else if (debtEquity > 1.5) {
        title = "‚ö†Ô∏è Estructura Agresiva";
        const coberturaText = interestCoverage !== null ? ` Aunque su cobertura de intereses es manejable (<strong>${fmtNumber(interestCoverage, 2)}x</strong>),` : "";
        message = `La empresa opera con una carga de deuda significativa (<strong>${fmtNumber(debtEquity, 2)}x Patrimonio</strong>).${coberturaText} esta estructura de capital reduce el margen de error ante una ca√≠da en ventas o subida de tasas.`;
        type = "warning";
        icon = "‚ö†Ô∏è";
      }
      // CASO D: SALUDABLE
      else {
        title = "‚úÖ Estructura Equilibrada";
        const deudaText = debtEquity !== null ? `<strong>${fmtPercent(debtEquity)}</strong>` : "un nivel saludable";
        const liquidezText = currentRatio !== null ? `<strong>${fmtNumber(currentRatio, 2)}x</strong>` : "adecuada";
        const coberturaText = interestCoverage !== null ? `<strong>${fmtNumber(interestCoverage, 2)} veces</strong>` : "c√≥modamente";

        message = `La empresa mantiene un nivel de deuda saludable, equivalente al ${deudaText} de su Patrimonio. Cuenta con una Liquidez Corriente holgada de ${liquidezText} para operar sin estr√©s y cubrir sus pasivos de corto plazo, y sus beneficios operativos cubren ${coberturaText} los gastos financieros. El apalancamiento parece productivo y sostenible.`;
        type = "good";
        icon = "‚úÖ";
      }

      return { title, message, type, icon };
    }

    function runModule5Deuda(fd) {
      const lastYear = fd.years[fd.years.length - 1];

      // 1. C√°lculo de Ratios Actuales (Foto)
      let deudaTotalLast = fd.balance.deudaTotal?.[lastYear];
      if (!Number.isFinite(deudaTotalLast)) {
        deudaTotalLast = (fd.balance.deudaCortoPlazo[lastYear] || 0) + (fd.balance.deudaLargoPlazo[lastYear] || 0);
      }
      const cajaLast = (fd.balance.efectivo[lastYear] || 0) + (fd.balance.efectivoRestringido?.[lastYear] || 0);
      const deudaNetaLast = deudaTotalLast - cajaLast;
      const patrimonioLast = fd.balance.patrimonio[lastYear] || null;

      const debtEquity = patrimonioLast ? safeDivide(deudaNetaLast, patrimonioLast) : null;
      const liquidez = fd.balance.pasivoCorriente[lastYear] ? safeDivide(fd.balance.activoCorriente[lastYear], fd.balance.pasivoCorriente[lastYear]) : null;

      const gastosIntereses = Math.abs(fd.eerr.gastosIntereses[lastYear] || 0);
      const ebit = fd.eerr.ebit[lastYear];
      let cobertura = null;
      if (Number.isFinite(ebit) && gastosIntereses > 0) {
        cobertura = ebit / gastosIntereses;
      }

      // 2. Generar Conclusi√≥n
      const conclusion = generateDebtConclusion(debtEquity, liquidez, cobertura, deudaNetaLast, patrimonioLast, ebit);

      // 3. Preparar Series Hist√≥ricas para el Gr√°fico Mixto (Barras + L√≠neas)
      const years = trimArray(fd.years, 5);
      const chartData = years.map(year => {
        // Valores absolutos para barras apiladas
        let dTotal = fd.balance.deudaTotal?.[year];
        if (!Number.isFinite(dTotal)) {
          dTotal = (fd.balance.deudaCortoPlazo[year] || 0) + (fd.balance.deudaLargoPlazo[year] || 0);
        }
        const caja = (fd.balance.efectivo[year] || 0) + (fd.balance.efectivoRestringido?.[year] || 0);
        const deudaNeta = dTotal - caja;
        const patrimonio = fd.balance.patrimonio[year] || 0;

        // Ratios para l√≠neas
        const solvencia = patrimonio > 0 ? safeDivide(deudaNeta, patrimonio) : null;

        const activoCorriente = fd.balance.activoCorriente[year] || null;
        const pasivoCorriente = fd.balance.pasivoCorriente[year] || null;
        const liquidez = pasivoCorriente ? safeDivide(activoCorriente, pasivoCorriente) : null;

        const ebit = fd.eerr.ebit[year];
        const gastosIntereses = Math.abs(fd.eerr.gastosIntereses[year] || 0);
        let cobertura = null;
        if (Number.isFinite(ebit) && gastosIntereses > 0) {
          cobertura = ebit / gastosIntereses;
        }

        return {
          year,
          patrimonio,      // Para barra base
          deudaNeta,       // Para barra superior
          solvencia,       // Ratio D/E (para mostrar en label)
          liquidez,        // Para l√≠nea
          cobertura        // Para l√≠nea
        };
      });

      return {
        deudaTotal: deudaTotalLast,
        caja: cajaLast,
        deudaNeta: deudaNetaLast,
        deudaSobrePatrimonio: debtEquity,
        liquidezCorriente: liquidez,
        coberturaIntereses: cobertura,
        conclusion,
        chartData // Datos hist√≥ricos (valores absolutos + ratios) para el gr√°fico
      };
    }

    function generateEfficiencyConclusion(trendAssets, trendInventory, trendReceivables, trendPayables, trendPPE, salesChange, rotActivosActual, rotInventariosActual, activosChange, trendWorkingCap, rotCapitalTrabajoActual, trendVentasGlobal) {
      // 1. C√°lculos Previos
      // D√≠as de Inventario (DSI)
      const diasInventario = rotInventariosActual > 0 ? Math.round(365 / rotInventariosActual) : null;

      // 2. Definir ESTADO (Nivel Absoluto)
      // ¬øEs una empresa pesada o √°gil HOY?
      let currentStatus = "neutral";
      if (diasInventario !== null) {
        if (diasInventario > 150) currentStatus = "malo"; // Muy pesada
        else if (diasInventario < 90) currentStatus = "bueno"; // √Ågil
      }

      // 3. Definir TENDENCIA (Cambio Relativo)
      // ¬øEst√° mejorando o empeorando?
      // Trend negativa en ratios de d√≠as/activos suele implicar MEJORA (menos d√≠as es mejor, menos activos para misma venta es mejor)
      // Asumamos que si trendInventory (cambio en d√≠as o nivel) es positivo => Empeora (m√°s d√≠as).
      // Si trendInventory es negativo => Mejora (menos d√≠as).

      let trendStatus = "neutral";
      if (trendInventory !== null) {
        if (trendInventory > 0.05) trendStatus = "empeora"; // +5% d√≠as
        else if (trendInventory < -0.05) trendStatus = "mejora"; // -5% d√≠as
      }

      // 4. MATRIZ DE CONCLUSI√ìN (NUEVA L√ìGICA DE DIVERGENCIA)
      let title = "";
      let message = "";
      let type = "neutral";
      let icon = "‚õñÔ∏è";

      // 0. PRIORIDAD: Ajuste por Contracci√≥n (M√≥dulo 1 Manda)
      // Si las ventas caen fuerte, cualquier mejora en eficiencia puede ser solo achicamiento
      if (trendVentasGlobal && trendVentasGlobal < -0.05 && (trendStatus === "mejora" || currentStatus === "bueno" || Math.abs(trendInventory) < 0.10)) {
        title = "‚ö†Ô∏è Ajuste por Contracci√≥n";
        message = `La aparente estabilidad o mejora en los ratios de eficiencia es enga√±osa. Como las ventas caen fuertemente (${fmtPercent(trendVentasGlobal)}) <strong>respecto al hist√≥rico</strong>, la empresa est√° obligada a reducir activos solo para mantener el ritmo. No es eficiencia real, es achicamiento preventivo.`;
        type = "warning";
        icon = "üìâ";
      }
      // 1. Detectar Divergencia (Inventario cae fuerte <-10% Y Cap. Trabajo sube fuerte >+10%)
      else if (trendInventory < -0.10 && trendWorkingCap > 0.10) {
        title = "‚ö†Ô∏è Divergencia: Deterioro Operativo con Ajuste de Caja";
        type = "warning";
        message = `Se observa una contradicci√≥n cr√≠tica: mientras la rotaci√≥n f√≠sica de inventarios parece mejorar (${fmtPercent(Math.abs(trendInventory))} <strong>frente al promedio hist√≥rico</strong>), la rotaci√≥n de capital de trabajo empeora un ${fmtPercent(trendWorkingCap)}. Esto indica que la empresa est√° financiando ineficiencias con deuda de corto plazo o quemando caja.`;
        icon = "‚ö†Ô∏è";
      }
      // 2. Detectar Deterioro Generalizado (Activos e Inventarios caen ambos fuerte)
      // Nota: Si trendInventory es positivo significa que aumentan los d√≠as (peor). Si trendInventory es negativo, bajan los d√≠as (mejor).
      // CORRECCI√ìN INTERPRETACI√ìN:
      // trendInventory > 0 => Aumentan d√≠as => Empeora.
      // trendAssets < 0 => Caen activos => Mejora rotaci√≥n (Sales/Assets sube)? No, Sales/Assets = Rotaci√≥n.
      // trendAssets es cambio en Rotaci√≥n. Si Rotaci√≥n cae (<0), empeora.
      // trendInventory es cambio en Rotaci√≥n Inventario (Sales/Inv). Si estuvi√©ramos usando D√≠as, ser√≠a al rev√©s.
      // REVISAR INPUTS: trendInventory viene de (rotActual/rotProm - 1).
      // Si Rotaci√≥n sube, trend es positivo => MEJORA.
      // Si Rotaci√≥n baja, trend es negativo => EMPEORA.
      // EN EL C√ìDIGO ORIGINAL: if (trendInventory > 0.05) trendStatus = "empeora" -> Esto sugiere que trendInventory NO es rotaci√≥n, sino D√çAS.
      // PERO los argumentos dicen "trendInventory". Vamos a asumir que el usuario quiere la l√≥gica tal cual la pidi√≥ para el caso de "Inventory cae fuerte (< -10%)".
      // Si el usuario dice "Inventario cae fuerte (< -10%)", asume que el valor num√©rico baja.

      // Aplicando l√≥gica de usuario DIRECTA:
      else if (trendAssets < -0.05 && trendInventory < -0.05) {
        title = "üìâ Deterioro de Eficiencia Operativa";
        type = "bad";
        message = `La empresa se ha vuelto m√°s "pesada". La rotaci√≥n de activos ha ca√≠do un ${fmtPercent(Math.abs(trendAssets))} y la de inventarios un ${fmtPercent(Math.abs(trendInventory))} <strong>en comparaci√≥n con sus promedios hist√≥ricos</strong>. Esto indica que las ventas no est√°n acompa√±ando el nivel de inversi√≥n en la estructura.`;
        icon = "üìâ";
      }
      // 3. Estabilidad (Solo si cambios son peque√±os)
      else if (Math.abs(trendAssets) < 0.10 && Math.abs(trendInventory) < 0.10) {
        title = "‚õñÔ∏è Operaci√≥n Estable";
        message = "La empresa mantiene sus m√©tricas de eficiencia estables, sin cambios dr√°sticos en su ciclo de conversi√≥n de efectivo o rotaci√≥n de activos.";
        type = "neutral";
        icon = "‚öñÔ∏è";
      }
      // FALLBACK: Mantener l√≥gica original b√°sica para otros casos
      else if (currentStatus === "malo" && trendStatus === "empeora") {
        title = "‚õî DETERIORO CR√çTICO (ESTRUCTURA PESADA)";
        message = `La empresa ya era ineficiente y la situaci√≥n se agrava. Consume mucho capital de trabajo.`;
        type = "bad";
        icon = "üê¢";
      }
      else if (currentStatus === "bueno" && trendStatus === "mejora") {
        title = "üíé M√ÅQUINA DE EFICIENCIA OPERATIVA";
        message = `La empresa combina una estructura ligera con una tendencia de mejora continua.`;
        type = "excellent";
        icon = "üöÄ";
      }
      else {
        title = "‚ö†Ô∏è Cambio en Eficiencia Mixto";
        message = `Se observan movimientos mixtos en la eficiencia. Revisar rotaci√≥n espec√≠fica de inventarios y activos.`;
        type = "warning";
      }

      return { title, message, type, icon };
    }

    function runModule6Eficiencia(fd, m1) { // Recibe m1
      const years = fd.years;

      // Context from Module 1
      const trendVentas = m1?.cagr?.ventas?.value ?? m1?.cagr?.ventas ?? 0;

      // 1. Tabla Hist√≥rica
      const tabla = fd.years.map((year) => {
        const ventas = fd.eerr.ventas[year] || null;
        const activos = fd.balance.totalActivos[year] || null;
        const activoCorriente = fd.balance.activoCorriente[year] || null;
        const pasivoCorriente = fd.balance.pasivoCorriente[year] || null;
        const inventarios = fd.balance.inventarios[year] || null;
        const cogs = fd.eerr.cogs[year] || null;

        const capitalTrabajo = (activoCorriente !== null && pasivoCorriente !== null) ? activoCorriente - pasivoCorriente : null;

        return {
          year,
          ventas, // Guardamos ventas para el gr√°fico
          rotActivos: safeDivide(ventas, activos),
          rotCapitalTrabajo: (capitalTrabajo && capitalTrabajo !== 0) ? safeDivide(ventas, capitalTrabajo) : null,
          rotInventarios: safeDivide(cogs, inventarios),

          // Datos auxiliares para diagn√≥stico forense
          activos,
          inventarios,
          cogs, // ADD THIS FOR DEBUG
          cobranza: fd.balance.cuentasPorCobrar[year] || null,
          ppe: fd.balance.ppe[year] || null
        };
      });

      // 2. C√°lculo Forense de Tendencias (√öltimo A√±o vs Promedio Anterior)
      const calcTrend = (key) => {
        const values = tabla.map(r => r[key]).filter(n => Number.isFinite(n));
        if (values.length < 2) return 0;
        const last = values[values.length - 1];
        const prevValues = values.slice(0, -1);
        const avg = prevValues.reduce((a, b) => a + b, 0) / prevValues.length;
        return avg !== 0 ? (last - avg) / avg : 0;
      };

      const salesChange = calcTrend('ventas');
      const trendAssets = calcTrend('rotActivos');
      const trendInventory = calcTrend('rotInventarios');
      const trendWorkingCap = calcTrend('rotCapitalTrabajo');

      // Tendencias de volumen para el diagn√≥stico
      const trendInventoryVol = calcTrend('inventarios');
      const trendReceivablesVol = calcTrend('cobranza');
      const trendPPEVol = calcTrend('ppe');

      // Obtener valores absolutos del √∫ltimo a√±o
      const lastRow = tabla[tabla.length - 1];
      const rotActivosActual = lastRow?.rotActivos || null;
      const rotInventariosActual = lastRow?.rotInventarios || null;
      const rotCapitalTrabajoActual = lastRow?.rotCapitalTrabajo || null;

      // Calcular cambio en activos totales
      // Calcular cambio en activos totales
      const activosChange = calcTrend('activos');

      // 3. Generar Conclusi√≥n
      const conclusion = generateEfficiencyConclusion(
        trendAssets,
        trendInventory,
        calcTrend('cobranza'),
        0,
        trendPPEVol,
        salesChange,
        rotActivosActual,
        rotInventariosActual,
        activosChange,
        trendWorkingCap,
        rotCapitalTrabajoActual,
        trendVentas
      );

      return {
        tabla,
        trends: {
          assets: trendAssets,
          inventory: trendInventory,
          workingCap: trendWorkingCap
        },
        conclusion
      };
    }

    function generateGrowthConclusion(cagrSales, cagrIncome, cagrEquity, cagrFCFE) {
      // 1. Validaci√≥n de Datos
      if (cagrSales === null) {
        return {
          title: "Datos Insuficientes",
          message: "Historial no disponible para calcular tasas de crecimiento.",
          type: "neutral",
          icon: "‚ö™"
        };
      }

      let title = "";
      let message = "";
      let type = "neutral";
      let icon = "üìä";

      // Formatear valores
      const ventasStr = fmtPercent(cagrSales);
      const utilidadStr = (cagrIncome !== null && cagrIncome !== undefined) ? fmtPercent(cagrIncome) : "N/A (P√©rdidas)";
      const fcfeStr = (cagrFCFE !== null && cagrFCFE !== undefined) ? fmtPercent(cagrFCFE) : "N/A";

      // LOGIC: SCENARIO DETECTION
      const salesVal = cagrSales || 0;
      const incomeVal = (cagrIncome !== null && cagrIncome !== undefined) ? cagrIncome : -999; // Force negative check if null

      // ESCENARIO 1: PROFITLESS GROWTH (Ventas suben > 10%, pero Utilidad Neta es negativa o cae)
      // User Req: "Ventas suben >10%, pero Utilidad Neta es negativa o cae"
      if (salesVal > 0.10 && (incomeVal < 0 || incomeVal < (salesVal * 0.1))) { // income declining (<0) or very weak growth compared to sales
        title = "‚ö†Ô∏è EXPANSI√ìN COMERCIAL SIN RENTABILIDAD";
        type = "warning";
        icon = "‚ö†Ô∏è";
        message = `La empresa ha logrado expandir sus ventas (+${ventasStr}), pero este crecimiento es ineficiente. La utilidad no acompa√±a el volumen, terminando en terreno negativo o estancado. La empresa es m√°s grande, pero menos rentable.`;
      }
      // ESCENARIO 2: COMPOUNDER (Ventas suben, Utilidad sube igual o m√°s)
      else if (salesVal > 0.05 && incomeVal >= salesVal * 0.8) {
        title = "üíé CRECIMIENTO VIRTUOSO (COMPOUNDER)";
        type = "excellent";
        icon = "üíé";
        message = `El Santo Grial. La empresa escala sus ventas al ${ventasStr} y mejora su eficiencia, haciendo crecer sus beneficios a un ritmo similar o superior (${utilidadStr}). Es crecimiento real y sostenible.`;
      }
      // ESCENARIO 3: TURNAROUND (Ventas caen/planas, Utilidad sube)
      else if (salesVal < 0.02 && incomeVal > 0.05) {
        title = "üîß OPTIMIZACI√ìN Y ENFOQUE (TURNAROUND)";
        type = "good";
        icon = "üîß";
        message = `La empresa se est√° enfocando en rentabilidad m√°s que en tama√±o. Sus ventas no crecen (${ventasStr}) pero sus utilidades aumentan (${utilidadStr}), optimizando sus m√°rgenes.`;
      }
      // ESCENARIO 4: IMPLOSI√ìN / CONTRACCI√ìN (Ventas bajan < 0%)
      else if (salesVal < 0) {
        title = "üîª CONTRACCI√ìN DE NEGOCIO";
        type = "bad";
        icon = "üîª";
        message = `El negocio pierde tracci√≥n comercial. Las ventas retroceden un ${ventasStr} anual, lo que pone en riesgo la viabilidad futura si no se revierte la tendencia.`;
      }
      // Default
      else {
        title = "‚öñÔ∏è Crecimiento Mixto";
        type = "neutral";
        message = `El desempe√±o es mixto: Ventas creciendo al ${ventasStr} con Utilidad al ${utilidadStr}.`;
      }

      // ADD-ON: CAJA (Siempre a√±adir nota de FCFE)
      if (cagrFCFE !== null && cagrFCFE !== undefined) {
        const fcfeAction = cagrFCFE >= 0 ? "generado" : "consumido";
        message += `<br><br>Esta din√°mica ha ${fcfeAction} caja libre a un ritmo del ${fmtPercent(cagrFCFE)} anual.`;

        // Check for cash burning in "growth" scenarios to downgrade type
        if (cagrFCFE < -0.05 && type === "excellent") {
          type = "neutral";
          message += " (Alerta: El crecimiento consume caja).";
        }
      } else {
        message += `<br><br>Datos de Flujo de Caja Libre (FCFE) no disponibles para confirmar sostenibilidad.`;
      }

      return { title, message, type, icon };
    }

    function runModule7Crecimiento(fd) {
      const years = trimArray(fd.years, 5);

      // Construir series
      const ventasSeries = buildSeries(fd.eerr.ventas, years);
      const beneficioSeries = buildSeries(fd.eerr.beneficioNeto, years);
      const patrimonioSeries = buildSeries(fd.balance.patrimonio, years);
      const fcfeSeries = years.map((year) => ({ year, value: calcFCFEReal(fd, year) }));

      // Calcular CAGRs usando la nueva funci√≥n estricta
      const cagrVentas = computeStrictCAGR(
        ventasSeries.map(s => s.value),
        ventasSeries.map(s => s.year)
      );
      const cagrBeneficioNeto = computeStrictCAGR(
        beneficioSeries.map(s => s.value),
        beneficioSeries.map(s => s.year)
      );
      const cagrPatrimonio = computeStrictCAGR(
        patrimonioSeries.map(s => s.value),
        patrimonioSeries.map(s => s.year)
      );
      const cagrFCFE = computeStrictCAGR(
        fcfeSeries.map(s => s.value),
        fcfeSeries.map(s => s.year)
      );

      // Generar Conclusi√≥n Narrativa (usa solo el valor del CAGR)
      const conclusion = generateGrowthConclusion(
        cagrVentas.value,
        cagrBeneficioNeto.value,
        cagrPatrimonio.value,
        cagrFCFE.value
      );

      return {
        years,
        cagrs: {
          ventas: cagrVentas,
          beneficio: cagrBeneficioNeto,
          patrimonio: cagrPatrimonio,
          fcfe: cagrFCFE
        },
        series: {
          ventas: ventasSeries,
          beneficio: beneficioSeries,
          patrimonio: patrimonioSeries,
          fcfe: fcfeSeries
        },
        conclusion
      };
    }

    function calculateInvestmentQuality(m1, m2, m4, m5, m6, m7) {
      // 0. VALIDACI√ìN CR√çTICA: Si no hay datos b√°sicos, Score = 0
      if (!m1 || !m1.estructural || !m1.actual) {
        return {
          score: 0,
          rating: "N/A",
          risks: ["Datos insuficientes para calcular score"],
          strengths: [],
          killSwitchActive: "SIN DATOS",
          colorClass: "bg-slate-100 text-slate-500"
        };
      }

      let score = 100; // Base Score
      let risks = [];
      let strengths = [];
      let killSwitchActive = null;
      let maxScoreCap = 100;

      // ============================================
      // FASE 0: KILL SWITCHES (SEGURIDAD PRIMERO)
      // ============================================

      // 1. QUIEBRA T√âCNICA / INSOLVENCIA (Patrimonio <= 0)
      // Detectamos por t√≠tulo de M5 (Insolvencia) o valor expl√≠cito si est√° disponible.
      const isInsolvent = m5?.conclusion?.title?.includes("INSOLVENCIA") || (m1?.actual?.patrimonioNeto !== undefined && m1?.actual?.patrimonioNeto <= 0);
      if (isInsolvent) {
        maxScoreCap = Math.min(maxScoreCap, 20); // CAP 20
        killSwitchActive = "QUIEBRA T√âCNICA";
        risks.push("‚õî KILL SWITCH: Patrimonio Negativo (Quiebra T√©cnica). La empresa no vale nada para el accionista hoy. Score Max: 20.");
      }

      // 2. RIESGO DE IMPAGO (Cobertura Intereses < 1)
      const coverage = m1?.actual?.coberturaIntereses;
      if (coverage !== undefined && coverage !== null && coverage < 1) {
        maxScoreCap = Math.min(maxScoreCap, 40); // CAP 40
        if (!killSwitchActive) killSwitchActive = "RIESGO DE IMPAGO";
        risks.push("‚õî KILL SWITCH: Cobertura de Intereses < 1x. La empresa no genera suficiente EBIT para pagar sus deudas. Score Max: 40.");
      }

      // 3. IMPLOSI√ìN DEL NEGOCIO (Ventas cayendo > 5% anual)
      const getCagr = (obj) => (obj && typeof obj === 'object') ? obj.value : obj;
      const cagrSales = getCagr(m7?.cagrs?.ventas);
      if (cagrSales !== undefined && cagrSales !== null && cagrSales < -0.05) {
        maxScoreCap = Math.min(maxScoreCap, 50); // CAP 50
        if (!killSwitchActive) killSwitchActive = "NEGOCIO EN DECLIVE";
        risks.push(`‚õî KILL SWITCH: Las ventas caen con fuerza (${fmtPercent(cagrSales)} anual). El negocio se est√° contrayendo estructuralmente. Score Max: 50.`);
      }

      // 4. DESTRUCTOR DE CAPITAL (M1 Bad)
      if (m1?.conclusion?.type === 'bad') {
        maxScoreCap = Math.min(maxScoreCap, 50);
        if (!killSwitchActive) killSwitchActive = "MODELO DESTRUCTIVO";
        risks.push("‚ö†Ô∏è Modelo de Negocio Destructivo (ROE < Costo Capital permanente).");
      }

      // 4b. DETERIORO ESTRUCTURAL GRAVE (M1 Red Severity) - NEW STRICT RULE
      if (m1?.debug?.diagnosis?.severity === 'red') {
        maxScoreCap = Math.min(maxScoreCap, 40);
        if (!killSwitchActive) killSwitchActive = "DETERIORO ESTRUCTURAL";
        risks.push("‚õî KILL SWITCH: Diagn√≥stico de Deterioro Estructural Severo (M√≥dulo 1). Score Max: 40.");
      }

      // 5. SOLVENCIA CR√çTICA GEN√âRICA (M5 Bad)
      if (m5?.conclusion?.type === 'bad') {
        maxScoreCap = Math.min(maxScoreCap, 30); // NEW STRICT RULE (was 40)
        if (!killSwitchActive) killSwitchActive = "ESTR√âS FINANCIERO";
        risks.push("‚õî SOLVENCIA CR√çTICA: Riesgo de quiebra mata valoraci√≥n. Score Max: 30.");
      }

      // ============================================
      // FASE 1: PENALIZACIONES (Descuentos al Score Base)
      // ============================================

      // 1. Calidad Estructural (M1)
      if (m1?.estructural?.roePromedioNormalizado < 0.10) {
        score -= 10;
        risks.push("Rentabilidad estructural mediocre (ROE < 10%).");
      }

      // 2. Generaci√≥n de Caja (M2)
      // Si el FCFE Yield es raqu√≠tico (< 2%) o negativo
      if (m2?.fcfeYield < 0.02) {
        score -= 10;
        risks.push("Generaci√≥n de caja d√©bil o nula.");
      }

      // 3. Eficiencia (M6)
      // Si la eficiencia es Mala o Empeora
      if (m6?.conclusion?.type === 'bad' || m6?.conclusion?.type === 'warning') {
        score -= 10;
        risks.push("Ineficiencia operativa creciente (Ciclos m√°s largos).");
      }

      // 4. Valoraci√≥n (M4) - Solo si est√° MUY cara
      if (m4?.conclusion?.type === 'warning' && m4?.roeImpl > 0.25) {
        score -= 10;
        risks.push("Valoraci√≥n exigente (Precio descuenta perfecci√≥n).");
      }

      // 5. Crecimiento Sin Rentabilidad (Profitless)
      // (User request: If Profitless -> -20)
      if (m7?.cagrs?.ventas?.value > 0.10 && (m7?.cagrs?.beneficio?.value < 0 || m1?.actual?.netIncome < 0)) {
        score -= 20;
        risks.push("‚ö†Ô∏è Crecimiento 'Profitless': Vende m√°s pero pierde dinero. Penalizaci√≥n -20 pts.");
      }

      // ============================================
      // FASE 2: BONIFICADORES (Solo si NO hay Kill Switch)
      // ============================================

      if (!killSwitchActive) {
        // 1. Fortaleza Financiera (Cash King)
        if (m5?.conclusion?.type === 'excellent') {
          score += 10;
          strengths.push("üíé BALANCE BLINDADO (Caja Neta Positiva).");
        }

        // 2. M√°quina de Valor (Compounder)
        if (m1?.conclusion?.type === 'excellent') {
          score += 10;
          strengths.push("üëë COMPOUNDER DE √âLITE (Alto ROE + Crecimiento).");
        }

        // 3. Eficiencia Operativa (M6 Excellent)
        if (m6?.conclusion?.type === 'excellent') {
          score += 5;
          strengths.push("üöÄ Excelencia Operativa (Mejorando rotaci√≥n).");
        }

        // 4. Valoraci√≥n Atractiva (M4 Excellent - Oportunidad)
        if (m4?.conclusion?.type === 'excellent') {
          score += 5;
          strengths.push("üí∞ Valoraci√≥n Atractiva (Margen de Seguridad).");
        }
      }

      // ============================================
      // FASE 3: CIERRE Y CLAMPING
      // ============================================

      // Aplicar Cap de Kill Switch
      if (maxScoreCap < 100) {
        score = Math.min(score, maxScoreCap);
      }

      // Asegurar rango 0-100
      score = Math.max(0, Math.min(100, score));

      // Determinar Etiqueta Final
      let rating = "MANTENER";
      let colorClass = "bg-yellow-100 text-yellow-800";

      if (score >= 80) {
        rating = "COMPRA FUERTE (STRONG BUY)";
        colorClass = "bg-emerald-100 text-emerald-800 border-emerald-300";
      } else if (score >= 65) {
        rating = "COMPRA (BUY)";
        colorClass = "bg-green-100 text-green-800 border-green-300";
      } else if (score >= 45) {
        rating = "MANTENER (HOLD)";
        colorClass = "bg-yellow-100 text-yellow-800 border-yellow-300";
      } else if (score >= 30) {
        rating = "VENTA (SELL)";
        colorClass = "bg-orange-100 text-orange-800 border-orange-300";
      } else {
        rating = "VENTA FUERTE (STRONG SELL)";
        colorClass = "bg-red-100 text-red-800 border-red-300";
      }

      // Si hay Kill Switch, forzar etiqueta de advertencia en el rating si no lo es ya
      if (killSwitchActive) {
        if (rating.includes("COMPRA")) {
          rating = "MANTENER (RIESGO ALTO)"; // Downgrade forzoso visual
          colorClass = "bg-orange-100 text-orange-800 border-orange-300";
        }
      }

      return { score, rating, risks, strengths, killSwitchActive, colorClass };
    }

    function runModule8PrecioFinal(fd, m0, m1, m2, m3, m4, m5, m6, m7) {
      // 1. Recopilaci√≥n de Precios (Safeguarded)
      const pDCF = m0?.pDCF || 0;
      const pPerObj = m3?.precioPerObj || 0;
      const pPbvObj = m3?.precioPbvObj || 0;

      // Calcular precios internos desde m√∫ltiplos hist√≥ricos
      // Safely access m2 and m3 properties
      const perPromedio = m2?.perPromedio ?? null;
      const epsBase = m3?.epsBase ?? null;
      const pbvPromedio = m2?.pbvPromedio ?? null;
      const bvpsBase = m3?.bvpsBase ?? null;

      const pInternoPer = (perPromedio !== null && epsBase !== null) ? perPromedio * epsBase : null;
      const pInternoPbv = (pbvPromedio !== null && bvpsBase !== null) ? pbvPromedio * bvpsBase : null;

      const pInternoPromedio = average([pInternoPer, pInternoPbv]) || 0;

      // DEBUG: Mostrar valores de M√≥dulo 3
      console.log('=== DEBUG M√ìDULO 3 - VALORES BASE ===');
      console.log('EPS Base:', epsBase);
      console.log('BVPS Base:', bvpsBase);
      console.log('PER Hist√≥rico (M2):', perPromedio);
      console.log('P/BV Hist√≥rico (M2):', pbvPromedio);
      console.log('Precio Interno PER:', pInternoPer);
      console.log('Precio Interno P/BV:', pInternoPbv);
      console.log('Precio Interno Promedio:', pInternoPromedio);
      console.log('=====================================');

      // Ponderaciones (Ajustables)
      const pesos = { dcf: 0.4, perObj: 0.2, pbvObj: 0.2, internos: 0.2 };

      let pFinal = (pDCF * pesos.dcf) +
        (pPerObj * pesos.perObj) +
        (pPbvObj * pesos.pbvObj) +
        (pInternoPromedio * pesos.internos);

      // Aplicar penalizaci√≥n si ven√≠a del contexto (M√≥dulo 1)
      let penaltyApplied = 0;
      if (state.context?.method?.penalty === 'MODERATE') { penaltyApplied = 0.10; pFinal *= 0.90; }
      if (state.context?.method?.penalty === 'HIGH') { penaltyApplied = 0.20; pFinal *= 0.80; }

      const precioActual = fd.datos.precioActualCLP || null;
      const upside = precioActual ? (pFinal - precioActual) / precioActual : null;

      // DEBUG: Mostrar componentes del precio
      console.log('=== DEBUG M√ìDULO 8 - PRECIO OBJETIVO ===');
      console.log('Componentes de Precio:');
      console.log('  - DCF (40%):', pDCF);
      console.log('  - PER Objetivo (20%):', pPerObj);
      console.log('  - P/BV Objetivo (20%):', pPbvObj);
      console.log('  - Hist√≥rico Promedio (20%):', pInternoPromedio);
      console.log('C√°lculo:');
      console.log('  - DCF * 0.4 =', pDCF * pesos.dcf);
      console.log('  - PER * 0.2 =', pPerObj * pesos.perObj);
      console.log('  - P/BV * 0.2 =', pPbvObj * pesos.pbvObj);
      console.log('  - Hist√≥rico * 0.2 =', pInternoPromedio * pesos.internos);
      console.log('Precio Final:', pFinal);
      console.log('Precio Actual:', precioActual);
      console.log('Upside:', upside);
      console.log('========================================');

      // 2. C√ÅLCULO DE SCORE DE CALIDAD
      const qualityAnalysis = calculateInvestmentQuality(m1, m2, m4, m5, m6, m7);
      const score = qualityAnalysis.score;

      // 3. GENERAR VEREDICTO (L√≥gica Estricta +/- 10%)
      let veredicto = { title: "", message: "", type: "neutral", icon: "" };

      const limiteSuperior = pFinal * 1.10;
      const limiteInferior = pFinal * 0.90;

      if (!precioActual) {
        veredicto = { title: "Sin Precio", message: "Falta precio actual.", type: "neutral", icon: "‚ö™" };
      }
      else if (precioActual > limiteSuperior) {
        veredicto = { title: "CARA (SOBREVALORADA)", message: "Precio > 110% del Precio Objetivo. Riesgo alto de correcci√≥n.", type: "bad", icon: "‚õî" };
      }
      else if (precioActual < limiteInferior) {
        veredicto = { title: "BARATA (OPORTUNIDAD)", message: "Precio < 90% del Precio Objetivo. Margen de seguridad atractivo.", type: "excellent", icon: "üü¢" };
      }
      else {
        veredicto = { title: "EN RANGO (PRECIO JUSTO)", message: "Precio en equilibrio (+/- 10% del Objetivo).", type: "neutral", icon: "‚öñÔ∏è" };
      }

      // 4. C√ÅLCULO DE TIME TO VALUE con validaci√≥n estricta de gExplicita
      let timeToValue = null;
      let growthRateCapped = false;

      // Paso 1: Extracci√≥n de gExplicita
      const gExplicita = m0?.gExplicita;

      // Paso 2: Validaci√≥n de Existencia
      if (gExplicita === null || gExplicita === undefined || isNaN(gExplicita)) {
        // ERROR CR√çTICO: No hay tasa de crecimiento expl√≠cita
        timeToValue = {
          error: "ERROR CR√çTICO: No se detect√≥ una tasa de crecimiento expl√≠cita (g) en el M√≥dulo DCF. Revise los inputs del M√≥dulo 2."
        };
      } else {
        // Paso 3: Tope de Seguridad (Cap al 20%)
        let growthRate = gExplicita;
        if (gExplicita > 0.20) {
          growthRate = 0.20;
          growthRateCapped = true;
          console.warn(`[M√≥dulo 10] Tasa de crecimiento original (${(gExplicita * 100).toFixed(1)}%) excede el tope de seguridad. Limitada al 20%.`);
        }

        // Calcular Time to Value con la tasa validada
        timeToValue = calculateTimeToValue(pFinal, precioActual, growthRate);

        // Agregar flag de tope aplicado
        if (timeToValue && growthRateCapped) {
          timeToValue.growthRateCapped = true;
          timeToValue.originalGrowthRate = gExplicita;
        }
      }


      return {
        pDCF, pPerObj, pPbvObj, pInternoPromedio, pFinal,
        pPerHist: pInternoPer,  // Precio v√≠a PER hist√≥rico
        pPbvHist: pInternoPbv,  // Precio v√≠a P/BV hist√≥rico
        upside, precioActual,
        veredicto,
        score: score,
        risks: qualityAnalysis.risks,
        strengths: qualityAnalysis.strengths,
        timeToValue: timeToValue, // Agregar timeToValue al retorno
        debug: { inputs: { pDCF, pPerObj, pPbvObj }, weights: pesos }
      };
    }

    // ---------- Helpers for modules ----------
    function calcFCFEReal(fd, year) {
      const cgo = fd.fcfe.cajaOperaciones[year] || 0;
      const capex = fd.fcfe.capex[year] || 0;
      const debtIssued = fd.fcfe.deudaEmitida[year] || 0;
      const debtRepaid = fd.fcfe.deudaReembolsada[year] || 0;
      return cgo + capex + debtIssued + debtRepaid;
    }

    function buildSeries(seriesObj, years) {
      return years.map((year) => ({ year, value: seriesObj[year] ?? null })).filter((row) => row.value !== null);
    }

    function computeCAGR(series) {
      if (!series || series.length < 2) return null;
      const first = series[0];
      const last = series[series.length - 1];
      if (!first.value || !last.value || first.value <= 0 || last.value <= 0) return null;
      const periods = last.year - first.year || series.length - 1;
      if (periods <= 0) return null;
      return Math.pow(last.value / first.value, 1 / periods) - 1;
    }

    // ============================================
    // MODULE 9: OPPORTUNITY COST & YIELD SIMULATOR
    // ============================================

    function runModule9Yield(fd, module1, module2, module8, module0) {
      console.log('[MODULE 9 YIELD] ===== STARTING =====');

      try {
        // Get benchmark rates from YIELD sheet
        const benchmarks = fd.yield || {
          dap: 0.05,
          moneyMarket: 0.05,
          bono: 0.0485,
          ipsa: 0.12,
        };

        // Calculate company yields
        const company = calculateCompanyYields(fd, module1, module2, module8);

        // Calculate spread vs bond (risk premium)
        const spread = company.fcfeYield !== null ? company.fcfeYield - benchmarks.bono : null;

        // Generate conclusion
        const conclusion = generateYieldConclusion(company, benchmarks, spread);

        // EXTRAER G PARA EL GR√ÅFICO (CONEXI√ìN CR√çTICA)
        // Usamos la g expl√≠cita del DCF. Si no existe, usamos 0.
        const growthRateUsed = module0?.gExplicita || 0;
        console.log('[MODULE 9 YIELD] Growth Rate Imported:', growthRateUsed);

        return {
          company,
          benchmarks,
          spread,
          conclusion,
          gUsed: growthRateUsed // <--- DATO CLAVE PARA EL GR√ÅFICO
        };

      } catch (error) {
        console.error('[MODULE 9 YIELD] Error:', error);
        throw error;
      }
    }

    function calculateCompanyYields(fd, module1, module2, module8) {
      const lastYear = fd.years[fd.years.length - 1];
      const shares = fd.datos.numeroAcciones || null;
      const precioActual = fd.datos.precioActualCLP || null;

      // 1. Dividend Yield (Cash Flow to Pocket)
      let dividendYield = null;
      const dividendosEERR = fd.eerr?.dividendos?.[lastYear];
      const dividendosFCFE = fd.fcfe?.dividendos?.[lastYear];
      const dividendos = dividendosFCFE || dividendosEERR || 0;

      // Market Cap = Price * Shares
      const marketCap = (precioActual && shares) ? precioActual * shares : null;

      if (marketCap && marketCap > 0 && dividendos) {
        dividendYield = Math.abs(dividendos) / marketCap;
      }

      // 2. Earnings Yield (Accounting Return)
      let earningsYield = null;
      const perActual = module1?.actual?.perReal || module2?.perActual || null;

      if (perActual && perActual > 0) {
        earningsYield = 1 / perActual;
      }

      // 3. FCFE Yield (Intrinsic Value Return)
      let fcfeYield = null;

      // Try to get from module2 first
      if (module2?.fcfeYield) {
        fcfeYield = module2.fcfeYield;
      } else if (marketCap && marketCap > 0) {
        // Calculate manually
        const fcfeLastYear = calcFCFEReal(fd, lastYear);
        if (fcfeLastYear && fcfeLastYear !== 0) {
          fcfeYield = fcfeLastYear / marketCap;
        }
      }

      return {
        dividendYield,
        earningsYield,
        fcfeYield,
        dividendos,
        marketCap,
        perActual,
      };
    }

    function generateYieldConclusion(company, benchmarks, spread) {
      const messages = [];
      let type = 'neutral';
      let icon = '‚öñÔ∏è';

      // 1. Spread Analysis (FCFE vs Bond)
      if (spread !== null) {
        if (spread < 0) {
          type = 'bad';
          icon = '‚õî';
          messages.push(`üö® ALERTA: Destrucci√≥n de Valor Relativo. El rendimiento FCFE (${fmtPercent(company.fcfeYield)}) es MENOR que los Bonos (${fmtPercent(benchmarks.bono)}). Mejor comprar Bonos sin riesgo.`);
        } else if (spread > 0.05) {
          type = 'excellent';
          icon = 'üíé';
          messages.push(`üíé OPORTUNIDAD: El riesgo extra est√° bien compensado. Spread de +${fmtPercent(spread)} vs Bonos. Prima de riesgo atractiva.`);
        } else {
          type = 'good';
          icon = '‚úÖ';
          messages.push(`‚úÖ ACEPTABLE: Compensaci√≥n moderada por riesgo. Spread de +${fmtPercent(spread)} vs Bonos.`);
        }
      }

      // 2. Dividend Comparison vs DAP
      if (company.dividendYield !== null) {
        if (company.dividendYield > benchmarks.dap) {
          messages.push(`üí∞ FLUJO ATRACTIVO: Dividend Yield (${fmtPercent(company.dividendYield)}) supera al DAP (${fmtPercent(benchmarks.dap)}). Genera m√°s flujo de caja que alternativas sin riesgo.`);
        } else if (company.dividendYield > 0) {
          messages.push(`üìä FLUJO MODERADO: Dividend Yield (${fmtPercent(company.dividendYield)}) por debajo del DAP (${fmtPercent(benchmarks.dap)}). Prioriza crecimiento sobre distribuci√≥n.`);
        } else {
          messages.push(`‚ö†Ô∏è SIN DIVIDENDOS: La empresa no distribuye dividendos. Todo el retorno depende de apreciaci√≥n de capital.`);
        }
      }

      // 3. Earnings Yield vs IPSA
      if (company.earningsYield !== null && benchmarks.ipsa) {
        if (company.earningsYield > benchmarks.ipsa) {
          messages.push(`üèÜ SUPERA MERCADO: Earnings Yield (${fmtPercent(company.earningsYield)}) mayor que IPSA (${fmtPercent(benchmarks.ipsa)}). Rentabilidad contable superior al mercado.`);
        }
      }

      return {
        type,
        icon,
        messages,
        summary: messages[0] || 'An√°lisis de costo de oportunidad completado.',
      };
    }

    function computeCAGRIgnoreNeg(series) {
      if (!series || series.length < 2) return null;
      const positives = series.filter((row) => row.value > 0);
      if (positives.length < 2) return null;
      const first = positives[0];
      const last = positives[positives.length - 1];
      const periods = last.year - first.year || positives.length - 1;
      if (periods <= 0) return null;
      return Math.pow(last.value / first.value, 1 / periods) - 1;
    }

    function trimLastN(arr, n) {
      return arr.slice(-n);
    }

    function trimArray(arr, n) {
      return arr.length <= n ? [...arr] : arr.slice(-n);
    }

    function mergeSeries(primary, secondary) {
      const result = { ...secondary };
      Object.keys(primary || {}).forEach((year) => {
        result[year] = primary[year];
      });
      return result;
    }

    function mapSeries(series, years) {
      const mapped = {};
      years.forEach((year) => {
        mapped[year] = series[year] ?? null;
      });
      return mapped;
    }

    function mapSeriesFCFE(fd, years) {
      const mapped = {};
      years.forEach((year) => {
        mapped[year] = calcFCFEReal(fd, year);
      });
      return mapped;
    }

    function findLastValue(values, predicate) {
      if (!Array.isArray(values) || !values.length) return null;
      for (let idx = values.length - 1; idx >= 0; idx -= 1) {
        const value = values[idx];
        if (predicate(value)) {
          return value;
        }
      }
      return null;
    }

    function evaluateSignal(current, averageValue) {
      if (!current || !averageValue) return 'Sin datos';
      if (current < 0.8 * averageValue) return 'Barato vs historia';
      if (current > 1.2 * averageValue) return 'Caro vs historia';
      return 'En l√≠nea';
    }

    function classifySemaphore(value, thresholds, labels) {
      if (value === null || value === undefined) return 'Sin datos';
      if (value < thresholds[0]) return labels[0];
      if (value < thresholds[1]) return labels[1];
      return labels[2];
    }

    // ---------- Theme toggle ----------
    const themeToggle = document.getElementById('theme-toggle');
    const iconLight = document.getElementById('icon-light');
    const iconDark = document.getElementById('icon-dark');
    const prefersDark = localStorage.getItem('theme') === 'dark' || (!localStorage.getItem('theme') && window.matchMedia('(prefers-color-scheme: dark)').matches);
    if (prefersDark) {
      document.documentElement.classList.add('dark');
      iconLight.classList.remove('hidden');
      iconDark.classList.add('hidden');
    }
    themeToggle.addEventListener('click', () => {
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      iconLight.classList.toggle('hidden', !isDark);
      iconDark.classList.toggle('hidden', isDark);
      if (moduleResults) {
        renderResults(moduleResults);
      }
    });
  </script>
</body>

</html>
